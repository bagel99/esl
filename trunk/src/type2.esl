// Copyright (c) 2009-2011, Brian G. Lucas.  See LICENSE file.
// $Id: type2.esl 643 2011-10-31 22:03:17Z bgl $

package type
{
    type fwd:
	{   next: @fwd;
	    symb: Symb;
	    type: Type;
	};
    type pfwd: @fwd;
    var fwdlist: pfwd;

    proc FwdAdd(s: Symb, t: Type)
    {   var f: pfwd;

	f = pfwd(sys.zalloc(fwd?size));
	f@.symb = s;
	f@.type = t;
	f@.next = fwdlist;
	fwdlist = f;
	s@.forward = true;
    }

    proc FwdFix(s: Symb, bt: Type)
    {   var f, fn, fp: pfwd;

	fp = 0;
	f = fwdlist;
	while f != 0 do
	{   fn = f@.next;
	    if s == f@.symb then
	    {   f@.type@.base = bt;
		if fp != 0 then fp@.next = fn; else fwdlist = fn;
		// free(f)
	    }
	    fp = f;
	    f = fn;
	}
	s@.forward = false;
    }

    proc Def(tok: TokenT, bt: Type): Type;		// forward
    proc ParmList(procs: Symb, meths: Symb);		// forward
    proc Compat(t1: Type, t2: Type): boolean;		// forward

    proc SameTypeList(al: TypeList, bl: TypeList): boolean
    {
	while al != 0 && bl != 0 do
	{   if !Compat(al.type, bl.type) then return false;
	    al = al.next;
	    bl = bl.next;
	}
	return al == 0 && bl == 0;  // must both be at the end of the list
    }

    // FIXME: could use SameTypeList() if SymbNode extends from TypeListEntry
    proc SameSymbList(as: Symb, bs: Symb): boolean
    {
	while as != 0 && bs != 0 do
	{   if !Compat(as.type, bs.type) then return false;
	    as = as.next;
	    bs = bs.next;
	}
	return as == 0 && bs == 0;  // must both be at the end of the list
    }

    const KindName: [TypeT]@[]Char =
    {   "UKNOWN", "ENUM", "UINT", "SINT", "REF", "ARRAY", "RECORD", "REFPROC" };

    proc Compat(t1: Type, t2: Type): boolean
    {
	if t1 == 0 || t2 == 0 then return true;	// what should this be?
	if t1 == t2 then return true;		// the trivial case
	if t1@.kind != t2@.kind then return false;
	if t1@.atbase != 0 then return Compat(t1@.atbase, t2);
	if t2@.atbase != 0 then return Compat(t1, t2@.atbase);
	if t2@.kind
	is UINT, SINT then return true;
	is ENUM, RECORD then 
	{   // if t2 is a superset of t1 then they are compatable
	    if t2@.base != 0 then return Compat(t1, t2@.base);
	    return false;
	}
	is REF then    return Compat(t1@.base, t2@.base);
	is ARRAY then  return Compat(t1@.base, t2@.base);	// FIXME: check index?
	is REFPROC then
	    return SameSymbList(t1@.list@.parmlist, t2@.list@.parmlist) &&
	           SameTypeList(t1@.list@.retvlist, t2@.list@.retvlist);
	return false;
    }

    proc NeedSwap(t: Type, to: MemOrderT): boolean
    {   var fm: MemOrderT;

	if t@.size <= Target.membits then return false;
	fm = t@.memorder;
	if fm == NATIVE then fm = Target.order;
	if to == NATIVE then to = Target.order;
	return fm != to;
    }

    proc New(kind: TypeT): Type
    {   var t: Type;

	t = Type(sys.zalloc(TypeNode?size));
	t@.kind = kind;
	return t;
    }

    proc Clone(ot: Type): Type
    {   var nt: Type;

	nt = New(ot@.kind);
	nt@ = ot@;	// record copy
	nt@.name = 0;
	nt@.final = false;
    }
	
    proc ChangeOrder(told: Type, neworder: MemOrderT): Type
    {   var t: Type;

	t = Clone(told);
	t@.memorder = neworder;
	t@.final = true;
	return t;
    }

    const askip1:[4]TokenT = { PEND, SEMI, NONE };
    const askip2:[5]TokenT = { COMMA, PEND, SEMI, NONE };

    proc XLinkage(s: Symb)
    {   var tok: TokenT;

	tok = Token;
	if tok == PBEG then
	{   tok = Next();
	    if tok == STR then
	    {   s@.altsymb = symb.New(ALIAS, lex.StringBuf, PRIVATE);
		tok = Next();
	    }
	    else
	    {   s@.xaddr = expr.ConstScalar(type.wordtype);
		s@.linkage = FIXED;
	    }
	    lex.Expect(PEND);
	}
    }
    
    const tattrlist:[]TokenT =
    {	KPACK, KMPACK,
	KLSB, KMSB,
	KLE, KBE,
	KRO, KWO,
	KINPUT, KOUTPUT,
	KMEMSZ, KBITSZ, KALIGN,
	NONE
    };
    proc Attributes(s: Symb, t: Type,  sattrlist:@[]TokenT): Type
    {   var tok, atok: TokenT;
	var at: Type;

	// assert Token == COLON
	loop
	{   tok = Next();
	    if tok == ID then
	    {   atok = lex.Keyword(tattrlist);
		if atok != tok then
		{   // Handle type attribute
		    tok = Next();
		    if t@.final then
		    {   at = t;
			t = Clone(at);	// Will not be the same type
			t@.atbase = at;
		    }
		    if atok
		    is KPACK then   t@.packed = BIT;
		    is KMPACK then  t@.packed = MEM;
		    is KLSB then    t@.bitorder = LSB;
		    is KMSB then    t@.bitorder = MSB;
		    is KLE then     t@.memorder = LE;
		    is KBE then     t@.memorder = BE;
		    is KRO then     t@.access = RO;
		    is KWO then     t@.access = WO;
		    is KINPUT then  t@.input = true;
		    is KOUTPUT then t@.output = true;
		    is KMEMSZ then 
		    {   if tok == PBEG then
			{   tok = Next();
			    t@.width = BitSize(expr.ConstScalar(type.wordtype) *
					Target.membits);
			    lex.Expect(PEND);
			}
		    }		
		    is KBITSZ then 
		    {   if tok == PBEG then
			{   tok = Next();
			    t@.size = BitSize(expr.ConstScalar(type.wordtype));
			    lex.Expect(PEND);
			}
		    }		
		    is KALIGN then 
		    {   if tok == PBEG then
			{   tok = Next();
			    t@.align = BitSize(expr.ConstScalar(type.wordtype) *
					Target.membits);
			    lex.Expect(PEND);
			}
		    }		
		}
		else
		{   // Not a type attribute
		    if s != 0 then
		    {   // Perhaps a symbol attribute
			atok = lex.Keyword(sattrlist);
			if atok != tok then
			{   // Handle symbol attribute
			    tok = Next();
			    if atok
			    is KINLINE then  s@.linkage = INLINE;
			    is KGLOBAL then 
			    {   s@.linkage = GLOBAL;
				XLinkage(s);
			    }
			    is KEXTERN then 
			    {   s@.linkage = EXTERN;
				XLinkage(s);
			    }
			    is KSECTION then 
			    {   lex.ErrorI(BADATTR, lex.Ident);
				if tok == PBEG then
				{   tok = Next();
				    tok = lex.Skip(askip1);
				}
			    }
			}
			else
			    lex.ErrorI(BADATTR, lex.Ident);
		    }
		    else
		    {   lex.ErrorI(BADATTR, lex.Ident);
			tok = Next();
		    }
		}
	    }
	    else if tok != SEMI then
	    {   lex.Error(EXPECTID);
		tok = lex.Skip(askip2);
	    }
	    tok = Token;
	  exit tok != COMMA;
	}
	return t;
    }

    const nattrlist:[]TokenT = { NONE };

    proc TypeAttributes(t: Type): Type
    {
	return Attributes(0, t, nattrlist);
    }

    const vattrlist:[4]TokenT = { KEXTERN, KGLOBAL, NONE };
    proc VarAttributes(s: Symb, t: Type): Type
    {
	return Attributes(s, t, vattrlist);
    }

    const pattrlist:[4]TokenT = { KEXTERN, KGLOBAL, KINLINE, NONE };
    proc ProcAttributes(s: Symb)
    {   var t: Type;

	t = Attributes(s, s@.type, pattrlist);
	s@.type = t;
    }

    // replace with something clever
    proc bitsize(x: _uint64): 0..255
    {   var t: _uint64;
	var n: 0..255;

	n = 1;
	t = 1;
	while t < x do
	{   t = t<<1;
	    t += 1;
	    n += 1;
	}
	return n;
    }

    proc FieldPad(prev: Symb, pad: BitSize, index: symb.OffsT): symb.OffsT
    {   var last, s: Symb;

	last = prev@.next;
	while pad > 0 do
	{   s = symb.New(FIELD, "_", PRIVATE);
	    s@.type = bytetype;
	    s@.addr = index;
	    s@.ispad = true;
	    prev@.next = s;
	    prev = s;
	    index += 1;    
	    pad -= 1;
	}
	prev@.next = last;
	return index;	
    }

    proc Final(t: Type)
    {   var align: BitSize;
	var tlo, thi: BitSize;
	var f, prev: Symb;
	var index: symb.OffsT;
	var offs, mod: BitSize;

	if t != 0 && !t@.final then
	{
	    if t@.bitorder == NATIVE then
		t@.bitorder = LSB;
	    if t@.memorder == NATIVE then
		t@.memorder = Target.order;
	    if t@.size != 0 && t@.width == 0 then
		t@.width = target.isize(t@.size);
	    if t@.width != 0 && t@.size == 0 then
		t@.size = t@.width;
	    if t@.kind
	    is ENUM, UINT then 
	    {   if t@.size == 0 then
		    t@.size = bitsize(t@.hi);
		if t@.width == 0 then
		    t@.width = target.isize(t@.size);
		if t@.align == 0 then
		    t@.align = target.ialign(t@.size);
	    }
	    is SINT then 
	    {   if t@.size == 0 then
		{   tlo = bitsize(~t@.lo);
		    thi = bitsize(t@.hi);
		    if tlo > thi then
			t@.size = tlo+1;
		    else
			t@.size = thi+1;
		}
		if t@.width == 0 then
		    t@.width = target.isize(t@.size);
		if t@.align == 0 then
		    t@.align = target.ialign(t@.size);
	    }
	    is REF then 
	    {   // Make sure anonymous base types are final
		if t@.base != 0 && t@.base@.name == 0 then
		    Final(t@.base);
		t@.size  = Target.ptr.size;
		t@.width = Target.ptr.size;
		t@.align = Target.ptr.align;
	    }
	    is REFPROC then 
	    {   t@.size  = Target.ptr.size;
		t@.width = Target.ptr.size;
		t@.align = Target.ptr.align;
	    }
	    is RECORD then 
	    {   index = 0;
		offs = 0;
		align = 0;
		prev = 0;
		f = t@.list;
		while f != 0 do
		{   if f@.type != 0 then
		    {	Final(f@.type);
			if f@.type@.flex then
			{   if f@.next != 0 then    // flex must be final field
				lex.Error(BADFLEX);
			    else
				t@.flex = true;     // mark record as flex
			}
			if t@.packed == BIT then
			{
			    offs += f@.type@.size;
			}
			else
			{   var falign: BitSize;
			    falign = f@.type@.align;
			    mod = offs % falign;
//err.str("field: "); err.str(f@.ident);
//err.chr('('); err.uid(f@.addr);
//err.str(") offs=");  err.uid(offs);
//err.str(" align="); err.uid(falign);
			    if mod != 0 && t@.packed == NATIVE then
			    {
				index = FieldPad(prev,
						 (falign-mod)/Target.membits,
						 index);
//err.str(" pad="); err.uid(falign - mod);
				offs += falign - mod;
			    }
//err.str("==> ("); err.uid(index);
//err.str(") offs="); err.uid(offs); err.nl();
			    offs += f@.type@.width;
			    if falign > align then
				align = falign;
			}
		    }
		    f@.addr = index;
		    index += 1;
		    prev = f;
		    f = f@.next;
		}
//err.str("explicit size= "); err.uint(t@.size); err.nl();
//err.str("explicit width="); err.uint(t@.width); err.nl();
		if t@.size == 0 then    // no explicit attribute
		    t@.size = offs;
		if t@.width == 0 then
		{   if offs <= Target.regsize then
			t@.width = target.isize(offs);
		    else
			t@.width = offs;
		}
//err.str("initial width="); err.uint(t@.width); err.nl();
//err.str("initial align="); err.uint(align); err.nl();
		if align > 0 then
		{   mod = t@.width % align;
		    if mod != 0 then	// pad to alignment
			t@.width += align - mod;
		}
		else  
		    align = target.ialign(t@.size);
		if t@.align == 0 then
		    t@.align = align;
//err.str("final width="); err.uint(t@.width); err.nl();
//err.str("final align="); err.uint(t@.align); err.nl();
	    }
	    is ARRAY then 
	    {   if t@.base != 0 then
		{   Final(t@.base);
		    if t@.size == 0 then
			t@.size = BitSize(t@.base@.size * t@.hi);
		    if t@.width == 0 then
			t@.width = t@.size;
		    if t@.align == 0 then
		    {   if t@.packed != BIT then
			    t@.align = t@.base@.align;
			else
			    t@.align = 1;
		    }
		}
	    }
	    t@.final = true;
	}
    }

    proc Enum(bt: Type): Type
    {   var tok: TokenT;
	var t: Type;
	var vn, pvn: Symb;
	var v, vmax: _uint32;

	tok = Next();
	t = New(ENUM);
	v = 0;
	vmax = 0;
	pvn = 0;
	if bt != 0 then
	{   var vb: Symb;
	    if bt@.kind == ENUM then
	    {	// for each field in base type, copy to new type
		vb = bt@.list;
		while vb != 0 do
		{   vn = symb.New(CONSTANT, vb@.ident, PRIVATE);
		    if pvn != 0 then pvn@.next = vn;
				else t@.list = vn;
		    pvn = vn;
		    vn@.const = vb@.const;
		    v = _uint32(vb@.const@.valu);
		    if v > vmax then vmax = v;
		    vb = vb@.next;
		}
		v += 1;		// start with next value
	    }
	    else lex.Error(BASEENUM);
	}
	loop
	{   if tok == ID then
	    {   if !symb.IsUniqueLocal(t@.list, lex.Ident) then
		    lex.ErrorI(DEFID, lex.Ident);
		vn = symb.New(CONSTANT, lex.Ident, PRIVATE);
		if pvn != 0 then pvn@.next = vn;
			    else t@.list = vn;
		pvn = vn;
		tok = Next();
		if tok == ASGN then
		{   tok = Next();
		    vn@.const = expr.Const(type.wordtype);
		    vn@.const@.type = t;
		    tok = Token;
		    v = _uint32(vn@.const@.valu);
		}
		else
		    vn@.const = ast.Const(t, v);
	    }
	    else
		lex.Error(EXPECTID);
	    if v > vmax then vmax = v;
	  exit tok != COMMA;
	    tok = Next();
	    v += 1;
	}
	t@.lo = 0;
	t@.hi = vmax;
	lex.Expect(PEND);
	return t;
    }

    proc Record(bt: Type): Type
    {   var tok: TokenT;
	var t, ft: Type;
	var s, ps, bs: Symb;

	tok = Next();
	t = type.New(RECORD);
	ps = 0;
	t@.base = bt;
	if bt != 0 then
	{   if bt@.kind == RECORD then
	    {	// copy the record type
		bs = bt@.list;
		while bs != 0 do
		{   s = symb.New(FIELD, bs@.ident, PRIVATE);
		    if ps != 0 then ps@.next = s; else t@.list = s;
		    ps = s;
		    s@.type = bs@.type;
		    bs = bs@.next;
		}
	    }
	    else
	    {   bt = 0;
		lex.Error(BASERECORD);
	    }
	}
	while tok == ID do
	{   // look ahead before dealing with ident
	    tok = Next();
	    if tok
	    is COLON then 
	    {   if !symb.IsUniqueLocal(t@.list, lex.Ident) then
		    lex.ErrorI(DEFID, lex.Ident);
		s = symb.New(FIELD, lex.Ident, PRIVATE);
		if ps != 0 then ps@.next = s; else t@.list = s;
		ps = s;
		tok = Next();
		ft = Def(tok, 0);
		s@.type = ft;
		tok = Token;
		if tok == COLON then
		{   s@.type = TypeAttributes(ft);
		    tok = Token;
		}
		if tok == ASGN then
		{   tok = Next();
		    lex.ErrorS(NOTIMPL, "field inital values");
		}

	    }
	    else
		lex.Error(BADRECORD);
	    tok = lex.Expect(SEMI);
	}
	tok = lex.Expect(GEND);
	return t;
    }

    proc Array(): Type
    {   var tok: TokenT;
	var t, bt: Type;

	tok = Next();
	t = type.New(ARRAY);
	if tok != AEND then
	{
	    var tree: Ast;
	    tree = expr.Bool(0);
	    if tree != 0 then
	    {   if tree@.op
		is CONST then
		{   t@.hi = tree@.valu;
		    t@.index = type.wordtype;
		}
		is TYPE then
		{   if tree@.type@.kind
		    is ENUM, UINT then
		    {   t@.hi = tree@.type@.hi + 1;
			t@.index = tree@.type;
		    }
		    else lex.Error(BADINDEX);
		}
		else lex.Error(BADINDEX);
	    }
	}
	else
	    t@.flex = true;
	tok = lex.Expect(AEND);
	bt = Def(tok, 0);
	t@.base  = bt;
	return t;
    }

    proc Name(): Symb
    {   var s: Symb;

	s = symb.Find(lex.Ident);
	if s != 0 && s@.kind != TYPE then
	    lex.Error(NOTTYPE);
	return s;
    }

    proc DefProc(procs: Symb, meths: Symb)
    {   var s, prevs: Symb;
	var t: Type;
	var tl, tlprev: TypeList;
	var tok: TokenT;

	tok = Token;
	if tok == PBEG then
	{   tok = Next();
	    if meths != 0 then
		procs@.parmlist = meths;
	    if tok != PEND then
	    {   prevs = meths;	// 0 if not a method
		loop
		{   if tok == ID then
		    {   if !symb.IsUniqueLocal(procs@.parmlist, lex.Ident) then
			    lex.ErrorI(DEFID, lex.Ident);
			s = symb.New(VAR, lex.Ident, PRIVATE);
			tok = Next();
			s@.isparam = true;
			s@.linkage = LOCAL;
			t = unkntype;
			if tok == COLON then
			{   tok = Next();
			    t = type.Def(tok, 0);
			    type.Final(t);
			    tok = Token;
			}
			else lex.ErrorT(EXPECT, COLON);
			s@.type = t;
			if procs@.parmlist == 0 then
			    procs@.parmlist = s;
			if prevs != 0 then
			    prevs@.next = s;
			prevs = s;
		    }
		    else lex.Error(EXPECTID);
		  exit tok != COMMA;
		    tok = Next();
		}
	    }
	    tok = lex.Expect(PEND);
	}
	else lex.ErrorT(EXPECT, PBEG);
	if tok == COLON then	// parse returned value type
	{   tok = Next();
	    if tok != COLON then    // not an empty return type
	    {   tlprev = 0;
		loop
		{   t = type.Def(tok, 0);
		    type.Final(t);
		    tl = TypeList(sys.zalloc(TypeListEntry?size));
		    tl@.type = t;
		    if tlprev == 0 then
			procs@.retvlist = tl;
		    else
			tlprev@.next = tl;
		    tlprev = tl; 
		    tok = Token;
		  exit tok != COMMA;
		    tok = Next();
		}
		procs@.type = procs@.retvlist@.type;	// first ret type
	    }
	}
    }

    proc Ref(): Type
    {   var tok: TokenT;
	var t: Type;
	var bs: Symb;

	t = unkntype;		// in case all goes wrong
	tok = Next();
	if tok == ID then
	{
	    if symb.IsAnon(lex.Ident) then
	    {
		t = New(REFPROC);
		bs = symb.New(PROC, lex.Ident, PRIVATE);
		tok = Next();
		DefProc(bs, 0);
		t@.list = bs;
	    }
	    else
	    {   t = New(REF);
		bs = Name();
		if bs != 0 then
		{   if bs@.type != 0 then
			t@.base = bs@.type;
		    else	// already forward, add another reference
			FwdAdd(bs, t);
		}
		else	// undefined, make forward and make reference
		{   bs = symb.New(TYPE, lex.Ident, VISIBLE);
		    FwdAdd(bs, t);
		}
		tok = Next();
	    }
	}
	else
	{   t = New(REF);
	    t@.base = Def(tok, 0);
	}
	return t;
    }


    proc Def(tok: TokenT, bt: Type): Type
    {   var t: Type;
	var s: Symb;
	var vlo, vhi: Ast;

	t = unkntype;		// in case all goes wrong
	if tok
	is NUM, PLUS, MINUS then 
	{   vlo = expr.Bool(0);
	    if Token == RANGE then
	    {   tok = Next();
		vhi = expr.Bool(0);
		if vlo@.op == CONST && vhi@.op == CONST then
		{   if vlo@.kind
		    is UINT, SINT then 
		    {	t = type.New(vlo@.kind);
			t@.lo = vlo@.valu;
			t@.hi = vhi@.valu;
		    }
		    else
			lex.Error(BADTYPDEF);
		}
		else
		    lex.Error(EXPCONST);
	    }
	    else
		lex.ErrorT(EXPECT, RANGE);
	}
	is ID then 
	{
	    s = Name();
	    if s != 0 then
	    {   t = s@.type;
		if t == 0 then
		{   lex.Error(NOIDTYPE);
		    t = unkntype;
		}
	    }
	    else
		lex.ErrorI(UNDEFID, lex.Ident);
	    tok = Next();
	}
	is AT then    t = Ref();
	is PBEG then  t = Enum(bt);
	is GBEG then  t = Record(bt);
	is ABEG then  t = Array();
	is QUEST then
	{   var tree: Ast;
	    tok = Next();
	    tree = expr.GetLHS();
	    if tree != 0 then t = tree@.type;
	}
	else
	{
	    lex.Error(NOTYPE);
	}
	return t;
    }

    proc NewBuiltin(kind: TypeT, name: @lex.Identifier, size: BitSize): Type
    {   var t: Type;
	var s: Symb;
	var levelsave: symb.levels;

	t = New(kind);
	t@.size = size;
	if kind
	is ENUM, UINT then 
	{   t@.lo = 0;
	    t@.hi = (((1 << (size-1)) - 1) << 1) | 1;
	}
	is SINT then 
	{   t@.hi = (1 << (size-1)) - 1;
	    t@.lo = ~t@.hi;
	}
	Final(t);
	levelsave = symb.level;
	symb.level = 0;
	s = symb.New(TYPE, name, VISIBLE);
	symb.level = levelsave;
	s@.type = t;
	t@.name = s;
	return t;
    }

    const packedstr:[AlignT]@[]Char = {"", "memory", "packed"};
    const bitorderstr:[BitOrderT]@[]Char = {"", "msb", "lsb"};
    const memorderstr:[MemOrderT]@[]Char = {"", "be", "le"};
    const accessstr:[AccessT]@[]Char = {"RW", "RO", "WO"};
    const blanks:[]_byte =
	"                                                                ";

    proc Dump2(t: Type, indent:_uint, full: boolean)
    {   var s: Symb;
	var offs: symb.OffsT;

	if t != 0 then
	{
	    if t@.name != 0 && (!full /* || t@.dumped */) then
		err.str(t@.name@.ident);
	    else
	    {   if t@.kind
		is UINT then 
		{
		    err.uint64(t@.lo); err.str(".."); err.uint64(t@.hi);
		}
		is SINT then 
		{
		    err.int64(_int64(t@.lo)); err.str("..");
		    err.int64(_int64(t@.hi));
		}
		is ENUM then 
		{   err.chr('(');
		    s = t@.list;
		    while s != 0 do
		    {   err.str(s@.ident);
			err.chr('=');
			err.uint32(_uint32(s@.const@.valu));
			s = s@.next;
		      exit s == 0;
			err.str(", ");
		    }
		    err.chr(')');
		}
		is RECORD then 
		{   err.str("{\n");
		    offs = 0;
		    s = t@.list;
		    while s != 0 do
		    {   err.strn(blanks, indent+2);
			err.str(s@.ident);
			err.str(" (");
			err.uint(offs);
			err.str("): ");
			Dump2(s@.type, indent+2, full);
			if t@.packed == BIT then
			    offs += symb.OffsT(s@.type@.size);
			else
			    offs += symb.OffsT(s@.type@.width / Target.membits);
			err.nl();
			s = s@.next;
		    }
		    err.chr('}');
		}
		is ARRAY then 
		{   err.chr('[');
		    if t@.flex then
			err.chr('*');
		    else
			err.uint32(_uint32(t@.hi));
		    err.chr(']');
		    Dump2(t@.base, indent, full);
		}
		is REF then 
		{   err.chr('@');
		    if t@.base != 0 && t@.base@.name != 0 then
			err.str(t@.base@.name@.ident);
		    else
			Dump2(t@.base, indent, full);
		}
		is REFPROC then 
		{   err.str("@_");
		    symb.DumpFormals(t@.list@.parmlist);
		}
		else
		    err.str("*UNKNOWN*");
		err.str(" size=");
		err.uint(t@.size);
		err.chr(':');
		err.uint(t@.width);
		err.chr(':');
		err.uint(t@.align);
		err.str(" attr="); err.str(packedstr[t@.packed]);
		err.chr(':');
		if t@.memorder != Target.order then
		    err.str(memorderstr[t@.memorder]);
		err.chr(':');
		if t@.bitorder != Target.order then
		    err.str(bitorderstr[t@.bitorder]);
		err.chr(':');
		if t@.access != RW then
		    err.str(accessstr[t@.access]);
		err.chr(':');
		if t@.input then err.chr('I');
		if t@.output then err.chr('O');
		t@.dumped = true;
		if t@.meths != 0 then
		{   s = t@.meths;
		    err.str("\n\tmethods:\n\t");
		    loop
		    {   symb.DumpS(s);
			s = s@.next;
		      exit s == 0;
			err.chr('\t');
		    }
		}
	    }
	}
    }

    proc DumpT(t: Type, full: boolean)
    {
	Dump2(t, 0, full);
    }
}
// vim: ts=8 sw=4 noet nowrap

