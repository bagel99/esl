// Copyright (c) 2009-2011, Brian G. Lucas.  See LICENSE file.
// $Id$

package type
{
    type fwd:
	{   next: @fwd;
	    symb: Symb;
	    type: Type;
	};
    type pfwd: @fwd;
    var fwdlist: pfwd;

    proc FwdAdd(s: Symb, t: Type)
    {   var f: pfwd;

	f = pfwd(sys.zalloc(fwd?size));
	f@.symb = s;
	f@.type = t;
	f@.next = fwdlist;
	fwdlist = f;
	s@.forward = true;
    }

    proc FwdFix(s: Symb, bt: Type)
    {   var f, fn, fp: pfwd;

	fp = 0;
	f = fwdlist;
	while f != 0 do
	{   fn = f@.next;
	    if s == f@.symb then
	    {   f@.type@.base = bt;
		if fp != 0 then fp@.next = fn; else fwdlist = fn;
		// free(f)
	    }
	    else
		fp = f;
	    f = fn;
	}
	s@.forward = false;
    }

    // FIXME - move to symb
    proc PPkgPfx(f:sys.fildes, s: Symb)
    {   if s@.package != 0 then PPkgPfx(f, s@.package);    // recursive
	f.str(s@.ident); 
	f.chr('.');
    }
    // FIXME - move to symb
    proc PName(f:sys.fildes, s: Symb)
    {   if s@.package != 0 then PPkgPfx(f, s@.package);
	f.str(s@.ident);
    }

    proc FwdCheck(): boolean
    {   var f: pfwd;

	f = fwdlist;
	while f != 0 do
	{   lex.ErrorSub(FORWNOFIX);
	    PName(err, f@.symb);
	    err.nl();
	    f = f@.next;
	}
    }
	
    proc Def(tok: TokenT, bt: Type): Type;		// forward
    proc ParmList(procs: Symb, meths: Symb);		// forward
    proc Compat(t1: Type, t2: Type): boolean;		// forward

    proc SameTypeList(al: TypeList, bl: TypeList): boolean
    {
	while al != 0 && bl != 0 do
	{   if !Compat(al.type, bl.type) then return false;
	    al = al.next;
	    bl = bl.next;
	}
	return al == 0 && bl == 0;  // must both be at the end of the list
    }

    // FIXME: could use SameTypeList() if SymbNode extends from TypeListEntry
    proc SameSymbList(as: Symb, bs: Symb): boolean
    {
	while as != 0 && bs != 0 do
	{   if !Compat(as.type, bs.type) then return false;
	    as = as.next;
	    bs = bs.next;
	}
	return as == 0 && bs == 0;  // must both be at the end of the list
    }

    const KindName: [TypeT]@[]Char =
    {   "UKNOWN", "ENUM", "UINT", "SINT", "REF", "ARRAY", "RECORD", "REFPROC" };

    proc Compat(t1: Type, t2: Type): boolean
    {
	if t1 == 0 || t2 == 0 then return true;	// what should this be?
	if t1 == t2 then return true;		// the trivial case
	if t1@.kind != t2@.kind then return false;
	if t1@.atbase != 0 then return Compat(t1@.atbase, t2);
	if t2@.atbase != 0 then return Compat(t1, t2@.atbase);
	if t2@.kind
	is UINT, SINT then return true;
	is ENUM then 
	{   var bt1, bt2: Type;
	    // must have same base type
	    bt1 = t1;
	    while bt1@.base != 0 do
		bt1 = bt1@.base;
	    bt2 = t2;
	    while bt2@.base != 0 do
		bt2 = bt2@.base;
	    if bt1 != bt2 then return false;
	    // if t2 is a superset of t1 then they are compatable
	    return t2@.lo <= t1@.lo && t1@.hi <= t2@.hi;
	}
	is RECORD then 
	{   // if t2 is same as, or derived from, t1 then they are compatable
	    if t2@.base != 0 then return Compat(t1, t2@.base);
	    return false;
	}
	is REF then    return Compat(t1@.base, t2@.base);
	is ARRAY then  return Compat(t1@.base, t2@.base);	// FIXME: check index?
	is REFPROC then
	    return SameSymbList(t1@.list@.parmlist, t2@.list@.parmlist) &&
	           SameTypeList(t1@.list@.retvlist, t2@.list@.retvlist);
	return false;
    }

    proc NeedSwap(t: Type, to: MemOrderT): boolean
    {   var fm: MemOrderT;

	if t@.size <= Target.membits then return false;
	fm = t@.memorder;
	if fm == NATIVE then fm = Target.memorder;
	if to == NATIVE then to = Target.memorder;
	return fm != to;
    }


    proc TargetUintType(size: type.BitSize): Type
    {   var i: 0..target.IntSizesMax;

	i = 0;    
	while i < Target.nisize && size > Target.isizes[i].size do
	    i += 1;
	return type.uinttypes[i];
    }

    proc ExactTargetUintType(bits: type.BitSize): Type
    {   var i: 0..target.IntSizesMax;

	i = 0;
	while i < type.NINTS do
	{   if bits == type.uinttypes[i]@.size then
		return type.uinttypes[i];
	    i += 1;
	}
	return 0;
    }

    proc New(kind: TypeT): Type
    {   var t: Type;

	t = Type(sys.zalloc(TypeNode?size));
	t@.kind = kind;
	return t;
    }

    proc MakeRef(bt: Type): Type
    {   var t: Type;

	t = bt@.reftype;
	if t == 0 then
	{   t = New(REF);
	    t@.base = bt;
	    t@.memorder = Target.memorder;
	    t@.size  = Target.ptr.size;
	    t@.width = Target.ptr.size;
	    t@.align = Target.ptr.align;
	    t@.reftype = t;
	}
	return t;
    }

    proc Clone(ot: Type): Type
    {   var nt: Type;

	nt = New(ot@.kind);
	nt@ = ot@;	// record copy
	nt@.name = 0;
	nt@.final = false;
    }
	
    proc ChangeOrder(told: Type, neworder: MemOrderT): Type
    {   var t: Type;

	t = Clone(told);
	t@.memorder = neworder;
	t@.final = true;
	return t;
    }

    proc ForceUnAligned(told: Type, align: BitSize): Type
    {   var t: Type;

	t = Clone(told);
	t@.atbase = told;
	t@.align = align;
	t@.unalgn = true;
	t@.final = true;
	return t;
    }

    const askip1:[4]TokenT = { PEND, SEMI, NONE };
    const askip2:[5]TokenT = { COMMA, PEND, SEMI, NONE };

    proc XLinkage(s: Symb)
    {   var tok: TokenT;

	tok = Token;
	if tok == PBEG then
	{   tok = Next();
	    if tok == STR then
	    {   s@.altsymb = symb.New(ALIAS, lex.StringBuf, PRIVATE);
		tok = Next();
	    }
	    else
	    {   s@.xaddr = expr.ConstValue(type.wordtype);
		s@.linkage = FIXED;
	    }
	    lex.Expect(PEND);
	}
    }
    
    proc XSection(s: Symb)
    {   var tok: TokenT;

	tok = Token;
	if tok == PBEG then
	{   tok = Next();
	    if tok == STR then
	    {   s@.section = symb.New(ALIAS, lex.StringBuf, PRIVATE);
	    	tok = Next();
	    	lex.Expect(PEND);
	    	return;
	    }
	}
	lex.Error(SECTNAME);
    }
    
    const tattrlist:[]TokenT =
    {	KPACK, KNOPAD,
	KLSB, KMSB,
	KLE, KBE,
	KRO, KWO,
	KINPUT, KOUTPUT,
	KMEMSZ, KBITSZ, KALIGN,
	NONE
    };
    proc Attributes(s: Symb, t: Type,  sattrlist:@[]TokenT): Type
    {   var tok, atok: TokenT;
	var at: Type;

	// assert Token == COLON
	loop
	{   tok = Next();
	    if tok == ID then
	    {   atok = lex.Keyword(tattrlist);
		if atok != tok then
		{   // Handle type attribute
		    tok = Next();
		    if t@.final then
		    {   at = t;
			t = Clone(at);	// Will not be the same type
			t@.atbase = at;
		    }
		    if atok
		    is KPACK then   t@.packed = true;
		    is KNOPAD then  t@.noepad = true;
		    is KLSB then    t@.bitorder = LSB;
		    is KMSB then    t@.bitorder = MSB;
		    is KLE then     t@.memorder = LE;
		    is KBE then     t@.memorder = BE;
		    is KRO then     t@.access = RO;
		    is KWO then     t@.access = WO;
		    is KINPUT then  t@.input = true;
		    is KOUTPUT then t@.output = true;
		    is KMEMSZ then 
		    {   if tok == PBEG then
			{   tok = Next();
			    t@.width = BitSize(expr.ConstValue(type.wordtype) *
					Target.membits);
			    t@.widthattr = true;
			    lex.Expect(PEND);
			}
		    }		
		    is KBITSZ then 
		    {   if tok == PBEG then
			{   tok = Next();
			    t@.size = BitSize(expr.ConstValue(type.wordtype));
			    t@.sizeattr = true;
			    lex.Expect(PEND);
			}
		    }		
		    is KALIGN then 
		    {   if tok == PBEG then
			{   tok = Next();
			    t@.align = BitSize(expr.ConstValue(type.wordtype) *
					Target.membits);
			    if t@.align == 0 then
				t@.align = Target.membits; // minimum align
			    t@.alignattr = true;
			    lex.Expect(PEND);
			}
		    }		
		}
		else
		{   // Not a type attribute
		    if s != 0 then
		    {   // Perhaps a symbol attribute
			atok = lex.Keyword(sattrlist);
			if atok != tok then
			{   // Handle symbol attribute
			    tok = Next();
			    if atok
			    is KINLINE then  s@.linkage = INLINE;
			    is KNOINLINE then s@.linkage = NOINLINE;
			    is KGLOBAL then 
			    {   s@.linkage = GLOBAL;
				XLinkage(s);
			    }
			    is KEXTERN then 
			    {   s@.linkage = EXTERN;
				XLinkage(s);
			    }
			    is KSECTION then
			    {   XSection(s);
			    }
			}
			else
			    lex.ErrorI(BADATTR, lex.Ident);
		    }
		    else
		    {   lex.ErrorI(BADATTR, lex.Ident);
			tok = Next();
		    }
		}
	    }
	    else if tok != SEMI then
	    {   lex.Error(EXPECTID);
		tok = lex.Skip(askip2);
	    }
	    tok = Token;
	  exit tok != COMMA;
	}
	return t;
    }

    const nattrlist:[]TokenT = { NONE };

    proc TypeAttributes(t: Type): Type
    {
	return Attributes(0, t, nattrlist);
    }

    const vattrlist:[4]TokenT = { KEXTERN, KGLOBAL, KSECTION, NONE };
    proc VarAttributes(s: Symb, t: Type): Type
    {
	return Attributes(s, t, vattrlist);
    }

    const pattrlist:[6]TokenT = { KEXTERN, KGLOBAL, KSECTION, KINLINE, KNOINLINE, NONE };
    proc ProcAttributes(s: Symb)
    {   var t: Type;

	t = Attributes(s, s@.type, pattrlist);
	s@.type = t;
    }

    // replace with something clever
    proc bitsize(x: _uint64): 0..255
    {   var t: _uint64;
	var n: 0..255;

	n = 1;
	t = 1;
	while t < x do
	{   t = t<<1;
	    t += 1;
	    n += 1;
	}
	return n;
    }

    proc FieldPad(prev: Symb, pad: BitSize, index: symb.OffsT): symb.OffsT
    {   var last, s: Symb;

	last = prev@.next;
	while pad > 0 do
	{   s = symb.New(FIELD, "_", PRIVATE);
	    s@.type = bytetype;
	    s@.addr = index;
	    s@.ispad = true;
	    prev@.next = s;
	    prev = s;
	    index += 1;    
	    pad -= 1;
	}
	prev@.next = last;
	return index;	
    }

    proc ForcePacked(t: Type): Type
    {
	if (t@.kind == RECORD || t@.kind == ARRAY) && !t@.packed then
	{   t = Clone(t);
	    t@.packed = true;
	    Final(t);
	}
	return t;
    }

    proc DumpType(msg: @[]_byte, t: Type)
    {
        const tname: [TypeT]@[]_byte =
	{   "UTYPE", "ENUM", "UINT", "SINT", "FLOAT", "REF", "ARRAY", "RECORD",
	    "REFPROC"
	};
	err.str(msg);
	err.str(tname[t@.kind]);
	err.nl();
	type.DumpT(t, true);
	err.nl();
    }

    proc Final(t: Type)
    {   var align: BitSize;
	var tlo, thi: BitSize;
	var f, prev: Symb;
	var index: symb.OffsT;
	var offs, mod: BitSize;

	if t != 0 && !t@.final then
	{
	    if t@.bitorder == NATIVE then
		t@.bitorder = Target.bitorder;
	    if t@.memorder == NATIVE then
		t@.memorder = Target.memorder;
	    /*
	     * This code checks to see if size/width/align has been
	     * set by explicit attributes and adjusts things accordingly.
	     */
//DumpType("Final beg: ", t);
	    if t@.sizeattr then
	    {   if !t@.widthattr then
		    t@.width = target.isize(t@.size);
	    }
	    if t@.widthattr then
	    {   if !t@.sizeattr then
		    t@.size = t@.width;
	    }
	    if t@.kind
	    is UTYPE then
		align = t@.align;   // code below depends on this
	    is ENUM, UINT then 
	    {   if t@.size == 0 then
		    t@.size = bitsize(t@.hi);
		if t@.width == 0 then
		    t@.width = target.isize(t@.size);
		align = target.ialign(t@.size);
	    }
	    is SINT then 
	    {   if t@.size == 0 then
		{   tlo = bitsize(~t@.lo);
		    thi = bitsize(t@.hi);
		    if tlo > thi then
			t@.size = tlo+1;
		    else
			t@.size = thi+1;
		}
		if t@.width == 0 then
		    t@.width = target.isize(t@.size);
		align = target.ialign(t@.size);
	    }
	    is FLOAT then
	        t@.width = t@.size;
	    is REF then 
	    {   // Make sure anonymous base types are final
		if t@.base != 0 && t@.base@.name == 0 then
		    Final(t@.base);
		t@.size  = Target.ptr.size;
		t@.width = Target.ptr.size;
		align = Target.ptr.align;
	    }
	    is REFPROC then 
	    {   t@.size  = Target.ptr.size;
		t@.width = Target.ptr.size;
		align = Target.ptr.align;
	    }
	    is RECORD then 
	    {   index = 0;
		offs = 0;
		align = 0;
		prev = 0;
		f = t@.list;
		while f != 0 do
		{   if f@.type != 0 then
		    {   Final(f@.type);
			if f@.type@.flex then
			{   if f@.next != 0 then    // flex must be final field
				lex.Error(BADFLEX);
			    else
				t@.flex = true;     // mark record as flex
			}
			if t@.packed then
			{   f@.type = ForcePacked(f@.type);
			    offs += f@.type@.size;
			}
			else
			{   var falign: BitSize;
			    falign = f@.type@.align;
			    if t@.alignattr && t@.align < falign then
				f@.type = ForceUnAligned(f@.type, t@.align);
			    if f@.type@.unalgn then
				t@.nofpad = true;
			    else
			    {
//err.str("offs="); err.uint(offs); err.str(" falign="); err.uint(falign); err.nl();
				mod = offs % falign;
				if mod != 0 then
				{   // field needs padding
				    index = FieldPad(prev,
						(falign-mod)/Target.membits,
						index);
				    offs += falign - mod;
				}
			    }
			    offs += f@.type@.width;
			    if falign > align then
				align = falign;
			}
		    }
		    f@.addr = index;
		    index += 1;
		    prev = f;
		    f = f@.next;
		}
		if t@.size == 0 then    // no explicit attribute
		    t@.size = offs;
		if t@.width == 0 then
		{   if offs <= Target.regsize  && !t@.noepad then
			t@.width = target.isize(offs);
		    else
			t@.width = offs;
		}
		if align > 0 then
		{   mod = t@.width % align;
		    if mod != 0  && !t@.noepad then
			t@.width += align - mod;	// pad to alignment
		}
		else
		{   if t@.noepad then
		    {   if t@.packed then
			    align = 1;
			else
			    align = Target.membits;
		    }
		    else
			align = target.ialign(t@.size);
		}
	    }
	    is ARRAY then 
	    {   if t@.base != 0 then
		{   Final(t@.base);
		    if t@.packed then
			t@.base = ForcePacked(t@.base);
		    if t@.size == 0 then
			t@.size = BitSize(t@.base@.size * t.Span());
		    if t@.width == 0 then
			t@.width = t@.size;
		    if t@.base.width < t@.base.align then
{
			lex.ErrorS(NOTIMPL, "Array of aligned items");
type.DumpT(t@.base, true);
err.nl();
}
		    if !t@.packed then
			align = t@.base@.align;
		    else
			align = target.ialign(t@.size);
		}
	    }
	    if t@.alignattr then
	    {   if t@.align < align then
		    t@.unalgn = true;
	    }
	    else
		t@.align = align;
	    t@.final = true;
//DumpType("Final end: ", t);
	}
    }

    proc Enum(bt: Type): Type
    {   var tok: TokenT;
	var t: Type;
	var vn, pvn: Symb;
	var v, vmax: _uint32;

	tok = Next();
	t = New(ENUM);
	v = 0;
	vmax = 0;
	pvn = 0;
	t@.base = bt;
	if bt != 0 then
	{   var vb: Symb;
	    if bt@.kind == ENUM then
	    {	// for each field in base type, copy to new type
		vb = bt@.list;
		while vb != 0 do
		{   vn = symb.New(CONSTANT, vb@.ident, PRIVATE);
		    if pvn != 0 then pvn@.next = vn;
				else t@.list = vn;
		    pvn = vn;
		    vn@.const = vb@.const;
		    v = _uint32(vb@.const@.valu);
		    if v > vmax then vmax = v;
		    vb = vb@.next;
		}
		v += 1;		// start with next value
	    }
	    else lex.Error(BASEENUM);
	}
	loop
	{   if tok == ID then
	    {   if !symb.IsUniqueLocal(t@.list, lex.Ident) then
		    lex.ErrorI(DEFID, lex.Ident);
		vn = symb.New(CONSTANT, lex.Ident, PRIVATE);
		if pvn != 0 then pvn@.next = vn;
			    else t@.list = vn;
		pvn = vn;
		tok = Next();
		if tok == ASGN then
		{   tok = Next();
		    vn@.const = expr.Const(type.wordtype);
		    vn@.const@.type = t;
		    tok = Token;
		    v = _uint32(vn@.const@.valu);
		}
		else
		    vn@.const = ast.Const(t, v);
	    }
	    else
		lex.Error(EXPECTID);
	    if v > vmax then vmax = v;
	  exit tok == PEND;
	    tok = lex.Expect(COMMA);
	  exit tok == PEND;
	    v += 1;
	}
	lex.Expect(PEND);
	t@.lo = 0;
	t@.hi = vmax;
	return t;
    }

    proc RangeEnum(t: Type, bt: Type)
    {   var vb, vn, pvn: Symb;
	var v, vlo, vhi: _uint32;

	t@.base = bt;
	vb = bt@.list;
	pvn = 0;
	vlo = t@.lo;
	// skip over any too low
	while vb != 0 && vlo > _uint32(vb@.const@.valu) do
	    vb = vb@.next;
	vhi = t@.hi;
	// copy over those in range
	while vb != 0 && vhi >= _uint32(vb@.const@.valu) do
	{   vn = symb.New(CONSTANT, vb@.ident, PRIVATE);
	    vn@.const = ast.Const(t, vb@.const@.valu);
	    if pvn != 0 then pvn@.next = vn;
			else t@.list = vn;
	    pvn = vn;
	    vb = vb@.next;
	}
    }

    proc Range(vlo: Ast): Type
    {   var t: Type;
	var tok: TokenT;
	var vhi: Ast;

	t = unkntype;		// in case all goes wrong
	if Token == RANGE then
	{   tok = Next();
	    vhi = expr.Bool(0);
	    if vlo != 0 && vhi != 0 then
	    {   if vlo@.op == CONST && vhi@.op == CONST then
		{   if vlo@.type@.kind
		    is ENUM, UINT, SINT then 
		    {   t = type.New(vlo@.type@.kind);
			t@.lo = vlo@.valu;
			t@.hi = vhi@.valu;
			if vlo@.type@.kind == ENUM then
			    RangeEnum(t, vlo@.type);
		    }
		    else
			lex.Error(BADTYPDEF);
		}
		else
		    lex.Error(EXPCONST);
	    }
	}
	else
	    lex.ErrorT(EXPECT, RANGE);
	return t;
    }

    proc Record(bt: Type): Type
    {   var tok: TokenT;
	var t, ft: Type;
	var s, ps, bs: Symb;

	tok = Next();
	t = type.New(RECORD);
	ps = 0;
	t@.base = bt;
	if bt != 0 then
	{   if bt@.kind == RECORD then
	    {	// copy the record type
		bs = bt@.list;
		while bs != 0 do
		{   s = symb.New(FIELD, bs@.ident, PRIVATE);
		    if ps != 0 then ps@.next = s; else t@.list = s;
		    ps = s;
		    s@.type = bs@.type;
		    bs = bs@.next;
		}
	    }
	    else
	    {   bt = 0;
		lex.Error(BASERECORD);
	    }
	}
	while tok == ID do
	{   // look ahead before dealing with ident
	    tok = Next();
	    if tok
	    is COLON then 
	    {   if !symb.IsUniqueLocal(t@.list, lex.Ident) then
		    lex.ErrorI(DEFID, lex.Ident);
		s = symb.New(FIELD, lex.Ident, PRIVATE);
		if ps != 0 then ps@.next = s; else t@.list = s;
		ps = s;
		tok = Next();
		ft = Def(tok, 0);
		s@.type = ft;
		tok = Token;
		if tok == COLON then
		{   s@.type = TypeAttributes(ft);
		    tok = Token;
		}
		if tok == ASGN then
		{   tok = Next();
		    lex.ErrorS(NOTIMPL, "field inital values");
		}

	    }
	    else
		lex.Error(BADRECORD);
	    tok = lex.Expect(SEMI);
	}
	tok = lex.Expect(GEND);
	return t;
    }

    proc Array(): Type
    {   var tok: TokenT;
	var t, bt: Type;
	var tree: Ast;

	tok = Next();
	t = type.New(ARRAY);
	if tok != AEND then
	{   tree = expr.Bool(0);
	    if tree != 0 then
	    {   if tree@.op
		is CONST then
		{   if Token == RANGE then
		    {   t@.index = Range(tree);
			t@.lo = t@.index@.lo;
			t@.hi = t@.index@.hi;
		    }
		    else
		    {   t@.lo = 0;
			t@.hi = tree@.valu - 1;
			t@.index = type.wordtype;
		    }
		}
		is TYPE then
		{   if tree@.type@.kind
		    is ENUM, UINT then
		    {   t@.lo = tree@.type@.lo;
		        t@.hi = tree@.type@.hi;
			t@.index = tree@.type;
		    }
		    else lex.Error(BADINDEX);
		}
		else lex.Error(BADINDEX);
	    }
	}
	else
	    t@.flex = true;
	tok = lex.Expect(AEND);
	bt = Def(tok, 0);
	t@.base  = bt;
	return t;
    }

    proc DefProc(procs: Symb, meths: Symb)
    {   var s, prevs: Symb;
	var t: Type;
	var tl, tlprev: TypeList;
	var tok: TokenT;

	tok = Token;
	if tok == PBEG then
	{   tok = Next();
	    if meths != 0 then
		procs@.parmlist = meths;
	    if tok != PEND then
	    {   prevs = meths;	// 0 if not a method
		loop
		{   if tok == ID then
		    {   if !symb.IsUniqueLocal(procs@.parmlist, lex.Ident) then
			    lex.ErrorI(DEFID, lex.Ident);
			s = symb.New(VAR, lex.Ident, PRIVATE);
			tok = Next();
			s@.linkage = FORMAL;
			t = unkntype;
			if tok == COLON then
			{   tok = Next();
			    t = type.Def(tok, 0);
			    type.Final(t);
			    tok = Token;
			}
			else lex.ErrorT(EXPECT, COLON);
if debug.tests[2] then {
			if t@.kind
			is ARRAY, RECORD then
			{   if !t@.packed then
				lex.ErrorS(NOTIMPL, "Aggregate parameter by value not allowed");
			}
}
			s@.type = t;
			if procs@.parmlist == 0 then
			    procs@.parmlist = s;
			if prevs != 0 then
			    prevs@.next = s;
			prevs = s;
		    }
		    else lex.Error(EXPECTID);
		  exit tok != COMMA;
		    tok = Next();
		}
	    }
	    tok = lex.Expect(PEND);
	}
	else lex.ErrorT(EXPECT, PBEG);
	if tok == COLON then	// parse returned value type
	{   tok = Next();
	    if tok != COLON then    // not an empty return type
	    {   tlprev = 0;
		loop
		{   t = type.Def(tok, 0);
		    type.Final(t);
		    tl = TypeList(sys.zalloc(TypeListEntry?size));
		    tl@.type = t;
		    if tlprev == 0 then
			procs@.retvlist = tl;
		    else
			tlprev@.next = tl;
		    tlprev = tl; 
		    tok = Token;
		  exit tok != COMMA;
		    tok = Next();
		}
		procs@.type = procs@.retvlist@.type;	// first ret type
	    }
	}
    }

    proc Name(): Symb
    {   var s: Symb;

	s = symb.Find(lex.Ident);
	if s != 0 && s@.kind != TYPE then
	    lex.Error(NOTTYPE);
	return s;
    }

    proc Ref(): Type
    {   var tok: TokenT;
	var t: Type;
	var bs: Symb;

	t = unkntype;		// in case all goes wrong
	tok = Next();
	if tok == ID then
	{
	    if symb.IsAnon(lex.Ident) then
	    {
		t = New(REFPROC);
		bs = symb.New(PROC, lex.Ident, PRIVATE);
		tok = Next();
		DefProc(bs, 0);
		t@.list = bs;
	    }
	    else
	    {   t = New(REF);
		bs = Name();
		if bs != 0 then
		{   if bs@.type != 0 then
			t@.base = bs@.type;
		    else	// already forward, add another reference
			FwdAdd(bs, t);
		}
		else	// undefined, make forward and make reference
		{   bs = symb.New(TYPE, lex.Ident, VISIBLE);
		    FwdAdd(bs, t);
		}
		tok = Next();
	    }
	}
	else
	{   t = New(REF);
	    t@.base = Def(tok, 0);
	}
	return t;
    }

    proc Def(tok: TokenT, bt: Type): Type
    {   var t: Type;
	var s: Symb;
	var vlo: Ast;

	t = unkntype;		// in case all goes wrong
	if tok
	is NUM, PLUS, MINUS then 
	{   vlo = expr.Bool(0);
	    t = Range(vlo);
	}
	is ID then 
	{   s = symb.Find(lex.Ident);
	    if s != 0 then
	    {   if s@.kind 
		is TYPE then
		{   tok = Next();
		    if tok == DOT then  // enum const, start of range
		    {   tok = Next();
			vlo = expr.EnumConst(s@.type);
			tok = Next();
			t = Range(expr.EnumConst(s@.type));
		    }
		    else    // just type name
		    {   t = s@.type;
		        if t == 0 then
			{   lex.Error(NOIDTYPE);
			    t = unkntype;
			}
		    }
		}
		is CONSTANT then	// named const, start of range
		{   vlo = expr.Bool(0);
		    t = Range(vlo);
		}
		else 
		{   tok = Next();
		    lex.Error(NOTTYPE);
		}
	    }
	    else
		lex.ErrorI(UNDEFID, lex.Ident);
	}
	is AT then    t = Ref();
	is PBEG then  t = Enum(bt);
	is GBEG then  t = Record(bt);
	is ABEG then  t = Array();
	is QUEST then
	{   var tree: Ast;
	    tok = Next();
	    tree = expr.GetLHS();
	    if tree != 0 then
	    {   // assert tree@.kind == REF
		t = tree@.type@.base;
	    }
	}
	else
	{
	    lex.Error(NOTYPE);
	}
	return t;
    }

    proc NewBuiltin(kind: TypeT, name: @lex.Identifier, size: BitSize): Type
    {   var t: Type;
	var s: Symb;
	var levelsave: symb.levels;

	t = New(kind);
	t@.size = size;
	if kind
	is ENUM, UINT then 
	{   t@.lo = 0;
	    t@.hi = (((1 << (size-1)) - 1) << 1) | 1;
	}
	is SINT then 
	{   t@.hi = (1 << (size-1)) - 1;
	    t@.lo = ~t@.hi;
	}
	Final(t);
	levelsave = symb.level;
	symb.level = 0;
	s = symb.New(TYPE, name, VISIBLE);
	symb.level = levelsave;
	s@.type = t;
	t@.name = s;
	return t;
    }

    const bitorderstr:[BitOrderT]@[]Char = {"", "msb", "lsb"};
    const memorderstr:[MemOrderT]@[]Char = {"", "be", "le"};
    const accessstr:[AccessT]@[]Char = {"RW", "RO", "WO"};
    const blanks:[]_byte =
	"                                                                ";

    proc Dump2(t: Type, indent:_uint, full: boolean)
    {   var s: Symb;
	var offs: symb.OffsT;

	if t != 0 then
	{
	    if t@.name != 0 && (!full /* || t@.dumped */) then
		err.str(t@.name@.ident);
	    else
	    {   if t@.kind
		is UINT then 
		{
		    err.uint64(t@.lo); err.str(".."); err.uint64(t@.hi);
		}
		is SINT then 
		{
		    err.int64(_int64(t@.lo)); err.str("..");
		    err.int64(_int64(t@.hi));
		}
		is ENUM then 
		{   err.chr('(');
		    s = t@.list;
		    while s != 0 do
		    {   err.str(s@.ident);
			err.chr('=');
			err.uint32(_uint32(s@.const@.valu));
			s = s@.next;
		      exit s == 0;
			err.str(", ");
		    }
		    err.chr(')');
		}
		is FLOAT then
		    err.str("<float>");
		is RECORD then 
		{   err.str("{\n");
		    offs = 0;
		    s = t@.list;
		    while s != 0 do
		    {   err.strn(blanks, indent+2);
			err.str(s@.ident);
			err.str(" (");
			err.uint(offs);
			err.str("): ");
			Dump2(s@.type, indent+2, full);
			if t@.packed then
			    offs += symb.OffsT(s@.type@.size);
			else
			    offs += symb.OffsT(s@.type@.width / Target.membits);
			err.nl();
			s = s@.next;
		    }
		    err.chr('}');
		}
		is ARRAY then 
		{   err.chr('[');
		    if t@.flex then
			err.chr('*');
		    else
		    {	err.uint32(_uint32(t@.lo));
		        err.str("..");
			err.uint32(_uint32(t@.hi));
		    }
		    err.chr(']');
		    Dump2(t@.base, indent, full);
		}
		is REF then 
		{   err.chr('@');
		    if t@.base != 0 && t@.base@.name != 0 then
			err.str(t@.base@.name@.ident);
		    else
			Dump2(t@.base, indent, full);
		}
		is REFPROC then 
		{   err.str("@_");
		    symb.DumpFormals(t@.list@.parmlist);
		}
		else
		    err.str("*UNKNOWN*");
		err.str(" size=");
		err.uint(t@.size);
		err.chr(':');
		err.uint(t@.width);
		err.chr(':');
		err.uint(t@.align);
		err.str(" attr=");
		if t@.unalgn then err.str("unalgn ");
		if t@.packed then err.str("packed ");
		if t@.noepad then err.str("noepad ");
		if t@.nofpad then err.str("nofpad ");
		err.chr(':');
		if t@.memorder != Target.memorder then
		    err.str(memorderstr[t@.memorder]);
		err.chr(':');
		if t@.bitorder != Target.bitorder then
		    err.str(bitorderstr[t@.bitorder]);
		err.chr(':');
		if t@.access != RW then
		    err.str(accessstr[t@.access]);
		err.chr(':');
		if t@.input then err.chr('I');
		if t@.output then err.chr('O');
		t@.dumped = true;
		if t@.meths != 0 then
		{   s = t@.meths;
		    err.str("\n\tmethods:\n\t");
		    loop
		    {   symb.DumpS(s);
			s = s@.next;
		      exit s == 0;
			err.chr('\t');
		    }
		}
	    }
	}
	else
	    err.str("???");
    }

    proc DumpT(t: Type, full: boolean)
    {
	Dump2(t, 0, full);
    }
}
// vim: ts=8 sw=4 noet nowrap

