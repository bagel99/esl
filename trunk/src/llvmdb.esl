/*
 * Output the debug information as LLVM metadata.
 * The LLVM documentation is incomplete, out-of-date, or just wrong.
 * Use clang's calls to DIBuilder routines (llvm/lib/Analysis/DIBuilder.cpp)
 * in clang/lib/CodeGen/CGDebuginfo.cpp as a reference.
 *
 * Copyright (c) 2010-2012, Brian G. Lucas.  See LICENSE file.
 * $Id: llvmdb.esl 766 2013-04-16 21:00:41Z bgl $
 */

package llvmdb
{
    alias llvm.f as f;
    type DW_TAG:
    (
	Array=1,
	Class=2,
	EntryPoint=3,
	Enumeration=4,
	FormalParameter=5,
	Label=10,
	Block=11,
	Member=13,
	Pointer=15,
	Reference=16,
	CompileUnit=17,
	String=18,
	Structure=19,
	SubroutineType=21,
	Typedef=22,
	Union=23,
	Inheritance=28,
	Inlined=29,
	Subrange=33,
	BasicType=36,
	Const=38,
	Enumerator=40,
	File=41,
	Subprogram=46,
	GlobalVariable=52,
	Volatile=53,
	Restrict=55,
	Namespace=57,
	AutoVariable=256,
	ArgVariable=257,
	ReturnVariable=258,
	Vector=259
    );
    type DW_ATE:
    (	Address=1, Boolean=2, ComplexFloat=3, Float=4, 
	Signed=5, SignedChar=6, Unsigned=7, UnsignedChar=8
    );
    const DWLanguage:_uint32 = 12;	// FIXME: using C99 for now
    const LLVMDebugVersion:_uint32 = 0xC_0000;
    type DIFlags:	// from llvm/include/llvm/Analysis/DebugInfo.h
    ( Private		= 1 << 0,
      Protected		= 1 << 1,
      FwdDecl		= 1 << 2,
      AppleBlock	= 1 << 3,
      BlockByrefStruct	= 1 << 4,
      Virtual		= 1 << 5,
      Artificial	= 1 << 6,
      Explicit		= 1 << 7,
      Prototyped	= 1 << 8,
      ObjcClassComplete	= 1 << 9
    );
    const meta:_byte = '!';		// metadata introducer
    type TermT: (COMMA, BRACE, PAREN, NONE);
    type seqnoT: _uint16;
    type LineT:
    {   next:   @LineT;
	tag:    seqnoT;
	lineno: _uint16;
	context:seqnoT;
    };
    type Line: @LineT;
    var seqno: seqnoT;
    var unit, file, subr, blok: seqnoT;
    var globals, subprogs, retained, enums: seqnoT;
    var gvhead, gvtail: Symb;	// linked list of global variables
    var lvhead, lvtail: Symb;	// linked list of local variables
    var sphead, sptail: Symb;	// linked list of subprograms
    var lnhead, lntail: Line;	// linked list of line number descriptors
    var lexblkno: _uint;	// unique id for lexical block

    proc GetLineContext(): seqnoT
    {
	if blok != 0 then return blok;
	return file;
    }

    proc PSeq(n: seqnoT)
    {
	f.chr(meta);
	f.uint(n);
    }
    proc PMetaSeq(n: seqnoT)
    {
	PSeq(n);
	f.str(" = metadata !{");
    }

    proc PTerminator(term: TermT)
    {
	if term
	is BRACE then f.str("}\n");
	is COMMA then f.str(", ");
	is PAREN then f.str(" )");
    }

    proc PNull(term: TermT)
    {
	f.str("null");
	PTerminator(term);
    }

    proc PMetaRef(n: seqnoT, term: TermT)
    {
	f.str("metadata !");
	f.uint(n);
	PTerminator(term);
    }

    proc PBoolean(b: boolean, term: TermT)
    {
	f.str("i1 ");
	if b then f.str("true"); else f.str("false");
	PTerminator(term);
    }

    proc P32(v: _uint32, term: TermT)
    {
	f.str("i32 ");
	f.uint32(v);
	PTerminator(term);
    }

    proc P64(v: _uint64, term: TermT)
    {
	f.str("i64 ");
	f.uint64(v);
	PTerminator(term);
    }

    proc PHeader(tag: seqnoT, dwat: DW_TAG)
    {
	PMetaSeq(tag);
	P32(_uint32(dwat) + LLVMDebugVersion, COMMA);
    }

    proc PString(s: @[]_byte, term: TermT)
    {
	f.str("metadata !\"");
	if s != 0 then f.str(s);
	f.chr('"');
	PTerminator(term);
    }

    proc PString2(s1: @[]_byte, s2: @[]_byte, delim: _byte, term: TermT)
    {
	f.str("metadata !\"");
	if s1 != 0 then
	{   f.str(s1);
	    f.chr(delim);
	}
	if s2 != 0 then f.str(s2);
	f.chr('"');
	PTerminator(term);
    }

    proc PName(s: Symb, term: TermT)
    {
	if s != 0 && !symb.IsAnon(s@.ident) then
	    PString(s@.ident, term);
	else
	    PString(0, term);
    }

    proc PFullName(s: Symb, term: TermT)
    {
	if s != 0 && !symb.IsAnon(s@.ident) then
	{   if s@.package != 0 then
		PString2(s@.package@.ident, s@.ident, '.', term);
	    else
		PString(s@.ident, term);
	}
	else
	    PString(0, term);
    }

    proc PLinkName(s: Symb, term: TermT)
    {
	if s != 0 && !symb.IsAnon(s@.ident) then
	{   if s@.package != 0 then
		PString2(s@.package@.ident, s@.ident, llvm.package_delimiter, term);
	    else
		PString(s@.ident, term);
	}
	else
	    PString(0, term);
    }

    proc PContext(term: TermT)
    {   var tag: seqnoT;

	tag = file;
	PMetaRef(tag, term);
    }

    proc PListStart(): seqnoT
    {   var tag: seqnoT;

	seqno += 1;  tag = seqno;
	PMetaSeq(tag);
	return tag;
    }
    
    proc PEmptyList(): seqnoT
    {   var tag: seqnoT;

	tag = PListStart();
	P32(0, BRACE);
	return tag;
    }
	    
    proc DefType(t: Type): seqnoT;		// forward

    proc DefFormals(ps: Symb): _uint
    {   var fs: Symb;
	var n: _uint;

	n = 0;
	fs = ps@.parmlist;
	while fs != 0 do
	{   n += 1;
	    DefType(fs@.type);
	    fs = fs@.next;
	}
	return n;
    }
	
    proc DefRetvs(ps: Symb): seqnoT
    {   var retvs, tag: seqnoT;
	var tl: type.TypeList;
	var term: TermT;

	tl = ps@.retvlist;
	if tl == 0 then return 0;		// no returned values (void)
	while tl != 0 do
	{   DefType(tl@.type);
	    tl = tl@.next;
	}
	tl = ps@.retvlist;
	if tl@.next == 0 then			// 1 returned value
	    retvs = tl@.type.dbtag;
	else					// >1 returned values
	{   seqno += 1;
	    retvs = seqno;
	    PMetaSeq(retvs);
	    term = COMMA;
	    while tl != 0 do
	    {   tag = tl@.type.dbtag;
		tl = tl@.next;
		if tl == 0 then term = BRACE;
		PMetaRef(tag, term);
	    }
	}
	return retvs;
    }
	
    proc DefBasicType(dwtype: DW_ATE, t: type.Type): seqnoT
    {   var tagt: seqnoT;

	seqno += 1;  tagt = seqno;
	PHeader(tagt, DW_TAG.BasicType);	// tag
	PNull(COMMA);				// context
	PName(t@.name, COMMA);			// name
	PNull(COMMA);				// file
	P32(0, COMMA);				// line
	P64(_uint64(t@.width), COMMA);		// size
	P64(_uint64(t@.align), COMMA);		// align
	P64(0, COMMA);				// offset
	P32(0, COMMA);				// flags
	P32(_uint32(dwtype), BRACE);		// encoding
	return tagt;
    }

    proc PTypeHeader(tag: seqnoT, dwat: DW_TAG, t:Type)
    {
	PHeader(tag, dwat);			// tag
	PMetaRef(file, COMMA);			// context
	PName(t@.name, COMMA);			// name
	PMetaRef(file, COMMA);			// file
	if t@.name != 0 then
	    P32(t@.name@.lineno, COMMA);	// line
	else
	    P32(0, COMMA);			// line
	P64(_uint64(t@.width), COMMA);		// size
	P64(_uint64(t@.align), COMMA);		// align
	P64(0, COMMA);				// offset
	P32(0, COMMA);				// flags
    }
    
    proc DefSubroutine(stag: seqnoT, ps: Symb);	// forward

    proc DefRefType(t: Type): seqnoT
    {   var tagb, tagr: seqnoT;

	if t@.kind == REFPROC then
	{   seqno += 1;  tagb = seqno;
	    DefSubroutine(tagb, t@.list);
	}
	else
	    tagb = DefType(t@.base);
	seqno += 1;  tagr = seqno;
	PTypeHeader(tagr, DW_TAG.Pointer, t);
	PMetaRef(tagb, BRACE);			// derived from
	return tagr;
    }

    proc DefRange(lo: _uint64, hi: _uint64): seqnoT
    {   var tagr: seqnoT;

	seqno += 1;  tagr = seqno;
	// emit Subrange
	PHeader(tagr, DW_TAG.Subrange);	// tag
	P64(lo, COMMA);				// lo value
	P64(hi, BRACE);				// hi value
	return tagr;
    }

    proc DefEnumConst(s: Symb): seqnoT
    {   var tagc: seqnoT;

	seqno += 1;  tagc = seqno;
	PHeader(tagc, DW_TAG.Enumerator);	// tag
	PName(s, COMMA);			// name
	P64(s@.const@.valu, BRACE);		// value
	return tagc;
    }

    proc DefEnumerationType(t: Type): seqnoT
    {   var tag, list, tage: seqnoT;
	var s: Symb;
	var term: TermT;

	// first output all the constants
	s = t@.list;
	while s != 0 do
	{   if s@.dbtag == 0 then
		s@.dbtag = DefEnumConst(s);
	    s = s@.next;
	}
	// then the list
	list = PListStart();
	term = COMMA;  
	s = t@.list;
	while s != 0 do
	{   tag = s@.dbtag;
	    s = s@.next;
	    if s == 0 then term = BRACE;
	    PMetaRef(tag, term);
	}
	seqno += 1;  tage = seqno;
	// emit Enumeration
	PTypeHeader(tage, DW_TAG.Enumeration, t);
	PNull(COMMA);				// derived from
	PMetaRef(list, COMMA);			// enum list
	P32(0, COMMA);				// runtime languages
	PNull(BRACE);				// what is this?
	return tage;
    }

    proc DefArrayType(t: Type): seqnoT
    {   var tagb, tagi, taga, tagl: seqnoT;

	tagb = DefType(t@.base);
	tagi = 0;
	if !t@.flex then
	    tagi = DefRange(t@.lo, t@.hi);
	// LLVM wants a list of indices
	if tagi != 0 then
	{   tagl = PListStart();
	    PMetaRef(tagi, BRACE);
	} 
	seqno += 1;  taga = seqno;
	// emit Array
	PTypeHeader(taga, DW_TAG.Array, t);
	PMetaRef(tagb, COMMA);			// derived from
	if tagi == 0 then
	    PNull(COMMA);			// flex
	else
	    PMetaRef(tagl, COMMA);		// index type list
	P32(0, COMMA);				// runtime languages
	PNull(BRACE);				// what is this?
	return taga;
    }

    proc DefField(s: Symb): seqnoT
    {   var tagt, tagf: seqnoT;
	var t: Type;

	t = s@.type;
	tagt = DefType(t);
	seqno += 1;  tagf = seqno;
	// emit Member
	PHeader(tagf, DW_TAG.Member);		// tag
	PMetaRef(file, COMMA);			// context
	PName(s, COMMA);			// name
	PMetaRef(file, COMMA);			// file
	P32(0, COMMA);				// line
	P64(_uint64(t@.width), COMMA);		// size
	P64(_uint64(t@.align), COMMA);		// align
	P64(s@.addr, COMMA);			// offset
	P32(0, COMMA);				// flags
	PMetaRef(tagt, BRACE);			// derived from
	return tagf;
    }

    proc DefRecordType(t: Type): seqnoT
    {   var tag, list, rec: seqnoT;
	var s: Symb;
	var term: TermT;

	// must put the record out first in case of recursion
	// (e.g. field in record points to record)
	seqno += 1;  rec = seqno;
	t@.dbtag = rec;
	seqno += 1;  list = seqno;
	// emit Structure
	PTypeHeader(rec, DW_TAG.Structure, t);
	PNull(COMMA);				// derived from
	PMetaRef(list, COMMA);			// field list
	P32(0, COMMA);				// runtime languages
	PNull(BRACE);				// what is this?
	// then output all the fields and their types
	s = t@.list;
	while s != 0 do
	{   if s@.dbtag == 0 then
		s@.dbtag = DefField(s);
	    s = s@.next;
	}
	// finally the list of fields
	PMetaSeq(list);
	term = COMMA; 
	s = t@.list;
	while s != 0 do
	{   tag = s@.dbtag;
	    s = s@.next;
	    if s == 0 then term = BRACE;
	    PMetaRef(tag, term);
	}
	return rec;
    }

    proc DefType(t: Type): seqnoT
    {   var tag: seqnoT;

	if t == 0 then return 0;
	tag = t@.dbtag;
	if tag == 0 then
	{   if t@.kind
	    is ENUM then
	    {   if t == type.booltype then
		    tag = DefBasicType(DW_ATE.Boolean, t);
		else
		    tag = DefEnumerationType(t);
	    }
	    is UINT then
	    {   if t == type.bytetype then
		    tag = DefBasicType(DW_ATE.UnsignedChar, t);
		else if t == type.wordtype ||
			t == type.uinttypes[0] ||
			t == type.uinttypes[1] ||
			t == type.uinttypes[2] ||
			t == type.uinttypes[3] then
		    tag = DefBasicType(DW_ATE.Unsigned, t);
		else
		    tag = DefRange(t@.lo, t@.hi);
	    }
	    is SINT then
	    {   if t == type.swordtype ||
		   t == type.inttypes[0] ||
		   t == type.inttypes[1] ||
		   t == type.inttypes[2] ||
		   t == type.inttypes[3] then
		    tag = DefBasicType(DW_ATE.Signed, t);
		else
		    tag = DefRange(t@.lo, t@.hi);
	    }
	    is REF, REFPROC then tag = DefRefType(t);
	    is ARRAY then tag = DefArrayType(t);
	    is RECORD then tag = DefRecordType(t);
	    t@.dbtag = tag;
	}
	return tag;
    }

    proc DefLines()
    {   var ln: Line;

	ln = lnhead;
	while ln != 0 do
	{   PMetaSeq(ln@.tag);
	    P32(ln@.lineno, COMMA);			// line
	    P32(1, COMMA);				// column?
	    PMetaRef(ln@.context, COMMA);
	    PNull(BRACE);
	    ln = ln@.next;
	}
	lnhead = 0;
	lntail = 0;
    }

    proc PLine(lineno: _uint16)
    {   var tag: seqnoT;
	var ln: Line;

	if lntail != 0 && lntail@.lineno == lineno then
	    tag = lntail@.tag;
	else
	{   seqno += 1;
	    tag = seqno;
	    ln = Line(sys.zalloc(LineT?size));
	    ln@.tag = tag;
	    ln@.lineno = lineno;
	    ln@.context = GetLineContext();
	    if lntail == 0 then
		lnhead = ln;
	    else
		lntail@.next = ln;
	    lntail = ln;
	}
	f.str(", !dbg ");
	PSeq(tag);
    }

    proc DefVar(s: Symb): seqnoT
    {   var tag: seqnoT;

	seqno += 1;
	s@.dbtag = seqno;
	if s@.linkage
	is LOCAL, FORMAL then
	{
	    f.str("\tcall void @llvm.dbg.declare(metadata !{");
	    llvm.PType(s@.type);
	    f.str("* ");
	    llvm.PName(s);
	    f.str("}, ");
	    f.str("metadata !");
	    f.uint(seqno);
	    f.chr(')');
	    PLine(s@.lineno);
	    f.nl();	
	    if s@.linkage != FORMAL then
	    {   s@.next = 0;
		if lvtail == 0 then
		    lvhead = s;
		else
		    lvtail@.next = s;
		lvtail = s;
	    }
	}
	else
	{
	    tag = DefType(s@.type);
	    PHeader(s@.dbtag, DW_TAG.GlobalVariable);	// tag
	    P32(0, COMMA);				// unused
	    PNull(COMMA);				// context
	    PFullName(s, COMMA);			// name
	    PFullName(s, COMMA);			// display name
	    PString(0, COMMA);				// linkage name
	    PMetaRef(file, COMMA);			// file
	    P32(s@.lineno, COMMA);			// line
	    PMetaRef(tag, COMMA);			// type
	    P32(_uint32(s@.linkage == NORMAL), COMMA);	// is "static"
	    P32(_uint32(s@.linkage != EXTERN), COMMA);	// is a definition
	    llvm.PType(s@.type);
	    f.str("* ");
	    llvm.PName(s);
	    PTerminator(BRACE);
	    // We are re-using the next field in Symb,
	    // we are done using it, right?
	    s@.next = 0;
	    if gvtail == 0 then
	    {   gvhead = s;
		gvtail = s;
	    }
	    else
	    {   gvtail@.next = s;
		gvtail = s;
	    }
	}
	return seqno;
    }

    proc DefSubroutine(stag: seqnoT, ps: Symb)
    {   var tag, list: seqnoT;
	var s: Symb;
	var tl: type.TypeList;
	var term: TermT;

	// FIXME: what about multiple returned values?
	// define all the returned values and formals
	tl = ps@.retvlist;
	while tl != 0 do
	{   DefType(tl@.type);
	    tl = tl@.next;
	}
	s = ps@.parmlist;
	while s != 0 do
	{   DefType(s@.type);
	    s = s@.next;
	}
	// now create the list of returned values and formals
	list = PListStart();
	tl = ps@.retvlist;
	s = ps@.parmlist;
	term = COMMA;
	if tl == 0 then				// no return value
	{   if s == 0 then term = BRACE;
	    PNull(term);
	}
	else
	{   while tl != 0 do
	    {   tag = tl@.type@.dbtag;
		tl = tl@.next;
		if tl == 0 && s == 0 then term = BRACE;
		PMetaRef(tag, term);
	    }
	}
	term = COMMA;
	while s != 0 do
	{   tag = s@.type@.dbtag;
	    s = s@.next;
	    if s == 0 then term = BRACE;
	    PMetaRef(tag, term);
	}
	// emit SubroutineType
	PHeader(stag, DW_TAG.SubroutineType);	// tag
	P32(0, COMMA);				// was context?
	PString(0, COMMA);			// clang prints ""
	P32(0, COMMA);				// was file?
	P32(0, COMMA);				// line
	P64(0, COMMA);				// size
	P64(0, COMMA);				// align
	P64(0, COMMA);				// offset
	P32(0, COMMA);				// flags?
	PNull(COMMA);				// what is this?
	PMetaRef(list, COMMA);			// retv and formals?
	P32(0, COMMA);				// runtime language
	P32(0, BRACE);				// containing type
    }

    proc ProcStart(ps: Symb)
    {
	seqno += 1;  subr = seqno;
	seqno += 1;  blok = seqno;
    }

    proc ProcFinish(ps: Symb)
    {   var s: Symb;
	var stype, stag, ttag, fvars, empty: seqnoT;
	var argno: _uint;

	seqno += 1;  stype = seqno;
	// emit SubProgram
	PHeader(subr, DW_TAG.Subprogram);		// tag
	P32(0, COMMA);					// unused
	PContext(COMMA);				// context
	PFullName(ps, COMMA);				// name
	PFullName(ps, COMMA);				// display name
	PString(0, COMMA);				// linkage name
	PMetaRef(file, COMMA);				// file
	P32(ps@.lineno, COMMA);				// line
	PMetaRef(stype, COMMA);				// subroutine type
	PBoolean(false, COMMA);				// FIXME: local
	PBoolean(ps@.linkage != EXTERN, COMMA);		// is a definition
	P32(0, COMMA);					// virtuality
	P32(0, COMMA);					// virtual index
	PNull(COMMA);					// base type
	P32(256, COMMA);				// FIXME: DIFlags
	PBoolean(false, COMMA);				// FIXME: is optimized
	llvm.PRetvType(ps@.retvlist, false);
	f.str(" (");
	s = ps@.parmlist;
	while s != 0 do
	{   llvm.PType(s@.type);
	    s = s@.next;
	    if s != 0 then f.str(", ");
	}
	f.str(")* ");
	llvm.PName(ps);
	PTerminator(COMMA);				// pointer to function
	PNull(COMMA);					// template parameters
	PNull(COMMA);					// function declaration
	seqno += 1;  fvars = seqno;
	PMetaRef(fvars, COMMA);				// function variables
	P32(ps@.lineno+1, BRACE);			// FIXME: scope line
	// FIXME function variables null list?
	empty = PEmptyList();
	PMetaSeq(fvars);
	PMetaRef(empty, BRACE);
	ps@.dbtag = subr;	// save tag
	ps@.next = 0;		// and add to subprogram list
	if sptail == 0 then
	    sphead = ps;
	else
	    sptail@.next = ps;
	sptail = ps;

	// define all the formals and returned values
	DefFormals(ps);
	DefRetvs(ps);
	// output the subroutine type descriptor
	DefSubroutine(stype, ps);
	// output formal argument descriptors
	{   argno = 0;
	    s = ps@.parmlist;
	    while s != 0 do
	    {   argno += 1;
	    	ttag = DefType(s@.type);
		stag = s@.dbtag;
		if stag == 0 then	// FIXME: shouldn't happen
		{   seqno += 1;
		    stag = seqno;
		}
		PHeader(stag, DW_TAG.ArgVariable);	// tag
		PMetaRef(subr, COMMA);			// context
		PName(s, COMMA);			// name
		PMetaRef(file, COMMA);			// file
		P32(s@.lineno|(argno<<24), COMMA);	// line+argno
		PMetaRef(ttag, COMMA);			// type
		P32(0, COMMA);				// flags?
		P32(0, BRACE);				// what is this?
		s = s@.next;
	    }
	}

	// output lexical block (only one per procedure)
	PHeader(blok, DW_TAG.Block);			// tag
	PMetaRef(subr, COMMA);				// context
	P32(ps@.lineno, COMMA);				// line
	P32(1, COMMA);					// column
	PMetaRef(file, COMMA);				// file
	P32(lexblkno, BRACE);				// unique id?
	lexblkno += 1;
	// output local variable descriptors
	s = lvhead;
	while s != 0 do
	{   ttag = DefType(s@.type);
	    stag = s@.dbtag;
	    PHeader(stag, DW_TAG.AutoVariable);		// tag
	    PMetaRef(blok, COMMA);			// context
	    PName(s, COMMA);				// name
	    PMetaRef(file, COMMA);			// file
	    P32(s@.lineno, COMMA);			// line
	    PMetaRef(ttag, COMMA);			// type
	    P32(0, COMMA);				// flags?
	    P32(0, BRACE);				// what is this?
	    s = s@.next;
	}
	// output line number descriptors
	DefLines();
	lvhead = 0;
	lvtail = 0;
	subr = 0;
	blok = 0;
    }

    proc PackageStart(name: @[]_byte)
    {
    }

    proc PackageEnd()
    {
    }

    proc FileStart(fs: Symb)
    {   var i: _uint;
	var name: @[]_byte;

	name = fs@.ident;
	seqno += 1;  file = seqno;
	fs@.dbtag = file;
	PHeader(file, DW_TAG.File);		// tag
	// need to split the name into file and directory
	i = zstr.rfind(name, '/', lex.PathMax);
	if i == lex.PathMax then		// '/' not found
	{   PString(name, COMMA);		// file
	    PString("", COMMA);			// directory
	}
	else
	{   name[i] = 0;
	    PString(name[i+1:], COMMA);		// file
	    PString(name, COMMA);		// directory
	}
	PNull(BRACE);				// unused
    }

    proc FileFinish(fs: Symb)
    {   var ps: Symb;

	ps = fs@.package;
	if ps != 0 then
	    file = ps@.dbtag;		// tag of containing file
	else
	    file = 0;			// must be final end of file
    }

    proc ProgStart(fs: Symb, opt: boolean)
    {
	f.str(
	 "declare void @llvm.dbg.declare(metadata, metadata) nounwind readnone\n");
	seqno = 0;	// This should be the first thing called
	unit = seqno;
	seqno += 1;  enums = seqno;
	seqno += 1;  retained = seqno;
	seqno += 1;  subprogs = seqno;
	seqno += 1;  globals = seqno;
	// emit anchor
    	f.str("!llvm.dbg.cu = !{!"); f.uint(unit); f.str("}\n");
	// emit Compile Unit
	PHeader(unit, DW_TAG.CompileUnit);	// tag
	P32(0, COMMA);				// unused
	P32(DWLanguage, COMMA);			// language id
	PString(fs@.ident, COMMA);		// filename
	PString(0, COMMA);			// directory FIXME
	PString("ESL", COMMA);			// producer
	PBoolean(true, COMMA);			// is main
	PBoolean(opt, COMMA);			// is optimized
	PString(0, COMMA);			// flags
	P32(0, COMMA);				// runtime version
	PMetaRef(enums, COMMA);			// list of enum types
	PMetaRef(retained, COMMA);		// list of retained types
	PMetaRef(subprogs, COMMA);		// list of subprograms
	PMetaRef(globals, BRACE);		// list of global variables
    }

    proc ProgFinish()
    {   var s: Symb;
	var tag, empty, list: seqnoT;
	var term: TermT;

	// output an empty list
	seqno += 1;  empty = seqno;
	PMetaSeq(empty);
	f.str("i32 0 }\n");
	// output list of enums (NOT USED YET)
	PMetaSeq(enums);
	PMetaRef(empty, BRACE);
	// output list of retained types (NOT USED, WHAT IS THIS?)
	PMetaSeq(retained);
	PMetaRef(empty, BRACE);
	// output list of subprograms
	list = PListStart();
	s = sphead;
	if s != 0 then
	{   term = COMMA;
	    while s != 0 do
	    {   tag = s@.dbtag;
		s = s@.next;
		if s == 0 then term = BRACE;
		PMetaRef(tag, term);
	    }
	}
	else
	    PMetaRef(empty, BRACE);
	PMetaSeq(subprogs);
	PMetaRef(list, BRACE);
	// output list of global variables
	list = PListStart();
	s = gvhead;
	if s != 0 then
	{   term = COMMA;
	    while s != 0 do
	    {   tag = s@.dbtag;
		s = s@.next;
		if s == 0 then term = BRACE;
		PMetaRef(tag, term);
	    }
	}
	else
	    PMetaRef(empty, BRACE);
	PMetaSeq(globals);
	PMetaRef(list, BRACE);
    }
}

