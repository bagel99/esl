// Copyright (c) 2009-2011, Brian G. Lucas.  See LICENSE file.
// $Id$

package lex
{
    // Order is warnings, errors, internal errors
    type Errors:
    (   // Warnings
	NOTIMPL,    EXPERIMENT,
	TRUNC,      TOSIGNED,   TOUNSIGN,   BADINTPTR,  AMBIGUOUS,
	// Errors
	BADNL,      ILLCHR,     ILLUTF8,    CMTEOF,     BADEOF,     BADCHR,
	BADHEXESC,  BADUTF8,    IDLONG,     STRLONG,    EXPECT,     EXPECTID,
	UNDEFID,    DEFID,      UNDEFFIELD, BADID,      BADREF,     BADINDEX,
	NOIDTYPE,   NOTTYPE,    NOTYPE,     NOTENUM,    BADTYPE,    OPTYPE,
	BADTYPDEF,  BADATTR,    UNDEFSTMT,  BADSTMTI,   BADSTMTT,   BADCOMPARE,
	BADASSIGN,  ILLASSIGN,  LHSASSIGN,  RHSASSIGN,  TYPEASSIGN, RHSLESS,
	RHSMORE,    BADRETURN,  FORWPROC,   FORWPARM,   FORWRETV,   WANTBOOL,
	WANTUINT,   BADCAST,    UNDFCOMPV,  BADCOMPV,   PROPID,     BADIF,
	BADIS,      NOPROC,     NOLOOP,     NOPACK,     NOTREF,     NOTARRAY,
	ARRAYCOPY,  BADINXEXP,  NOTRECORD,  BADRECORD,  BASERECORD, BASEENUM,
	ARGSLO,     ARGSHI,     PARMTYPE,   INITHI,     BADCONST,   EXPCONST,
	BADIMPORT,  NOTVAR,     BADFLEX,    FORWNOFIX,  BADFOR,     SECTNAME,
	BADPACKED,  NOSIZE,     NEEDSIZE,   BADSIZE,    BADAT,
	PROGERROR,  // error statement
	COMPILER    // internal compiler error
    );
    const FirstError:Errors = BADNL;
    const ErrMsg:[Errors]@[]Char =
    {
	[NOTIMPL] =	"Feature not yet implemented: ",
	[EXPERIMENT] =  "Feature is experimental: ",
	[TRUNC] =	"Truncation may cause loss of data",
	[TOSIGNED] =	"Converting unsigned to signed integer",
	[TOUNSIGN] =	"Converting signed to unsigned integer",
	[BADINTPTR] =	"Pointer converted from wrong size integer",
	[AMBIGUOUS] =   "Use of identifier is ambiguous: ",
	[BADNL] =	"End of line in string or character constant",
	[ILLCHR] =      "Illegal character in source",
	[ILLUTF8] =     "Illegal byte in UTF8 sequence",
	[CMTEOF] =	"End of file in comment",
	[BADEOF] =	"Unexpected end of file",
	[BADCHR] =	"Malformed character constant",
	[BADHEXESC] =	"Malformed hex escape in string or character constant",
	[BADUTF8] =	"Malformed unicode escape",
	[IDLONG] =	"Identifier too long",
	[STRLONG] =	"String too long",
	[EXPECT] =	"Expected: ",
	[EXPECTID] =	"Expected identifier",
	[UNDEFID] =	"Undefined identifier: ",
	[DEFID] =	"Identifier already in use: ",
	[UNDEFFIELD] =	"Undefined field: ",
	[BADID] =	"Unexpected identifier: ",
	[BADREF] =	"Cannot dereference incomplete type",
	[BADINDEX] =	"Illegal index specification",
	[NOIDTYPE] =	"Identifier has no type: ",
	[NOTTYPE] =	"Expected type identifier",
	[NOTYPE] =	"Error in type definition",
	[NOTENUM] =	"Enumeration type required",
	[BADTYPE] =	"Illegal use of type identifier: ",
	[OPTYPE] =	"Operation not suppported for type",
	[BADTYPDEF] =	"Error in type definition",
	[BADATTR] =	"Unknown attribute: ",
	[UNDEFSTMT] =	"Statement begins with undefined identifier: ",
	[BADSTMTI] =	"Statement begins with inappropriate identifier: ",
	[BADSTMTT] =	"Statement begins with inappropriate token: ",
	[BADCOMPARE] =	"Illegal comparison, bad type perhaps",
	[BADASSIGN] =	"Syntax error in possible assignment statement",
	[ILLASSIGN] =	"Illegal assignment",
	[LHSASSIGN] =	"Illegal lhs in assignment",
	[RHSASSIGN] =	"Illegal rhs in assignment",
	[TYPEASSIGN] =	"Type mismatch in assignment",
	[RHSLESS] =	"Not enough rhs values in assignment",
	[RHSMORE] =	"Too many rhs values in assignment",
	[BADRETURN] =	"Return with no value in procedure that expects one",
	[FORWPROC] =	"Call of undefined forward procedure: ",
	[FORWPARM] =	"Parameter types changed from forward declaration: ",
	[FORWRETV] =	"Return value types changed from forward declaration: ",
	[WANTBOOL] =	"Boolean expression required",
	[WANTUINT] =	"Unsigned integer expression required",
	[BADCAST] =	"Illegal cast",
	[UNDFCOMPV] =	"Missing type for composite value",
	[BADCOMPV] =	"Illegal type for composite value",
	[PROPID] =	"Missing or undefined property identifier",
	[BADIF] =	"Expecting \"then\" or \"is\"",
	[BADIS] =	"Error in \"is\" clause",
	[NOPROC] =	"Return statement not in procedure",
	[NOLOOP] =	"Exit statement not in a loop",
	[NOPACK] =	"Unknown statement in package",
	[NOTREF] =	"Not a pointer",
	[NOTARRAY] =	"Not an array",
	[ARRAYCOPY] =	"Array copy with undefined length",
	[BADINXEXP] =   "Illegal array index",
	[NOTRECORD] =	"Not a record",
	[BADRECORD] =	"Syntax error in record declaration",
	[BASERECORD] =	"Base type must be a record",
	[BASEENUM] =	"Base type must be an enumeration",
	[ARGSLO] =	"Insufficient arguments to procedure call",
	[ARGSHI] =	"Too many arguments to procedure call",
	[PARMTYPE] =	"Actual parameter type not compatible with formal",
	[INITHI] =	"Too many initializers",
	[BADCONST] =	"Const requires a constant value",
	[EXPCONST] =	"Expression must be a compile-time constant",
	[BADIMPORT] =	"Unable to open file: ",
	[NOTVAR] =      "Expected variable identifier",
	[BADFLEX] =     "Flexible array must be final field",
	[FORWNOFIX]=    "Unresolved forward symbol: ",
	[BADFOR] =      "Syntax error in for statement",
	[SECTNAME] =    "Expected section name",
	[BADPACKED] =   "Packed record or array too large",
	[NOSIZE] =      "Can not specify size for fixed sized object",
	[NEEDSIZE] =    "Must specify size for variable sized object",
	[BADSIZE] =     "Specified size smaller that actual object size",
	[BADAT] =       "Illegal field offset specified",
	[PROGERROR] =   "Program defined error: ",
	[COMPILER] =    "Internal compiler error: "
    };
    // Lines commented ** must have the tokens consecutive
    type TokenT:
    (   NONE,	ENDF,
	DOT,	COLON,	SEMI,	COMMA,	RANGE,	AT,	QUEST,
	ASGN,	INCR,	DECR,				// **
	NOT,	INV,    PLUS,	MINUS,	OR,	XOR,	// must be contiguous
	STAR,	DIV,	MOD,	SHL,	SHR,	AND,	// must be contiguous
	EQ,	NE,	LT,	GT,	LE,	GE,	// must be contiguous
	BAND,	BOR,					// **
	PBEG,	PEND,	ABEG,	AEND,	GBEG,	GEND,
	NUM,	FNUM,   STR,
	ID,		// all keywords follow this
	KTYPE,	KVAR,	KCONST,	KIMPORT,KALIAS,	KERROR,
	KPROC,	KPACKAGE,
	KASM,   KCALL,
	KRET,   KIF,	KWHILE,				// must be contiguous
	KFOR,	KLOOP,	KEXIT,
	KTHEN,	KELIF,  KELSE,	KIS,    KDO,	KWITH,  KAS,
	KIN,	KFROM,	KTO,    KBY,			// for loop support
	// attributes begin here
	KPACK,	KNOPAD,	KLSB,	KMSB,	KLE,	KBE,
	KRO,	KWO,	KINPUT,	KOUTPUT,KAT,
	KEXTERN,KGLOBAL,KSECTION,KALIGN,
	KINLINE,KNOINLINE,KINTR,KWEAK,
	// type properties begin here
	KMIN,	KMAX,	KBITSZ,	KMEMSZ,	KLEN
    );
    const keywords:[TokenT]@[]Char =
    {	[NONE] =	"",		// none
	[ENDF] =	"ENDOFFILE",
	[DOT] =		".",
	[COLON] =	":",
	[SEMI] =	";",
	[COMMA] =	",",
	[RANGE] =	"..",
	[AT] =		"@",
	[QUEST] =	"?",
	[ASGN] =	"=",
	[INCR] =	"+=",
	[DECR] =	"-=",
	[NOT] =		"!",
	[INV] =		"~",
	[PLUS] =	"+",
	[MINUS] =	"-",
	[OR] =		"|",
	[XOR] =		"^",
	[STAR] =	"*",
	[DIV] =		"/",
	[MOD] =		"%",
	[SHL] =		"<<",
	[SHR] =		">>",
	[AND] =		"&",
	[EQ] =		"==",
	[NE] =		"!=",
	[LT] =		"<",
	[GT] =		">",
	[LE] =		"<=",
	[GE] =		">=",
	[BAND] =	"&&",
	[BOR] =		"||",
	[PBEG] =	"(",
	[PEND] =	")",
	[ABEG] =	"[",
	[AEND] =	"]",
	[GBEG] =	"{",
	[GEND] =	"}",
	[NUM] =		"NUMBER",
	[FNUM] =	"FNUM",
	[STR] =		"STRING",
	[ID] =		"IDENT",
	[KTYPE] =	"type",
	[KVAR] =	"var",
	[KCONST] =	"const",
	[KIMPORT] =	"import",
	[KALIAS] =	"alias",
	[KERROR] =      "error",
	[KPROC] =	"proc",
	[KPACKAGE] =	"package",
	[KASM] =	"asm",
	[KCALL] =       "call",
	[KRET] =	"return",
	[KIF] =		"if",
	[KWHILE] =	"while",
	[KFOR] =	"for",
	[KLOOP] =	"loop",
	[KEXIT] =	"exit",
	[KTHEN] =	"then",
	[KELIF] =       "elif",
	[KELSE] =	"else",
	[KIS] =		"is",
	[KDO] =		"do",
	[KWITH] =	"with",
	[KAS] =		"as",
	[KIN] =		"in",
	[KFROM] =	"from",
	[KTO] =		"to",
	[KBY] =		"by",
	[KPACK] =	"packed",       // attributes for types
	[KNOPAD] =	"nopad",
	[KLSB] =	"lsb",
	[KMSB] =	"msb",
	[KLE] =		"le",
	[KBE] =		"be",
	[KRO] =		"ro",
	[KWO] =		"wo",
	[KINPUT] =	"in",
	[KOUTPUT] =	"out",
	[KAT] =		"at",
	[KEXTERN] =	"external",	// attributes for vars and procs
	[KGLOBAL] =	"global",
	[KSECTION] =	"section",
	[KALIGN] =	"align",
	[KINLINE] =	"inline",	// attributes for procs
	[KNOINLINE] =   "noinline",
	[KINTR] =	"interrupt",
	[KWEAK] =       "weak",
	[KMIN] =	"min",		// properties
	[KMAX] =	"max",
	[KBITSZ] =	"bits",
	[KMEMSZ] =	"size",
	[KLEN]=		"len"
    }; 
    type TokenList: []TokenT;
    const StringMax = 4095;
    type StringRange: 0..StringMax;
    const IdentMax = 255;
    const BufSize = 4096;
    type BufRange: 0..BufSize;
    const PathMax = 1024;	// Max chars in a pathname
    type PathRange: 0..PathMax;
    const NameMax =  256;	// Max chars in filename
    const LinesMax = 0xFFFF;	// Max lines in a file, files in a program
    type LinesRange: 0..LinesMax;
    const ErrorMax = 10;	// Max errors before terminate
    type SearchPathEntry:
    {   next:		@SearchPathEntry;
	path:		[]Char;
    };
    type Path: @SearchPathEntry;
    var  pathhead, pathtail:Path;

    type FileListEntry:
    {   next:		@FileListEntry;
	name:		[]Char;
    };
    type FileList: @FileListEntry;
    var  filehead, filetail: FileList;

    type FileContext:
    {
	prev:		@FileContext;
	filepath:	Path;
	filename:	FileList;
	fd:		sys.fildes;
	lineno:		LinesRange;
	cchar:		BufRange;		// index into buf
	nchar:		BufRange;		// num valid chars in buf
	buf:		[BufSize]Char;
    };
    type File: @FileContext;
    var f: File;
    type Identifier: []Char;
    var ErrorCount: 0..ErrorMax;
    var Token: TokenT;			// current token
    var Ident: [IdentMax+1]Char;	// if token is an IDENT
    var Number: _uint64;		// if token is a NUM or FNUM
    var Scale:  _int16;			// power of 10 for FNUM
    var StringLen: 0..StringMax;	// if token is a STR
    var StringBuf: [StringMax+1]Char;	// if token is a STR
    type State:
    (   FIRST,	// first character
	DIV,	// seen "/"
	CMTLN,	// seen "//", skipping to EOL
	CMTBK,	// seen "/*", skipping to "*"
	CMTBE,	// seen "*" in a block comment
	DOT,	// seen "."
	PLUS,	// seen "+"
	MINUS,	// seen "-"
	LT,	// seen "<"
	GT,	// seen ">"
	ASGN,	// seen "="
	NOT,	// seen "!"
	AND,	// seen "&"
	OR,	// seen "|"
	ZERO,	// seen "0"
	BIN,  OCT,  HEX,
	DEC,  DECD, DECF, EXP1, EXP2,
	ID,   ID1,  ID2,  ID3,				// must be consecutive
	CHR,  CHREND,
	STR,
	ESC,
	HEX1, HEX2,					// must be consecutive
	U161, U162, U163, U164,				// must be consecutive
	U321, U322, U323, U324, U325, U326, U327, U328	// must be consecutive
    );
    var saves: State = FIRST;		// look behind state

    // These are for error message use
    proc Filename(): []Char;

    proc Lineno():0..LinesMax
    {
	if f == 0 then
	    return 0;
	return f@.lineno;
    }

    proc ErrorSub(error: Errors)
    {
	if f@.filepath != 0 then
	{   err.str(f@.filepath@.path);
	    err.chr('/');
	}
	err.str(f@.filename@.name);
	err.chr(':');
	err.uint(Lineno());
	err.str(": ");
	if error >= FirstError then
	{   ErrorCount += 1;
	    if ErrorCount >= ErrorMax then
	    {   err.str("\nToo many errors, quiting.\n");
		sys.exit(1);
	    }
	    err.str("Error: ");
	}
	else
	    err.str("Warning: ");
	err.str(ErrMsg[error]);
    }

    // Print error message, no parameters
    proc Error(error: Errors)
    {
	ErrorSub(error);
	err.nl();
    }

    // Print error message, parameter is arbitrary string
    proc ErrorS(error: Errors, msg: @[]_byte)
    {
	ErrorSub(error);
	err.str(msg);
	err.nl();
    }

    // Print error message, parameter is identifer
    proc ErrorI(error: Errors, ident: @Identifier)
    {
	ErrorSub(error);
	err.str(ident);
	err.nl();
    }

    // Print error message, parameter is token
    proc ErrorT(error: Errors, tok: TokenT)
    {
	ErrorSub(error);
	err.chr('\'');
	err.str(keywords[tok]);
	err.chr('\'');
	err.nl();
    }

    proc SearchPathAdd(newpath: @[]Char, prepend: boolean): Path
    {   var np: Path;
	var len: _uint;

	len = zstr.len(newpath, PathMax);
	np = Path(sys.malloc(SearchPathEntry?size + len+1));
	zstr.copy(np@.path, newpath, len+1);
	if pathhead == 0 then
	{   np@.next = 0;
	    pathhead = np;
	    pathtail = np;
	}
	else
	{   if prepend then
	    {   np@.next = pathhead;
		pathhead = np;
	    }
	    else
	    {   np@.next = 0;
		pathtail@.next = np;
		pathtail = np;
	    }
	}
	return np;
    }

    proc SearchPathPrint()
    {   var pp: Path;

	err.str("Search path \"");
	pp = pathhead;
	while (pp != 0) do
	{   err.str(pp@.path);
	    err.chr(':');
	    pp = pp@.next;
	}
	err.str("\"\n");
    }

    proc FileListAdd(filename: @[]Char): FileList
    {   var fp: FileList;
	var len: _uint;
	
	len = zstr.len(filename, NameMax);
	fp = FileList(sys.malloc(FileListEntry?size + len+1));
	zstr.copy(fp@.name, filename, len+1);
	if filehead == 0 then
	    filehead = fp;
	else
	    filetail@.next = fp;
	filetail = fp;
	return fp;
    }

    proc FileOpen(filename: @[]Char): boolean
    {   var nf: File;
	var fd: sys.fildes;
	var pp: Path;
	var fp: FileList;
	var i: _uint;
	var pathbuf: [PathMax]Char;

	if f != 0 then		// this is an included file, name missing ".esl"
	{   // search SearchPath trying to open file
	    pp = pathhead;
	    while pp != 0 do
	    {
		zstr.copy(pathbuf, pp@.path, PathMax);
		zstr.cat(pathbuf, "/", PathMax);
		i = zstr.len(pathbuf, PathMax);
		zstr.cat(pathbuf, filename, PathMax);
		zstr.cat(pathbuf, ".esl", PathMax);
		fd = sys.open(pathbuf, sys.O_RDONLY, 0);
	      exit fd >= 0;
		pp = pp@.next;
	    }
	}
	else			// this is the outer file, name has ".esl"
	{   zstr.copy(pathbuf, filename, PathMax);
	    fd = sys.open(pathbuf, sys.O_RDONLY, 0);
	    i = zstr.rfind(pathbuf, '/', PathMax);
	    if i == PathMax then		// '/' not found
	    {   pp = SearchPathAdd(".", true);
		i = 0;
	    }
	    else
	    {   pathbuf[i] = 0;	// terminate
		pp = SearchPathAdd(pathbuf, true);
		i += 1;
	    }
	}
	if fd < 0 then
	    return false;
	fp = FileListAdd(filename);
	if debug.files then
	{   err.str("Open  file \"");
	    if pp != 0 then
	    {   err.str(pp@.path);
		err.chr('/');
	    }
	    err.str(pathbuf[i:]);
	    err.str("\"\n");
	}
	if feature.mflag then
	{
	    msg.str(" \\\n ");
	    if pp != 0 && (pp@.path[0] != '.' || pp@.path[1] != 0) then
	    {   msg.str(pp@.path);
		msg.chr('/');
	    }
	    msg.str(pathbuf[i:]);
	}
	nf = File(sys.malloc(FileContext?size));
	nf@.filename = fp;
	nf@.filepath = pp;
	nf@.fd = fd;
	nf@.lineno = 1;
	nf@.cchar = 0;
	nf@.nchar = 0;
	nf@.prev = f;
	f = nf;
	return true;        
    }

    // Search to see if we have not imported this yet, if not, open it
    proc FileCheck(filename: @[]Char): boolean
    {   var fp: FileList;

	fp = filehead;
	while fp != 0 do
	{
	    if zstr.eq(fp@.name, filename, NameMax) then
		return false;	// already imported
	    fp = fp@.next;
	}
	if FileOpen(filename) then return true;
	ErrorI(BADIMPORT, filename);
	return false;
    }

    proc FileClose()
    {   var of: File;

	if f != 0 then
	{   sys.close(f@.fd);
	    if debug.files then
	    {   err.str("Close file \"");
		if f@.filepath != 0 then
		{   err.str(f@.filepath@.path);
		    err.chr('/');
		}
		err.str(f@.filename@.name);
		err.str("\"\n");
	    }
	    of = f;
	    f = of@.prev;
	    // sys.free(of)
	}
    }

    proc FillBuf()
    {   var k: _int;

	k = sys.read(f@.fd, f@.buf, BufSize);
	if k < 0 then
	    k = 0;
	f@.cchar = 0;
	f@.nchar = BufRange(k);
    }

    proc MakeFnum(n: _uint64, scale1: _uint)
    {   var scale: _int;

	scale = _int(scale1);
	Number = n;
	Scale = scale;
    }

    proc MakeFnumE(n: _uint64, scale1: _uint, scale2: _int)
    {   var scale: _int;

	scale = _int(scale1) - scale2;
	Number = n;
	Scale = scale;
    }

    proc EscChar(c: Char): Char
    {
	if c
	is 'n' then c = 0x0A;	// LF
	is 'r' then c = 0x0D;	// CR
	is 't' then c = 0x09;	// HT
	is 'b' then c = 0x08;	// BS
	is 'v' then c = 0x0B;	// VT
	is 'f' then c = 0x0C;	// FF
	return c;
    }

    proc EscHex(c: Char, h: _uint32): _uint32
    {
	if c
	is '0'..'9' then c -= '0';
	is 'A'..'F' then c = (c - 'A') + 10;
	is 'a'..'f' then c = (c - 'a') + 10;
	else
	{   Error(BADHEXESC);
	    return h;
	} 
	return (h << 4) | c;
    }

    const unicodemax: [4]_uint32 =
	{ 0x0000_007F, 0x0000_07FF, 0x0000_FFFF, 0x0010_FFFF };
    const utf8pfx: [5]_uint8 = { 0x00, 0xC0, 0xE0, 0xF0, 0xF8 };

    proc EscUTF8(unicode: _uint32, j:_uint): _uint
    {   var n, i, k: _uint;

	n = 0;
	loop
	{
	  exit unicode <= unicodemax[n];
	    n += 1;
	  exit n > 3;
	}
	if n >= 4 then		// illegal unicode
	{   Error(BADUTF8);
	    return 0;
	}
	else
	{   k = j+n+1;		// need n+1 bytes
	    if k >= StringMax then
	    {   Error(STRLONG);
		return 0;
	    }
	    i = n;
	    while i > 0 do
	    {   StringBuf[j+i] = 0x80 | 0x3F & _uint8(unicode);
		unicode = unicode >> 6;
		i -= 1;
	    }
	    StringBuf[j] = utf8pfx[n] | _uint8(unicode);
	}
	return k;	
    }

    proc Next():TokenT
    {   var state: State;
	var c: Char;
	var tok: TokenT;
	var i: 0..BufSize;
	var e: 0..BufSize;
	var j, k: 0..StringMax;
	var str, neg: boolean;
	var h: _uint32;		// for hex and unicode escapes
	var n: _uint64;		// for numbers

	state = FIRST;
	if saves != FIRST then
	{   state = saves;
	    saves = FIRST;
	}
	tok = NONE;
	i = f@.cchar;
	e = f@.nchar;
	loop
	{   if i >= e then
	    {   FillBuf();
		i = f@.cchar;
		e = f@.nchar;
		exit e == 0 with
		{   if state
		    is FIRST then {}	// as it should be
		    is CMTLN, CMTBK, CMTBE then
			Error(CMTEOF);
		    else
			Error(BADEOF);
		    tok = ENDF;
		}
	    }
	    c = f@.buf[i];
	    if state
	    is FIRST then
	    {	if c
		is ':' then { tok = COLON;  i += 1; }
		is ';' then { tok = SEMI;   i += 1; }
		is ',' then { tok = COMMA;  i += 1; }
		is '@' then { tok = AT;     i += 1; }
		is '~' then { tok = INV;    i += 1; }
		is '^' then { tok = XOR;    i += 1; }
		is '*' then { tok = STAR;   i += 1; }
		is '%' then { tok = MOD;    i += 1; }
		is '(' then { tok = PBEG;   i += 1; }
		is ')' then { tok = PEND;   i += 1; }
		is '{' then { tok = GBEG;   i += 1; }
		is '}' then { tok = GEND;   i += 1; }
		is '?' then { tok = QUEST;  i += 1; }
		is '[' then { tok = ABEG;   i += 1; }
		is ']' then { tok = AEND;   i += 1; }
		is '.' then state = DOT;
		is '/' then state = DIV;
		is '!' then state = NOT;
		is '<' then state = LT;
		is '>' then state = GT;
		is '=' then state = ASGN;
		is '+' then state = PLUS;
		is '-' then state = MINUS;
		is '&' then state = AND;
		is '|' then state = OR;
		is '0' then      { n = 0;     state = ZERO; }
		is '1'..'9' then { n = c-'0'; j = 1; state = DEC; }
		is '\'' then state = CHR;
		is '"' then { j = 0; state = STR; }
		is ' ','\t','\n','\r','\f' then // whitespace
		{ }

		is 'A'..'Z', 'a'..'z', '_' then
		{   Ident[0] = c;  j = 1; state = ID; }
		is 0xC2 .. 0xDF then		// 2 byte UTF8
		{   Ident[0] = c;  j = 1; state = ID1; }
		is 0xE0 .. 0xEF then		// 3 byte UTF8
		{   Ident[0] = c;  j = 1; state = ID2; }
		is 0xF0 .. 0xF4 then		// 4 byte UTF8
		{   Ident[0] = c;  j = 1; state = ID3; }
		else
		    Error(ILLCHR);
	    }
	    is ID then
		if c
		is 'A'..'Z', 'a'..'z', '0'..'9', '_' then
		{   Ident[j] = c; j += 1; }
		is 0xC2 .. 0xDF then		// 2 byte UTF8
		{   Ident[j] = c;  j += 1; state = ID1; }
		is 0xE0 .. 0xEF then		// 3 byte UTF8
		{   Ident[j] = c;  j += 1; state = ID2; }
		is 0xF0 .. 0xF4 then		// 4 byte UTF8
		{   Ident[j] = c;  j += 1; state = ID3; }
		else
		{   Ident[j] = 0; tok = ID; }   // end of identifier
	    is ID1, ID2, ID3 then     // in a UTF8 sequence in identifier
		if (c & 0b1100_0000) == 0b1000_0000 then
		{   Ident[j] = c; j += 1; state -= 1; }
		else
		    Error(ILLUTF8);
	    is DIV then
		if c
		is '/' then state = CMTLN;
		is '*' then state = CMTBK;
		else    tok = DIV;
	    is CMTLN then
		if c == '\n' then state = FIRST;
	    is CMTBK then
		if c == '*' then state = CMTBE;
	    is CMTBE then
		if c == '/' then state = FIRST; else state = CMTBK;
	    is DOT then
		if c
		is '.' then { tok = RANGE; i += 1; }
		is '0'..'9' then { n = 0; k = 0; j = 0; state = DECD; }
		else    tok = DOT;
	    is PLUS then
		if c
		is '=' then { tok = INCR; i += 1; }
		else    tok = PLUS;
	    is MINUS then
		if c
		is '=' then { tok = DECR; i += 1; }
		else    tok = MINUS;
	    is LT then
		if c
		is '=' then { tok = LE; i += 1; }
		is '<' then { tok = SHL; i += 1; }
		else    tok = LT;
	    is GT then
		if c
		is '=' then { tok = GE; i += 1; }
		is '>' then { tok = SHR; i += 1; }
		else    tok = GT;
	    is ASGN then
		if c
		is '=' then { tok = EQ; i += 1; }
		else    tok = ASGN;
	    is NOT then
		if c
		is '=' then { tok = NE; i += 1; }
		else    tok = NOT;
	    is AND then
		if c
		is '&' then { tok = BAND; i += 1; }
		else    tok = AND;
	    is OR then
		if c
		is '|' then { tok = BOR; i += 1; }
		else    tok = OR;
	    is ZERO then
	    {   if c
		is 'b' then state = BIN;
		is 'o' then state = OCT;
		is 'x' then state = HEX;
		is '0'..'9' then { n = c-'0'; j = 1; state = DEC; }
		is '_'      then {            j = 0; state = DEC; }
		is '.'      then { k = 0;     j = 0; state = DECD; }
		else    { Number = n; tok = NUM; }
	    }
	    is BIN then
		if c
		is '0'..'1' then n = (n<<1) + (c-'0');
		is '_' then {}
		else    { Number = n; tok = NUM; }
	    is OCT then
		if c
		is '0'..'7' then n = (n<<3) + (c-'0');
		is '_' then {}
		else    { Number = n; tok = NUM; }
	    is HEX then
		if c
		is '0'..'9' then n = (n<<4) + (c-'0');
		is 'A'..'F' then n = (n<<4) + (c-'A'+10);
		is 'a'..'f' then n = (n<<4) + (c-'a'+10);
		is '_' then {}
		else    { Number = n; tok = NUM; }
	    is DEC then
		if c
		is '0'..'9' then { n = n*10 + (c-'0'); j += 1; }
		is '_' then {}
		is '.' then { k = 0; state = DECD; }
		else    { Number = n; tok = NUM; }
	    is DECD then
		if c
		is '.' then     // simple decimal integer followed by ..
		    { saves = DOT; Number = n; tok = NUM; }
		is '0'..'9' then
		{   n = n*10 + (c-'0'); j += 1;
		    k += 1; state = DECF;
		}
		is '_' then {}
		is 'e','E' then state = EXP1;
		else { MakeFnum(n, k); tok = FNUM; }
	    is DECF then
		if c
		is '0'..'9' then { n = n*10 + (c-'0'); j += 1; k += 1; }
		is '_' then {}
		is 'e','E' then state = EXP1;
		else { MakeFnum(n, k); tok = FNUM; }
	    is EXP1 then
		if c
		is '-' then { h = 0; neg = true; state = EXP2; }
		is '+' then { h = 0; neg = false; state = EXP2; }
		is '0'..'9' then { h = c-'0'; neg = false; state = EXP2; }
		else { /* FIXME - error */ state = FIRST; }
	    is EXP2 then
		if c
		is '0'..'9' then { h = h*10 + (c-'0'); }
		else 
		{   var exp: _int;
		    exp = _int(h);
		    if neg then exp = -exp;
		    MakeFnumE(n, k, exp); tok = FNUM;
		}
	    is CHR then
	    {	str = false;
		if c
		is '\'' then { Error(BADCHR); state = FIRST; }
		is '\n' then { Error(BADNL); state = FIRST; }	
		is '\\' then state = ESC;
		else     { h = c; state = CHREND; }
	    }
	    is CHREND then
		if c
		is '\'' then { Number = h; tok = NUM; i += 1; }
		else     { Error(BADCHR); state = FIRST; }
	    is STR then
	    {   str = true;
		if c
		is '"' then
		{   StringBuf[j] = 0;	// terminate
		    StringLen = j+1;
		    tok = STR; i += 1;
		}
		is '\n' then { Error(BADNL); state = FIRST; }
		is '\\' then state = ESC;
		else
		{   if j < StringMax then { StringBuf[j] = c; j += 1; }
		    else Error(Errors.STRLONG);
		}
	    }
	    is ESC then
		if c
		is '\n' then { Error(BADNL); state = FIRST; }	// NL in escape
		is 'x' then { h = 0; state = HEX1; }
		is 'u' then { h = 0; state = U161; }
		is 'U' then { h = 0; state = U321; }
		else
		{   if str then
		    {   if j < StringMax then { StringBuf[j] = EscChar(c); j += 1; }
			else Error(STRLONG);
			state = STR;
		    }
		    else { h = EscChar(c); state= CHREND; }
		}
	    is HEX1, U161 .. U163, U321 .. U327 then
		if c
		is '\n' then { Error(BADNL); state = FIRST; }	// NL in escape
		else
		{   h = EscHex(c, h);
		    state += 1;	// WARNING: depends on consecutive state
		}
	    is HEX2 then
		if c
		is '\n' then { Error(BADNL); state = FIRST; }	// NL in escape
		else
		{   h = EscHex(c, h);
		    if str then
		    {   if j < StringMax then { StringBuf[j] = Char(h); j += 1; }
			else Error(STRLONG);
			state = STR;
		    }
		    else state = CHREND;
		}
	    is U164, U328 then
		if c
		is '\n' then { Error(BADNL); state = FIRST; }	// NL in escape
		else
		{   h = EscHex(c, h);
		    if str then
		    {   j = StringRange(EscUTF8(h, j));
			state = STR;
		    }
		    else state = CHREND;
		}
	  exit tok != NONE;
	    if c == '\n' then
		f@.lineno += 1;
	    i += 1;
	}
	f@.cchar = i;
	Token = tok;
	return tok;
    }


    proc Keyword(toklist: @TokenList): TokenT
    {   var tok: TokenT;
	var i: _uint;

	if Token == ID then
	{   i = 0;
	    loop
	    {   tok = toklist[i];
	      exit tok == NONE;
		if zstr.eq(Ident, keywords[tok]@, IdentMax) then
		    return tok;
		i += 1;
	    }
	}
	return Token;
    }

    proc Expect(expect: TokenT): TokenT
    {   var tok: TokenT;
	var toklist: [2]TokenT;

	tok = Token;
	if expect > ID then
	{   toklist[0] = expect;
	    toklist[1] = NONE;
	    tok = Keyword(toklist);
	}
	if tok == expect then
	    tok = Next();
	else
	    ErrorT(EXPECT, expect);
	return tok;
    }

    // FIXME: temporary debugging aid
    proc WhereAmI(msg: @[]_byte)
    {
	err.str(msg);
	err.str(" line="); err.uint(Lineno());
	err.str(" tok=");
	err.str(keywords[Token]);
	if Token == ID then
	{   err.str(" \"");
	    err.str(Ident);
	    err.chr('"');
	}
	err.nl();
    }

    const plist: []TokenT = { PEND, NONE };
    const alist: []TokenT = { AEND, NONE };
    const glist: []TokenT = { GEND, NONE };

    proc Skip(toklist: @TokenList): TokenT
    {   var tok, ttok: TokenT;
	var i: _uint;

	tok = Next();
/*
WhereAmI("Skip start:");
err.str("\tlist=");
i = 0; loop
{  ttok = toklist[i];
  exit ttok == NONE;
   err.chr('"'); err.str(keywords[ttok]); err.str("\" ");
   i += 1;
}
err.nl();
*/
	ttok = ENDF;
	while tok != ENDF do
	{   i = 0;
	    loop
	    {   ttok = toklist[i];
	      exit ttok == NONE || tok == ttok;
	      exit ttok > ID && zstr.eq(Ident, keywords[ttok]@, IdentMax);
		i += 1;
	    }
	  exit ttok != NONE;
	    if tok	// handle nested constructs
	    is PBEG then tok = Skip(plist);
	    is ABEG then tok = Skip(alist);
	    is GBEG then tok = Skip(glist);
	    tok = Next();
	}
/*
WhereAmI("Skip end:");
err.str("\ttok="); err.str(keywords[tok]);
err.str(" ttok="); err.str(keywords[ttok]);
err.nl();
*/
	return ttok;
    }

    proc Want(toklist: @TokenList): TokenT
    {   var tok: TokenT;

	tok = Token;
	if tok != toklist[0] then
	{   ErrorT(EXPECT, toklist[0]);
	    tok = Skip(toklist);
	}
	return tok;
    }

}
// vim: ts=8 sw=4 noet nowrap

