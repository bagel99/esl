// Copyright (c) 2009, 2010, Brian G. Lucas.  See LICENSE file.
// $Id: llvm.esl 543 2011-04-01 00:33:13Z bgl $

// Convert AST to LLVM assembly
package llvm
{
    const package_delimiter:Char = '_';
    const anon_prefix: []Char = "A.";
    const scon_prefix: []Char = "S.";
    type file: sys.fildes;
    var  f: file;
    type typeoptions: (NONE, PACK);
    proc PType(t: Type, opt: typeoptions);			// forward
    proc PName(s: Symb);					// forward
    proc PRetvType(tl: type.TypeList, extend: boolean);		// forward
    proc PParmTypes(s: Symb);					// forward
}

import llvmdb;

package llvm
{
    const llvm_memop_bug: boolean = true;	// memcpy intrinsic wants i8*
    type pstring: @[]_byte;
    // These pointer types might be useful to other packages.
    var pbytetype: Type;
    var puinttype: [4]Type;
    type seqnoT: 0..0xFFFF;
    var Tseqno: seqnoT;
    var Pseqno: seqnoT = 0;
    var Lseqno: seqnoT = 0;
    var Aseqno: _uint16 = 0;
    var labthis: seqnoT;	// label sequence number of this basic block
    var loopexit: seqnoT;	// label sequence number for this loop exit
    type Intrinsics:
    (   MEMCPY, MEMMOVE, BSWAP2, BSWAP4, BSWAP8,
	MEMCMP1, MEMCMP2, MEMCMP4, MEMCMP8,	// must be in order
	END
    );
    var UseIntrinsic: [Intrinsics]boolean;

    proc GenSub(node: Ast): boolean;	// forward
    proc ProcParmTypes(s: Symb);	// forward

    proc PEndLine(node: Ast)
    {
	if feature.gflag then llvmdb.PLine(node@.lineno);
	out.nl(f);
    }
   
    proc PTypeName(t: Type)
    {   var s: Symb;

	out.str(f, "%");
	s = t@.name;
	if s != 0 then
	{   if s@.package != 0 then
	    {   out.str(f, s@.package@.ident);
		out.str(f, ".");
	    }
	    out.str(f, s@.ident);
	}
	else
	{   out.str(f, anon_prefix);
	    if t@.antag == 0 then
	    {   Aseqno += 1;
		t@.antag = Aseqno;
	    }
	    out.uint16(f, t@.antag);
	}
    }

    proc PType(t: Type, opt: typeoptions)
    {   var size: type.BitSize;
	if t != 0 then
	{   if t@.kind
	    is ENUM, UINT, SINT then
	    {
		if opt == PACK then
		    size = t@.size;
		else
		    size = target.isize(t@.size);
		out.str(f, "i"); out.uint(f, size);
	    }
	    is REF then
	    {   PType(t@.base, NONE);
		out.str(f, "*");
	    }
	    is RECORD then
	    {
		if t@.packed == BIT then
		{   // LLVM doesn't do bit pack records, handle as integers
//out.str(2, "PType packed record\n");
		    size = target.isize(t@.size);
		    out.str(f, "i"); out.uint(f, size);
		}
		else
		{   if t@.printed then
			PTypeName(t);
		}
	    }
	    is ARRAY then
	    {
		if t@.packed == BIT then
		{   // LLVM doesn't do bit pack arrays, handle as integers
//out.str(2, "PType packed array\n");
		    size = target.isize(t@.size);
		    out.str(f, "i"); out.uint(f, size);
		}
		else
		{   out.chr(f, '[');
		    out.uint32(f, _uint32(t@.hi));
		    out.str(f, " x ");
		    PType(t@.base, NONE);
		    out.chr(f, ']');
		}
	    }
	    is REFPROC then
	    {   PRetvType(t@.list@.retvlist, false);
		out.chr(f, ' ');
		PParmTypes(t@.list@.parmlist);
		out.chr(f, '*');
	    }
	}
    }

    proc PExtend(t: Type)
    {
	if t != 0 then
	{   if t@.kind
	    is ENUM, UINT, SINT then
	    {   var size: type.BitSize;
		size = target.isize(t@.size);
		if size < type.wordtype@.size then
		{
		    if t@.kind == SINT then
			out.str(f, " signext");
		    else
			out.str(f, " zeroext");
		}
	    }
	}
    }

    proc PRetvType(tl: type.TypeList, extend: boolean)
    {   var t: Type;

	if tl != 0 then
	{   if  tl@.next != 0 then		// has multiple returned values
	    {   out.str(f, " { ");
		loop
		{   PType(tl@.type, NONE);
		    tl = tl@.next;
		  exit tl == 0;
		    out.str(f, ", ");
		}
		out.str(f, " }");
	    }
	    else				// single returned value
	    {   t = tl@.type;
		if extend then PExtend(t);
		out.chr(f, ' ');
		PType(t, NONE);
	    }
	}
	else					// has no returned value
	    out.str(f, " void");
    }
    
    proc PParmTypes(s: Symb)
    {
	out.chr(f, '(');
	while s != 0 do
	{   PType(s@.type, NONE);
	    s = s@.next;
	  exit s == 0;
	    out.str(f, ", ");
	}
	out.chr(f, ')');
    }
 
    proc ConstantRef(t: Type, node: Ast)
    {   var v: type.Valu;

	v = node@.valu;
	if v == 0 then
	    out.str(f, "null");
	else
	{   out.str(f, "inttoptr(");
	    PType(type.wordtype, NONE);
	    out.chr(f, ' ');
	    out.uint64(f, v);
	    out.str(f, " to ");
	    if t == 0 then	// FIXME: CONST REFs inconsistent
	    {   PType(node@.type, NONE);
		out.chr(f, '*');
	    }
	    else
		PType(t, NONE);
	    out.chr(f, ')');
	}
    }
	
    proc NodeType(node: Ast)
    {
	if node@.kind
	is UTYPE then	      { out.str(f, "void"); }
	is REF then           { PType(node@.type, NONE); out.str(f, "*"); }
	is ARRAY, RECORD then { PType(node@.type, NONE); }
	is REFPROC then	      { PType(node@.type, NONE); }
	else                  { out.str(f, "i"); out.uint(f, node@.size); }
    }

    proc PPkgPfx(s: Symb)
    {   if s@.package != 0 then PPkgPfx(s@.package);    // recursive
	out.str(f, s@.ident); 
	out.chr(f, package_delimiter);
    }

    proc PName(s: Symb)
    {
	if s@.linkage
	is LOCAL then  { out.chr(f, '%'); out.str(f, s@.ident); }
	is NORMAL, INLINE then
	{   out.chr(f, '@');
	    if s@.package != 0 then
		PPkgPfx(s@.package);
	    out.str(f, s@.ident);
	}
	is GLOBAL, EXTERN then { out.chr(f, '@'); out.str(f, s@.ident); }
	is FIXED then
	{   out.str(f, "inttoptr(");
	    PType(type.wordtype, NONE);
	    out.chr(f, ' ');
	    out.uint64(f, s@.xaddr);
	    out.str(f, " to ");
	    if s@.kind == PROC then
	    {   PRetvType(s@.retvlist, true);
		PParmTypes(s@.parmlist);
	    }
	    else
		PType(s@.type, NONE);
	    out.str(f, "*)");
	}
    }

    proc PTempName(n: seqnoT)
    {
	out.chr(f, '%');
	out.uint(f, n-1);
    }

    proc NodeName(node: Ast)
    {   var s: Symb;

	s = node@.symb;
	if s != 0 then
	    PName(s);
	else
	    out.str(f, "__NoName__");
    }

    proc NodeDst(node: Ast)
    {
	if node@.op
	is CONST then lex.Error(ASSIGNCONST);
	is VAR, DCLVAR then NodeName(node);
	else PTempName(node@.seqno);
    }

    proc NodeSrc(node: Ast)
    {
	if node@.op
	is CONST then
	{   if node@.kind
	    is ENUM, UINT then out.uint64(f, node@.valu);
	    is SINT then       out.int64(f, _int64(node@.valu));
	    is REF, REFPROC then ConstantRef(0, node);
	    is ARRAY, RECORD then out.uint64(f, node@.valu);	// packed?
	}
	is VAR then NodeName(node);
	else        PTempName(node@.seqno);
    }

    proc Print(fmt: @[]Char, anode: Ast)
    {   var i: _uint;
	var c: Char;
	var n: ast.NSubNodes;
	var node: Ast;

	i = 0;
	loop
	{   c = fmt[i];
	  exit c == 0;
	    if c == '%' then
	    {   i += 1;  c = fmt[i];
		node = anode;
		if c
		is '0'..'9' then
		{   n = 0;
		    loop
		    {   n = (n * 10) + (c - '0');
			i += 1;  c = fmt[i];
		      exit c < '0' || c > '9';
		    }
		    node = anode@.child[n];
		}
		if c
		is 'B' then PType(node@.type, NONE);
		is 'A' then PType(node@.type@.base, NONE);
		is 'T' then NodeType(node);
		is 'I' then NodeName(node);
		is 'N' then NodeSrc(node);
		is 'D' then NodeDst(node);
		is 'W' then PType(type.wordtype, NONE);	// target word type
		is 'S' then // string name
		{   out.chr(f, '@');
		    out.str(f, scon_prefix);
		    out.uint32(f, _uint32(node@.valu));
		}
		is '%' then out.chr(f, c);
	    }
	    else
		out.chr(f, c);
	    i += 1;
	}
    }

    proc PRetValName(n: ast.NSubNodes)
    {
	out.str(f, "%rv.");
	out.uint(f, n);
    }

    proc DclType(t: Type)
    {   var s: Symb;
	var opt: typeoptions;
	var size: type.BitSize;

	opt = NONE;
	if t != 0 && !t@.printed then
	{   if t@.kind
	    is REF, ARRAY then DclType(t@.base);
	    is REFPROC then
	    {   // make sure formals are all recursively defined
		s = t@.list@.parmlist;
		while s != 0 do
		{   DclType(s@.type);
		    s = s@.next;
		}
	    }
	    is RECORD then
	    {   t@.printed = true;
		// make sure all types are recursively defined
		s = t@.list;
		while s != 0 do
		{   DclType(s@.type);
		    s = s@.next;
		}
		// now deal with the record
		PTypeName(t);
		out.str(f, " = type ");
		if t@.packed == BIT then
		{   // LLVM doesn't do bit pack records, handle as integers
		    size = target.isize(t@.size);
		    out.str(f, "i"); out.uint(f, size);
		}
		else
		{
		    if t@.packed == MEM then
		    {   out.str(f, "<");
			opt = PACK;
		    }
		    out.str(f, "{");
		    s = t@.list;
		    while s != 0 do
		    {   PType(s@.type, opt);
			s = s@.next;
		      exit s == 0;
			out.str(f, ", ");
		    }
		    out.str(f, "}");
		    if t@.packed == BIT then
			out.str(f, ">");
		}
		out.nl(f);
	    }
	}		
    }

    proc DclProc(node: Ast, isdefine: boolean)
    {   var s, ps: Symb;

	ps = node@.symb;
	if isdefine then out.str(f, "define"); else out.str(f, "declare");
	PRetvType(ps@.retvlist, true);
	Print(" %I(", node);
	s = ps@.parmlist;
	while s != 0 do
	{   PType(s@.type, NONE);
	    PExtend(s@.type);
	    if isdefine then
	    {   out.str(f, " %");
		out.str(f, s@.ident);
		out.str(f, ".arg");
	    }
	    s = s@.next;
	  exit s == 0;
	    out.str(f, ", ");
	}
	out.str(f, ")");
    }

    proc PString(s:@[]_byte, n:0..lex.StringMax, prefix: boolean)
    {   var i: 0..lex.StringMax;
	var c: Char;

	if prefix then out.chr(f, 'c');
	out.chr(f, '"');
	i = 0;
	while i < n do
	{   c = s[i];
	    if c < ' ' || c >= 0x7F || c == '"' || c == '\\' then
	    {   out.chr(f, '\\');
		out.hex8(f, c);
	    }
	    else
		out.chr(f, c);
	    i += 1;
	}
	out.chr(f, '"');
    }

    proc Constant(node: Ast, t: Type)
    {   var i: ast.NSubNodes;

	if t != 0 then
	{
	    if t@.kind
	    is ENUM, UINT then
	    {   if node != 0 then
		    out.uint64(f, node@.valu);
		else
		    out.uint(f, 0);
	    }
	    is SINT then
	    {   if node != 0 then
		    out.int64(f, _int64(node@.valu));
		else
		    out.uint(f, 0);
	    }
	    is REF then
	    {   if node == 0 || node@.valu == 0 then
		    out.str(f, "zeroinitializer");
		else
		    ConstantRef(t, node);
	    }
	    is RECORD then
	    {   if node != 0 then
		{   if t@.packed == BIT then	// assert node@.op == CONST
			out.uint64(f, _uint64(node@.valu));
		    else			// assert node@.op == CLIST
		    {   out.str(f, "{ ");
			i = 0;
			loop
			{   PType(node@.child[i]@.type, NONE);
			    out.str(f, " ");
			    Constant(node@.child[i], node@.child[i]@.type);
			    i += 1;
			  exit i >= node@.num;
			    out.str(f, ", ");
			}
			out.str(f, " }");
		    }
		}
		else
		    out.str(f, "zeroinitializer");
	    }
	    is ARRAY then
	    {   if node != 0 then
		{   if t@.packed == BIT then	// assert node@.op == CONST
			out.uint64(f, _uint64(node@.valu));
		    else if node@.op
		    is CLIST then
		    {   out.str(f, "[ ");
			i = 0;
			loop
			{   PType(node@.child[i]@.type, NONE);
			    out.str(f, " ");
			    Constant(node@.child[i], node@.child[i]@.type);
			    i += 1;
			  exit i >= node@.num;
			    out.str(f, ", ");
			}
			out.str(f, " ]");
		    }
		    is BYREF then
		    {   if node@.child[0]@.op == SCON then
			{   out.str(f, "* ");
			    if t@.flex then
				Print("bitcast( %T ", node@.child[0]);
			    Print("getelementptr( %T %S ) ", node@.child[0]);
			    if t@.flex then
				Print(" to %T )", node);
			}
		    }
		    is SCON then
		    {   var n: 0..lex.StringMax;
			if t@.flex then
			    n = node@.type@.hi;
			else
			    n = t@.hi;
			PString(pstring(node@.symb), n, true);
		    }
		}
		else
		    out.str(f, "zeroinitializer");
	    }
	    is REFPROC then
		out.str(f, "null");
	}
    }

    proc Alignment(t: Type)
    {   var n: type.BitSize;

	n = t@.align;
	if n >= Target.membits then
	{   out.str(f, ", align ");
	    out.uint(f, n / Target.membits);
	}
    }

    proc DclVar(node: Ast)
    {   var s: Symb;

	s = node@.symb;
	if s != 0 then
	{   DclType(s@.type);
	    if s@.linkage
	    is LOCAL then
	    {   Print("\t%I = alloca %B", node);
		if node@.child[0] != 0 then     // initialized local
		{   if node@.type@.kind <= REF then // scalar
		    {   out.nl(f);
			out.chr(f, '\t');   // FIXME: refactor with Store
			out.str(f, "store ");
			NodeType(node@.child[0]); out.chr(f, ' ');
			NodeSrc(node@.child[0]);  out.str(f, ", ");
			NodeType(node); out.chr(f, ' ');
			NodeDst(node);
		    }
		    else lex.ErrorS(NOTIMPL, "initialized local composites");
		}
	    }
	    is NORMAL then
	    {   Print("%I = internal global %B ", node);
		Constant(node@.child[0], node@.type);
		Alignment(s@.type);
	    }
	    is GLOBAL then
	    {   Print("%I = global %B ", node);
		Constant(node@.child[0], node@.type);
		Alignment(s@.type);
	    }
	    is EXTERN then
		Print("%I = external global %B", node);
	    out.nl(f);
	    if feature.gflag then llvmdb.DefVar(s);
	}
    }

    proc DclString(node: Ast)
    {   var n: 0..lex.StringMax;

	Print("%S = internal constant %B ", node);
	n = node@.type@.hi;
	PString(pstring(node@.symb), n, true);
    }

    // Look at nodes under a constant to see if there are any
    // string constants by reference.  If so, declare the string.
    proc ConstScan(node: Ast)
    {   var i: ast.NSubNodes;

	if node@.op == BYREF && node@.child[0].op == SCON then
	{
//out.str(2, "ConstScan: BYREF SCON\n");
	    DclString(node@.child[0]);
	    out.str(f, ";\n");
	}
	else
	{   i = 0;
	    while i < node@.num do
	    {   ConstScan(node@.child[i]);
		i += 1;
	    }
	}
    }

    proc DclCon(node: Ast)
    {   var s: Symb;

	s = node@.symb;
	if s != 0 then
	{   DclType(s@.type);
	    ConstScan(node);
	    if s@.linkage
	    is NORMAL then Print("%I = internal constant %B ", node);
	    is GLOBAL then Print("%I = constant %B ", node);
	    Constant(node@.child[0], node@.type);
	    Alignment(s@.type);
	}
	out.nl(f);
    }

    proc DclAggregate(node: Ast)
    {
	ConstScan(node);
	Print("%S = internal constant %B ", node);
	Constant(node, node@.type);
	// FIXME: Alignment(node@.type)?
    }

    proc Declare()
    {   var i: Intrinsics;

	i = MEMCPY;
	while i < END do
	{   if UseIntrinsic[i] then
		if i
		is MEMCPY then
		    if llvm_memop_bug then
			Print("declare void @llvm.memcpy.%W(i8*, i8*, %W, i32) nounwind\n", 0);
		    else
			Print("declare void @llvm.memcpy.%W([0 x i8]*, [0 x i8]*, %W, i32) nounwind\n", 0);
		is BSWAP2 then
		    Print("declare i16 @llvm.bswap.i16(i16)\n", 0);
		is BSWAP4 then
		    Print("declare i32 @llvm.bswap.i32(i32)\n", 0);
		is BSWAP8 then
		    Print("declare i64 @llvm.bswap.i64(i64)\n", 0);
		is MEMCMP1 then
		    Print("declare i1 @_builtin.memcmp.i8(i8*, i8*, %W)\n", 0);
		is MEMCMP2 then
		    Print("declare i1 @_builtin.memcmp.i16(i16*, i16*, %W)\n", 0);
		is MEMCMP4 then
		    Print("declare i1 @_builtin.memcmp.i32(i32*, i32*, %W)\n", 0);
		is MEMCMP8 then
		    Print("declare i1 @_builtin.memcmp.i64(i64*, i64*, %W)\n", 0);
	    i += 1;
	}
    }

    proc PLabel(n: seqnoT)
    {
	out.str(f, "L.");
	out.uint(f, n);
    }

    proc Label(n: seqnoT)
    {
	PLabel(n);
	out.str(f, ":\n");
	labthis = n;
    }

    proc RefLabel(n: seqnoT)
    {
	out.str(f, "label %");
	PLabel(n);
    }
	
    proc Branch(n: seqnoT)
    {
	out.str(f, "\tbr ");
	RefLabel(n);
	out.nl(f);
    }

    proc BranchConditional(node: Ast, ntrue: seqnoT, nfalse: seqnoT)
    {
	out.str(f, "\tbr i1 ");
	NodeSrc(node);
	out.str(f, ", ");
	RefLabel(ntrue);
	out.str(f, ", ");
	RefLabel(nfalse);
	out.nl(f);
    }

    proc If(node: Ast): boolean
    {   var labend, labtrue, labfalse: seqnoT;
	var term: boolean;

	GenSub(node@.child[0]);
	labend = Lseqno;  Lseqno += 1;
	labtrue = Lseqno;  Lseqno += 1;
	if node@.child[2] != 0 then
	{   labfalse = Lseqno;  Lseqno += 1;
	}
	else
	    labfalse = labend;
	BranchConditional(node@.child[0], labtrue, labfalse);
	Label(labtrue);
	term = GenSub(node@.child[1]);
	if !term then Branch(labend);
	if node@.child[2] != 0 then
	{   Label(labfalse);
	    term = GenSub(node@.child[2]);
	    if !term then Branch(labend);
	}
	Label(labend);
	return false;
    }

    proc Select(node: Ast): boolean
    {	var i, j: ast.NSubNodes;
	var isnode, selnode: Ast;
	var labend, labelse: seqnoT;
	var lo, hi: Valu;

	// LLVM wants selector to be register width
	node@.child[0] = expr.Extend(node@.child[0], type.wordtype@.size);
	GenSub(node@.child[0]);		// the selector value
	labelse = Lseqno;  Lseqno += 1;
	labend = Lseqno;  Lseqno += 1;
	Print("\tswitch %T %N, ", node@.child[0]);
	RefLabel(labelse);
	out.str(f, " [\n");
	// first pass through all the "is" nodes to generate labels
	i = 1;
	while i < node@.num -1 do
	{   isnode = node@.child[i];
	    if isnode@.op == IS then
	    {   isnode@.seqno = Lseqno;  Lseqno += 1;
		j = 0;
		while j < isnode@.num -1 do
		{   selnode = isnode@.child[j];
		    lo = 0; hi = 0;	// in case of internal error
		    if selnode@.op
		    is CONST then { lo = selnode@.valu; hi = lo; }
		    is CRANGE then
		    {   if selnode@.child[0]@.op == CONST &&
			   selnode@.child[1]@.op == CONST then
			{   lo = selnode@.child[0]@.valu;
			    hi = selnode@.child[1]@.valu;
			}
		    }
		    while lo <= hi do
		    {   Print("\t\t%0T ", node);
			out.uint32(f, _uint32(lo));
			out.str(f, ", ");
			RefLabel(isnode@.seqno);
			out.nl(f);
			lo += 1;
		    }
		    j += 1;
		}
	    }
	    i += 1;
	}
	out.str(f, "\t]\n");
	// second pass through all the "is" nodes to generate the code
	i = 1;
	while i < node@.num -1 do
	{   isnode = node@.child[i];
	    Label(isnode@.seqno);
	    if !GenSub(isnode@.child[isnode@.num-1]) then
		Branch(labend);
	    i += 1;
	}
	Label(labelse);
	// now the else node
	if !GenSub(node@.child[node@.num-1]) then
	    Branch(labend);
	Label(labend);
	return false;
    }

    proc Loop(node: Ast): boolean
    {   var loopcont, saveexit: seqnoT;

	saveexit = loopexit;
	loopcont = Lseqno;  Lseqno += 1;
	loopexit = Lseqno;  Lseqno += 1;
	Branch(loopcont);		// start a new basic block
	Label(loopcont);
	GenSub(node@.child[0]);
	Branch(loopcont);		// end of loop, continue
	Label(loopexit);		// loop exit
	loopexit = saveexit;
	return false;
    }

    proc Exit(node: Ast): boolean
    {   var labtrue, labfalse: seqnoT;
	var term: boolean;

	labfalse = Lseqno;  Lseqno += 1;
	GenSub(node@.child[0]);
	if (node@.child[1] != 0) then	// has "with" clause
	{   labtrue = Lseqno;  Lseqno += 1;
	    BranchConditional(node@.child[0], labtrue, labfalse);
	    Label(labtrue);		// exit with ...
	    term = GenSub(node@.child[1]);
	    if !term then
		Branch(loopexit);	// exit loop
	}
	else				// no "with" clause
	    BranchConditional(node@.child[0], loopexit, labfalse);
	Label(labfalse);		// come here if continuing
	return false;	
    }

    proc Conditional(node: Ast, isand: boolean): boolean
    {   var lablhs, labrhs, labend: seqnoT;

	labrhs = Lseqno;  Lseqno += 1;
	labend = Lseqno;  Lseqno += 1;
	GenSub(node@.child[0]);
	if isand then
	    BranchConditional(node@.child[0], labrhs, labend);
	else
	    BranchConditional(node@.child[0], labend, labrhs);
	lablhs = labthis;	// left hand side final basic block
	Label(labrhs);
	GenSub(node@.child[1]);
	labrhs = labthis;	// right hand side final basic block
	Branch(labend);
	Label(labend);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = phi i1 [ ", node);
	if isand then out.str(f, "false"); else out.str(f, "true");
	out.str(f, ", %");
	PLabel(lablhs);
	out.str(f, " ], [ ");
	PTempName(node@.child[1]@.seqno);
	out.str(f, ", %");
	PLabel(labrhs);
	out.str(f, " ]\n");
	return false;
    }

    proc Copy(node: Ast)
    {
	if llvm_memop_bug then
	{
	    node@.child[0] = expr.Cast(node@.child[0], pbytetype);
	    node@.child[1] = expr.Cast(node@.child[1], pbytetype);
	}
	GenSub(node@.child[0]);
	GenSub(node@.child[1]);
	// LLVM wants count to be register width
	node@.child[2] = expr.Extend(node@.child[2], type.wordtype@.size);
	GenSub(node@.child[2]);
	// FIXME: need to check for potential overlap and use memmove if necessary
	// FIXME: find alignment, here or during parsing?
	if llvm_memop_bug then
	   Print(
	   "\tcall void @llvm.memcpy.%2T(i8* %0N, i8* %1N, %2T %2N, i32 %3N)\n", node);
	else
	   Print(
	   "\tcall void @llvm.memcpy.%2T(%T %0N, %T %1N, %2T %2N, i32 %3N)\n", node);
	UseIntrinsic[MEMCPY] = true;
    }

    proc GetChunkSize(size: _uint, align: _uint): 0..target.IntSizesMax
    {   var is, ia: 0..target.IntSizesMax;

	ia = 0;
	if align > 0 then
	{
	    while ia < Target.nisize-1 &&
		  align > Target.isizes[ia].align/Target.membits do
		ia += 1;
	}
	is = ia;
	if size > 0 then
	{   is = 0;
	    while is < Target.nisize-1 &&
		  size > Target.isizes[is].size/Target.membits do
		is += 1;
	}
	if ia < is then is = ia;
	return is;
    }

    // This horrible mess would be straighforward if only LLVM would support
    // an instrinsic llvm.memcmp().
    proc ArrayCompare(node: Ast): boolean
    {   var length, align, size: _uint;
	var i: 0..target.IntSizesMax;

	length = 0;	// 0 means variable
	if node@.child[2]@.op == CONST then
	    length = _uint(node@.child[2]@.valu);
	align = node@.child[3]@.valu;
out.str(2, "Array compare experimental: length=");
	if length == 0 then
out.str(2, "variable");
	else
out.uint(2, length);
	// find the largest target chunk we can use
	i = GetChunkSize(length, align);
	size = Target.isizes[i].size/Target.membits;
	align = Target.isizes[i].align/Target.membits;
out.str(2, " size="); out.uint(2, size);
out.str(2, " align="); out.uint(2, align);
	if length != 0 && length <= size then	// can do with one load
	{
	    node@.child[0] = expr.Cast(node@.child[0], puinttype[i]);
	    node@.child[0]@.size = puinttype[i]@.base@.width;
	    node@.child[0] = ast.New1(LOAD, puinttype[i]@.base, node@.child[0]);
	    node@.child[0]@.kind = puinttype[i]@.base@.kind;
	    node@.child[1] = expr.Cast(node@.child[1], puinttype[i]);
	    node@.child[1]@.size = puinttype[i]@.base@.width;
	    node@.child[1] = ast.New1(LOAD, puinttype[i]@.base, node@.child[1]);
	    node@.child[1]@.kind = puinttype[i]@.base@.kind;
	    if length < size then
	    {   var mask: _uint64;
		// Assert size <= 64;
		if Target.order == BE then
		    mask = ~((1 << ((size-length)*8)) -1);
		else	// assume LE
		    mask = (1 << (length*8)) - 1;
out.str(2, " mask=0x"); out.hex64(2, mask);
		node@.child[0] = ast.New2(XOR, puinttype[i]@.base,
					  node@.child[0], node.child[1]);
		node@.child[0] = ast.New2(AND, puinttype[i]@.base,
					  node@.child[0],
					  ast.Const(puinttype[i]@.base, mask));
		node@.child[1] = ast.Const(puinttype[i]@.base, 0);
	    }
	    GenSub(node@.child[0]);
	    GenSub(node@.child[1]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    node@.kind = ENUM;
	    node@.size = 1;
	    if node@.op == AEQ then
		Print("\t%N = icmp eq %0T %0N, %1N\n", node);
	    else
		Print("\t%N = icmp ne %0T %0N, %1N\n", node);
out.nl(2);
	    return true;
	}
	else
	{
	    node@.child[0] = expr.Cast(node@.child[0], puinttype[i]);
	    node@.child[0]@.size = puinttype[i]@.base@.width;
	    node@.child[1] = expr.Cast(node@.child[1], puinttype[i]);
	    node@.child[1]@.size = puinttype[i]@.base@.width;
	    GenSub(node@.child[0]);
	    GenSub(node@.child[1]);
	    if size > 1 then
		node@.child[2] = ast.New2(DIV, type.wordtype,
				 node@.child[2],
				 ast.Const(type.wordtype, size));
	    // LLVM wants count to be register width
	    node@.child[2] = expr.Extend(node@.child[2], type.wordtype@.size);
	    GenSub(node@.child[2]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    node@.kind = ENUM;
	    node@.size = 1;
	    Print("\t%N = call i1 @_builtin.memcmp.", node);
	    PType(puinttype[i]@.base, NONE);
	    Print("(%0T %0N, %1T %1N, %2T %2N)\n", node);
	    UseIntrinsic[MEMCMP1+i] = true;
	}
out.nl(2);
	return false;
    }

    proc Swap(node: Ast)
    {
	GenSub(node@.child[0]);
	if node@.size
	is 16 then  UseIntrinsic[BSWAP2] = true;
	is 32 then  UseIntrinsic[BSWAP4] = true;
	is 64 then  UseIntrinsic[BSWAP8] = true;
	else
	{   node@.seqno = node@.child[0]@.seqno;
	    return;
	}
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = call %T @llvm.bswap.%T(%T %0N)\n", node);
    }

    proc PStringCon(node: Ast)
    {   var p: pstring;
	var n: 0..lex.StringMax;
    
	if node == 0 then
	    out.str(f, "\"\"");
	else
	{   p = pstring(node@.symb);
	    n = zstr.len(p, lex.StringMax);
	    PString(p, n, false);
	}
    }
	    
    proc GetRV(node: Ast)
    {   var tl: type.TypeList;
	var ps: Symb;

	if node@.valu == 0 then
	    GenSub(node@.child[0]);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = extractvalue ", node);
	ps = node@.child[0]@.symb;
	if ps != 0 then
	    tl = ps@.retvlist;
	else
	    tl = type.TypeList(node@.child[0]@.type);	// hack
	PRetvType(tl, false);
	Print(" %0N, ", node);
	out.uint32(f, _uint32(node@.valu));
	out.nl(f);
    }

    // FIXME: re-factor to merge stuff with Call()
    proc Asm(node: Ast)
    {	var i: ast.NSubNodes;

	i = 2;
	while i < node@.num do
	{   GenSub(node@.child[i]);
	    i += 1;
	}
	out.chr(f, '\t');
	if node@.type != 0 then		// has return value
	{   node@.seqno = Tseqno;  Tseqno += 1;
	    Print("%N = ", node);
	}
	out.str(f, "call");
	PRetvType(type.TypeList(node@.type), false);
	out.str(f, " asm sideeffect ");
	PStringCon(node@.child[0]);
	out.str(f, ", ");
	PStringCon(node@.child[1]);
	out.str(f, " (");
	i = 2;
	if node@.num > i then
	{   loop
	    {
		Print("%T %N", node@.child[i]);
		i += 1;
	      exit i >= node@.num;
		out.str(f, ", ");
	    }
	}
	out.str(f, ")\n");
    }

    // Declare parameter types and return value types
    proc DclParmRetv(ps: Symb)
    {   var tl: type.TypeList;
        var s: Symb;

	s = ps@.parmlist;
	while s != 0 do
	{   DclType(s@.type);
	    s = s@.next;
	}
	tl = ps@.retvlist;
	while tl != 0 do
	{   DclType(tl@.type);
	    tl = tl@.next;
	}
    }

    proc Call(node: Ast, indirect:boolean)
    {	var i: ast.NSubNodes;

	i = 0;
	while i < node@.num do
	{   GenSub(node@.child[i]);
	    i += 1;
	}
	out.chr(f, '\t');
	if node@.type != 0 then		// has return value
	{   node@.seqno = Tseqno;  Tseqno += 1;
	    Print("%N = ", node);
	}
	if feature.test then out.str(f, "tail ");
	out.str(f, "call");
	PRetvType(node@.symb@.retvlist, false);
	if indirect then
	{   Print(" %0N(", node);
	    i = 1;	// actuals start here
	}
	else
	{   Print(" %I(", node);
	    i = 0;	// all children are actuals
	}
	if node@.num > i then
	{   loop
	    {
		Print("%T %N", node@.child[i]);
		i += 1;
	      exit i >= node@.num;
		out.str(f, ", ");
	    }
	}
	out.str(f, ")\n");
	if node@.symb@.forward then
	    lex.ErrorI(FORWPROC, node@.symb@.ident);
    }

    // Search AST of a procedure for
    // 1. DCLVAR so types can be pre-declared
    // 2. DCLCON so they can be moved outside the procedure
    // 3. CALL of external so parameter and retv types can be pre-declared
    // FIXME: might as well catch SCON and CLIST since we search the whole tree
    proc DclProcSearch(node: Ast)
    {   var i: ast.NSubNodes;

	if node != 0 then
	{   if node@.op
	    is DCLVAR then
	    {   DclType(node@.type);
		return;
	    }
	    is DCLCON then
	    {   var s: Symb;
out.str(2, "DCLCON in proc\n");
		s = node@.symb;
		if s != 0 then
		{
		    s@.linkage = NORMAL;	// promote linkage
		    DclCon(node);
		}
		node@.op = NULL;		// ignore for code generation
		return;
	    }
	    is SCON then
{
//out.str(2, "SCON in proc\n");
		DclString(node);
		return;
}
	    is CLIST then
{
//out.str(2, "CLIST in proc\n");
		DclAggregate(node);
}
	    is CALL then
	    {   var ps: Symb;
		ps = node@.symb;
		if ps@.linkage == EXTERN && !ps@.declared then
		{   DclParmRetv(ps);
		    DclProc(node, false);
		    out.str(f, ";\n");
		    ps@.declared = true;
		}
	    }
	    is ASM then return;     // ignore SCONs under an ASM
	    i = 0;
	    while i < node@.num do
	    {   DclProcSearch(node@.child[i]);
		i += 1;
	    }
	}
    }

    proc Procedure(node: Ast)
    {   var s, ps: Symb;
	var tl: type.TypeList;
	var i: ast.NSubNodes;

	ps = node@.symb;
	if ps != 0 then
	{   DclParmRetv(ps);    // declare parameter and retv types
	    // Make sure any local variables have type declared
	    // and DCLCONs are moved outside
	    DclProcSearch(node@.child[0]);
	    // Now declare the procedure with its parameters
	    DclProc(node, true);
	    if ps@.linkage == INLINE then
		out.str(f, " alwaysinline");
	    if feature.size then
		out.str(f, " optsize");
	    out.str(f, " nounwind {\n");
	    Pseqno += 1;
	    Tseqno = 1;
	    Lseqno = 0;
	    Label(Lseqno);  Lseqno += 1;
	    // allocate returned values
	    tl = ps@.retvlist;
	    i = 0;
	    while tl != 0 do
	    {   out.chr(f, '\t');
		PRetValName(i);
		out.str(f, " = alloca ");
		PType(tl@.type, NONE);
		out.nl(f);
		i += 1;
		tl = tl@.next;
	    }
	    // allocate parameters
	    s = ps@.parmlist;
	    while s != 0 do
	    {   out.str(f, "\t%"); out.str(f, s@.ident);
		out.str(f, " = alloca ");
		PType(s@.type, NONE);
		out.nl(f);
		s = s@.next;
	    }
	    s = ps@.parmlist;
	    while s != 0 do
	    {
		out.str(f, "\tstore ");
		PType(s@.type, NONE);
		out.str(f, " %");
		out.str(f, s@.ident);
		out.str(f, ".arg, ");
		PType(s@.type, NONE);
		out.str(f, "* %");
		out.str(f, s@.ident);
		out.nl(f);
		if feature.gflag then llvmdb.DefVar(s);
		s = s@.next;
	    }
	    if !GenSub(node@.child[0]) then
	    {   out.str(f, "\tbr label %return");
		PEndLine(node);
	    }
	    out.str(f, "return:\n");
	    tl = ps@.retvlist;
	    if tl != 0 then
	    {   // load up returned values
		i = 0;
		while tl != 0 do
		{   out.chr(f, '\t');
		    PTempName(Tseqno+i);
		    out.str(f, " = load ");
		    PType(tl@.type, NONE);
		    out.str(f, "* ");
		    PRetValName(i);
//		    PEndLine(node);	//FIXME: wrong line number
		    out.nl(f);
		    i += 1;
		    tl = tl@.next;
		}
		tl = ps@.retvlist;
		i = 0;
		out.str(f, "\tret ");
		loop
		{   PType(tl@.type, NONE);
		    out.chr(f, ' ');
		    PTempName(Tseqno+i);
		    i += 1;
		    tl = tl@.next;
		  exit tl == 0;
		    out.str(f, ", ");
		}
	    }
	    else
		out.str(f, "\tret void");
	    out.str(f, "\n}\n");
	}
    }

    proc BinaryOp(node: Ast, op: @[]Char): boolean
    {

	GenSub(node@.child[0]);
	GenSub(node@.child[1]);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = ", node);
	out.str(f, op);
	Print(" %T %0N, %1N", node);
	PEndLine(node);
	return false;
    }

    proc CompareOp(node: Ast, op: @[]Char): boolean
    {

	GenSub(node@.child[0]);
	GenSub(node@.child[1]);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = ", node);
	out.str(f, op);
	Print(" %0T %0N, %1N", node);
	PEndLine(node);
	return true;
    }

    proc ChangeSize(node: Ast, op: @[]Char)
    {
	GenSub(node@.child[0]);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = ", node);
	out.str(f, op);
	Print(" %0T %0N to %T", node);
	PEndLine(node);
    }

    proc BitfieldOffset(trec: Type, fno: type.Valu): type.BitSize
    {   var foffs, rsize, fsize: type.BitSize;
	var s: Symb;
	var i: ast.NSubNodes;

	// assert trec@.kind == RECORD
	rsize = trec@.width;
	if trec@.bitorder == MSB then foffs = rsize; else foffs = 0;
	s = trec@.list;
	i = 0;
	while s != 0 do
	{   fsize = s@.type@.size;
	    if trec@.bitorder == MSB then foffs -= fsize;
	  exit i == fno;
	    if trec@.bitorder != MSB then foffs += fsize;
	    s = s@.next;
	    i += 1;
	}
//out.str(2, "BitfieldOffset="); out.uint(2, foffs); out.nl(2);
	return foffs;
    }

    proc BitfieldIndex(node: Ast, size: type.BitSize, tree: Ast): Ast
    {   var indx: Ast;

	// FIXME: what about bitorder?
	indx = expr.Extend(node@.child[1], type.wordtype@.size);
	indx = ast.New2(MUL, type.wordtype, indx,
                        ast.Const(type.wordtype, size));
	if tree != 0 then
	    tree = ast.New2(ADD, type.wordtype, tree, indx);
	else
	    tree = indx;
	return tree;
    }

    proc BitfieldRewrite(offs: Ast): Ast, Ast, Ast
    {   var varb, tree: Ast;
	var shft: type.BitSize;

	shft = 0;
	varb = 0;
	loop
	{   if offs@.op
	    is OFFSET then
		shft += BitfieldOffset(offs@.child[0]@.type, offs@.valu);
	    is INDEX then
		varb = BitfieldIndex(offs, offs@.type@.size, varb);
	    is SLICE then
		varb = BitfieldIndex(offs, offs@.type@.base@.size, varb);
	    offs = offs@.child[0];
	  exit (offs@.op < OFFSET || offs@.op > SLICE) ||
	    offs@.child[0]@.type@.packed != BIT;
	}
	if shft != 0 then
	{   tree = ast.Const(type.wordtype, shft);
	    if varb != 0 then
		varb = ast.New2(ADD, type.wordtype, varb, tree);
	    else
		varb = tree;
	}
	// load the container of the bitfield
	tree = ast.New1(LOAD, offs@.type, offs);
	tree@.kind = UINT;
	tree@.size = offs@.type@.width;
	// make sure the endian is correct
	if tree@.size > Target.membits && 
	   tree@.type@.memorder != Target.order then
	    tree = ast.New1(REVB, tree@.type, tree);
	// make register sized, this simplifies things
	tree = expr.Extend(tree, type.wordtype@.size);
	return tree,    // return the loaded container,
	       varb,    // the shift computation,
	       offs;    // and the base address 
    }

    proc BitfieldMask(node: Ast): Ast
    {   var mask: Ast;
	var bits: type.Valu;
	var size: type.BitSize;

	if node@.op == SLICE then
	{   if node@.child[2]@.op != CONST then
	    {
out.str(2, "BitfieldMask of variable SLICE\n");
	    }
	    else
	    {   size = node@.type@.base@.size;
		size = size * type.BitSize(node@.child[2]@.valu);
	    }
	}
	else
	    size = node@.type.size;
	bits = (1<<size)-1;
	mask = ast.Const(type.wordtype, bits);
	return mask;
    }
	
    proc Load(load: Ast)
    {   var offs, tree, varb, mask: Ast;
	var size: type.BitSize;
	var t: Type;

	// LLVM doesn't handle bitfields (packed records or arrays)
	// so we expand bitfield extract
	offs = load@.child[0];
	if (offs@.op >= OFFSET && offs@.op <= SLICE) &&
	    offs@.child[0]@.type@.packed == BIT then
	{   // We are dealing with a packed record or array (aka bitfield).
	    t = offs@.type;		// final type
	    size = t@.size;		// final bit size
	    mask = BitfieldMask(offs);
	    // Rewrite the AST to extract item.
	    tree, varb, offs = BitfieldRewrite(offs);
	    // shift item rightward, if necessary
	    if varb != 0 then
		tree = ast.New2(LSR, t, tree, varb);
	    // mask off the parts we don't want
	    tree = ast.New2(AND, t, tree, mask);
	    // possibly narrow the size
	    tree = expr.Extend(tree, load@.size);
//out.str(2, "BFLoad tree=\n"); ast.Dump(tree); out.nl(2);
	    GenSub(tree);
	    load@.child[0] = tree;      // load@.op == LOAD, we're done with it
	    load@.seqno = tree@.seqno;  // copy up seqno of node below
	}
	else	// normal load
	{   GenSub(offs);
	    load@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = ", load);
	    if offs@.type@.input then
		out.str(f, "volatile ");
	    Print("load %T* %0N", load);
	    PEndLine(load);
	}
    }

    proc Store(store: Ast)
    {   var rhs, lhs, varb, tree, mask: Ast;
	var size: type.BitSize;
	var t: Type;
	var i, n: ast.NSubNodes;

	i = 0;
	n = store@.num / 2;
	while i < n do
	{   lhs = store@.child[i];
	    rhs = store@.child[n+i];
	    // LLVM doesn't handle bitfields (packed records or arrays)
	    // so we expand bitfield insert
	    if (lhs@.op >= OFFSET && lhs@.op <= SLICE) &&
		lhs@.child[0]@.type@.packed == BIT then
	    {   // We are dealing with a packed record or array (aka bitfield).
		t = lhs@.type;			// final type
		size = t@.size;			// final bit size
		mask = BitfieldMask(lhs);
		// Rewrite the AST to extract item.
		tree, varb, lhs = BitfieldRewrite(lhs);
		// shift the mask leftward, if necessary
		if varb != 0 then
		    mask = ast.New2(LSL, type.wordtype, mask, varb);
		mask = ast.New1(NOT, type.wordtype, mask);
		// mask out the field in the target
		tree = ast.New2(AND, type.wordtype, tree, mask);
		// make the value word size
		rhs = expr.Extend(rhs, type.wordtype@.size);
		// shift the value leftward, if necessary
		if varb != 0 then
		    rhs  = ast.New2(LSL, type.wordtype, rhs, varb);
		// or in the new value
		rhs  = ast.New2(OR, type.wordtype, tree, rhs);
		// adjust width of final result
		rhs = expr.Extend(rhs, lhs@.size);
		// make sure the endian is correct
		if lhs@.size > Target.membits && 
		   lhs@.type@.memorder != Target.order then
		    rhs = ast.New1(REVB, rhs@.type, rhs);
		store@.child[i] = lhs;
		store@.child[n+i] = rhs;
//out.str(2, "BFStore tree=\n"); ast.Dump(store); out.nl(2);
	    }
	    GenSub(rhs);	// rhs first
	    i += 1;
	}
	i = 0;
	while i < n do
	{   lhs = store@.child[i];
	    rhs = store@.child[n+i];
	    if lhs != 0 then
	    {   GenSub(lhs);	// then lhs
		out.chr(f, '\t');
		if store@.child[i]@.type@.output then
		   out.str(f, "volatile ");
		out.str(f, "store ");
		NodeType(rhs); out.chr(f, ' ');
		NodeSrc(rhs);  out.str(f, ", ");
		NodeType(lhs); out.chr(f, ' ');
		NodeDst(lhs);
		PEndLine(store);
	    }
	    i += 1;
	}
    }

    proc Return(node: Ast): boolean
    {   var i: ast.NSubNodes;
	var rnode: Ast;

	if node@.num > 0 then
	{   i = 0;
	    while i < node@.num do
	    {   rnode = node@.child[i];
		GenSub(rnode);
		Print("\tstore %T %N, %T* ", rnode);
		PRetValName(i);
		PEndLine(node);
		i += 1;
	    }
	    node@.seqno = node@.child[0]@.seqno;
	}
	out.str(f, "\tbr label %return");
	PEndLine(node);
	return true;	// always terminates a block
    }

    proc IfExpr(node: Ast)
    {
	GenSub(node@.child[1]);
	GenSub(node@.child[2]);
	GenSub(node@.child[0]);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = select i1 %0N, %1T %1N, %2T %2N", node);
	PEndLine(node);
    }
	
    proc GenSub(node: Ast): boolean
    {   var term: boolean;	// basic block has been terminated

	term = false;
	if node == 0 then return term;
	if node@.seqno != 0 then return term;
//{   out.str(2, "node "); out.uint(2, node@.seqno);
//    out.str(2, " visited before, ignoring.\n");
//    return term;
//}
	if node@.op
	is NOP then { GenSub(node@.child[0]); node@.seqno = node@.child[0]@.seqno; }
	is FILE then
	{   if feature.gflag then llvmdb.FileStart(node@.symb@);
	    GenSub(node@.child[0]);
	    if feature.gflag then llvmdb.FileFinish(node@.symb@);
	}
	is PACKAGE then
	{   if feature.gflag then llvmdb.PackageStart(node@.symb@.ident);
	    GenSub(node@.child[0]);
	    if feature.gflag then llvmdb.PackageEnd();
	}
	is PROC then
	{   if feature.gflag then llvmdb.ProcStart(node@.symb@);
	    Procedure(node);
	    if feature.gflag then llvmdb.ProcFinish(node@.symb@);
	}
	is DCLVAR then DclVar(node);
	is DCLCON then DclCon(node);
	is VAR, CONST then {}
	is SCON, CLIST then
	{
	    node@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = getelementptr %T %S\n", node);
	}
	is ACOPY then Copy(node);
	is AEQ, ANE then term = ArrayCompare(node);
	is COPY then Copy(node);
	is RET then term = Return(node);
	is GETRV then GetRV(node);
	is STORE then Store(node);
	is LOAD  then Load(node);
	is BYREF then
	{   GenSub(node@.child[0]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = getelementptr %T %0N\n", node);
	}
	is OFFSET then
	{   GenSub(node@.child[0]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = getelementptr %0T %0N, %W 0, i32 ", node);
	    out.uint32(f, _uint32(node@.valu));
	    out.nl(f);
	}
	is INDEX then
	{   GenSub(node@.child[0]);
	    // LLVM wants index value to be register width
	    node@.child[1] = expr.Extend(node@.child[1], type.wordtype@.size);
	    GenSub(node@.child[1]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = getelementptr %0T %0N, %W 0, %1T %1N\n", node);
	}
	is SLICE then
	{   var nextseqno: seqnoT;
	    // Treat this like an index followed by cast back to original type
	    // Ignore the count, for now
	    GenSub(node@.child[0]);
	    // LLVM wants index value to be register width
	    node@.child[1] = expr.Extend(node@.child[1], type.wordtype@.size);
	    GenSub(node@.child[1]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    nextseqno = Tseqno; Tseqno += 1;
	    Print("\t%N = getelementptr %0T %0N, %W 0, %1T %1N\n", node);
	    out.chr(f, '\t'); PTempName(nextseqno);
	    Print(" = bitcast %A* %N to %T\n", node);
	    node@.seqno = nextseqno;
	}	
	is CAST then
	{   GenSub(node@.child[0]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    if node@.kind == REF then
	    {   if node@.child[0]@.kind == REF then
		    Print("\t%N = bitcast %0T %0N to %T\n", node);
		else
		    Print("\t%N = inttoptr %0T %0N to %T\n", node);
	    }
	    else
	    {   if node@.child[0]@.kind == REF then
		    Print("\t%N = ptrtoint %0T %0N to %T\n", node);
		else
		    Print("\t%N = bitcast %0T %0N to %T\n", node);
	    }
	}	
	is ZEXT then  ChangeSize(node, "zext");
	is SEXT then  ChangeSize(node, "sext");
	is TRUNC then ChangeSize(node, "trunc");
	is REVB then  Swap(node);
	is NOT then
	{   GenSub(node@.child[0]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = xor %0T %0N, -1\n", node);
	}
	is NEG then
	{   GenSub(node@.child[0]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = sub %0T 0, %0N\n", node);
	}
	is ADD then BinaryOp(node, "add");
	is SUB then BinaryOp(node, "sub");
	is MUL then BinaryOp(node, "mul");
	is DIV then BinaryOp(node, "udiv");	// FIXME: signed version
	is MOD then BinaryOp(node, "urem");	// FIXME: signed version
	is LSL, ASL then BinaryOp(node, "shl");
	is LSR then BinaryOp(node, "lshr");
	is ASR then BinaryOp(node, "ashr");
	is EQ then  term = CompareOp(node, "icmp eq");
	is NE then  term = CompareOp(node, "icmp ne");
	is UGT then term = CompareOp(node, "icmp ugt");
	is ULT then term = CompareOp(node, "icmp ult");
	is UGE then term = CompareOp(node, "icmp uge");
	is ULE then term = CompareOp(node, "icmp ule");
	is SGT then term = CompareOp(node, "icmp sgt");
	is SLT then term = CompareOp(node, "icmp slt");
	is SGE then term = CompareOp(node, "icmp sge");
	is SLE then term = CompareOp(node, "icmp sle");
	is AND then BinaryOp(node, "and");
	is OR then  BinaryOp(node, "or");
	is XOR then BinaryOp(node, "xor");
	is BNOT then
	{   GenSub(node@.child[0]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = xor i1 %0N, true\n", node);
	}
	is BOR then  term = Conditional(node, false);
	is BAND then term = Conditional(node, true);
	is IFEXPR then IfExpr(node);
	is CALL then  Call(node, false);
	is CALLI then Call(node, true);
	is ASM then Asm(node);
	is IF then   term = If(node);
	is SEL then  term = Select(node);
	is LOOP then term = Loop(node);
	is EXIT then term = Exit(node);
	is SEQ then
	{   var i: ast.NSubNodes;
	    i = 0;
	    while i < node@.num do
	    {   if term then
		{   // a block ends in a sequence, unreachable code
		    Label(Lseqno);  Lseqno += 1;
		    term = false;
		}
		term = GenSub(node@.child[i]);
		i += 1;
	    }
	}
	return term;
    }

    proc Gen(fd: file, tree: Ast)
    {   var i: 0..target.IntSizesMax;

	f = fd;
	// These pointer types might be useful to other packages.
	pbytetype = type.New(REF);
	pbytetype.base = type.bytetype;
	puinttype[0] = type.New(REF);
	puinttype[0].base = type.uinttypes[0];
	puinttype[1] = type.New(REF);
	puinttype[1].base = type.uinttypes[1];
	puinttype[2] = type.New(REF);
	puinttype[2].base = type.uinttypes[2];
	puinttype[3] = type.New(REF);
	puinttype[3].base = type.uinttypes[3];

	out.str(f, "target datalayout = \"");
	if Target.order == BE then out.str(f, "E"); else out.str(f, "e");
	out.str(f, "-p:");  out.uint(f, Target.ptr.size);
	out.str(f, ":");    out.uint(f, Target.ptr.align);
	out.str(f, ":");    out.uint(f, Target.ptr.align);
	out.str(f, "-i1:"); out.uint(f, Target.isizes[0].align);
	out.str(f, ":");   out.uint(f, Target.isizes[0].align);
	i = 0;
	while i < Target.nisize do
	{   out.str(f, "-i"); out.uint(f, Target.isizes[i].size);
	    out.str(f, ":");  out.uint(f, Target.isizes[i].align);
	    out.str(f, ":");  out.uint(f, Target.isizes[i].align);
	    i += 1;
	}
	out.str(f, "\"\ntarget triple = \"");
	out.str(f, Target.triple);
	out.str(f, "\"\n");
	GenSub(tree);
	Declare();
	if feature.gflag then llvmdb.ProgFinish();
    }
}
// vim: ts=8 sw=4 noet nowrap

