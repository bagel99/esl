// Copyright (c) 2009-2011, Brian G. Lucas.  See LICENSE file.
// $Id: llvm.esl 630 2011-10-03 17:35:21Z bgl $

// Convert AST to LLVM assembly
import bout;
package llvm
{
    alias lex.StringRange as StringRange;
    const package_delimiter:Char = '_';
    const anon_prefix: []Char = "A.";
    const scon_prefix: []Char = "S.";
    type file: sys.fildes;
    var  f: bout.pBufIO;
    proc PType(t: Type);					// forward
    proc PName(s: Symb);					// forward
    proc PRetvType(tl: type.TypeList, extend: boolean);		// forward
    proc PParmTypes(s: Symb);					// forward
}

import llvmdb;

package llvm
{
    type pstring: @[]_byte;
    // These pointer types might be useful to other packages.
    var pbytetype: Type;
    var puinttype: [4]Type;
    type seqnoT: 0..0xFFFF;
    var Tseqno: seqnoT;
    var Pseqno: seqnoT = 0;
    var Lseqno: seqnoT = 0;
    var Aseqno: _uint16 = 0;
    var labthis: seqnoT;	// label sequence number of this basic block
    var loopexit: seqnoT;	// label sequence number for this loop exit
    type Intrinsics:
    (   MEMCPY, MEMMOVE, BSWAP2, BSWAP4, BSWAP8,
	MEMCMP1, MEMCMP2, MEMCMP4, MEMCMP8,	// must be in order
	END
    );
    var UseIntrinsic: [Intrinsics]boolean;

    proc GenSub(node: Ast): boolean;	// forward
    proc ProcParmTypes(s: Symb);	// forward

    proc PEndLine(node: Ast)
    {
	if feature.gflag then llvmdb.PLine(node@.lineno);
	f.nl();
    }
   
    proc PTypeName(t: Type)
    {   var s: Symb;

	f.str("%");
	s = t@.name;
	if s != 0 then
	{   if s@.package != 0 then
	    {   f.str(s@.package@.ident);
		f.str(".");
	    }
	    f.str(s@.ident);
	}
	else
	{   f.str(anon_prefix);
	    if t@.antag == 0 then
	    {   Aseqno += 1;
		t@.antag = Aseqno;
	    }
	    f.uint16(t@.antag);
	}
    }

    proc PType(t: Type)
    {   var size: type.BitSize;
	if t != 0 then
	{   if t@.kind
	    is ENUM, UINT, SINT then
	    {   size = target.isize(t@.size);
		f.str("i"); f.uint(size);
	    }
	    is REF then
	    {   PType(t@.base);
		f.str("*");
	    }
	    is RECORD then
	    {
		if t@.packed == BIT then
		{   // LLVM doesn't do bit pack records, handle as integers
//f.str("PType packed record\n");
		    size = target.isize(t@.size);
		    f.str("i"); f.uint(size);
		}
		else
		{   if t@.printed then
			PTypeName(t);
		}
	    }
	    is ARRAY then
	    {
		if t@.packed == BIT then
		{   // LLVM doesn't do bit pack arrays, handle as integers
//f.str("PType packed array\n");
		    size = target.isize(t@.size);
		    f.str("i"); f.uint(size);
		}
		else
		{   f.chr('[');
		    f.uint32(_uint32(t@.hi));
		    f.str(" x ");
		    PType(t@.base);
		    f.chr(']');
		}
	    }
	    is REFPROC then
	    {   PRetvType(t@.list@.retvlist, false);
		f.chr(' ');
		PParmTypes(t@.list@.parmlist);
		f.chr('*');
	    }
	}
    }

    proc PExtend(t: Type)
    {
	if t != 0 then
	{   if t@.kind
	    is ENUM, UINT, SINT then
	    {   var size: type.BitSize;
		size = target.isize(t@.size);
		if size < type.wordtype@.size then
		{
		    if t@.kind == SINT then
			f.str(" signext");
		    else
			f.str(" zeroext");
		}
	    }
	}
    }

    proc PRetvType(tl: type.TypeList, extend: boolean)
    {   var t: Type;

	if tl != 0 then
	{   if  tl@.next != 0 then		// has multiple returned values
	    {   f.str(" { ");
		loop
		{   PType(tl@.type);
		    tl = tl@.next;
		  exit tl == 0;
		    f.str(", ");
		}
		f.str(" }");
	    }
	    else				// single returned value
	    {   t = tl@.type;
		if extend then PExtend(t);
		f.chr(' ');
		PType(t);
	    }
	}
	else					// has no returned value
	    f.str(" void");
    }
    
    proc PParmTypes(s: Symb)
    {
	f.chr('(');
	while s != 0 do
	{   PType(s@.type);
	    s = s@.next;
	  exit s == 0;
	    f.str(", ");
	}
	f.chr(')');
    }
 
    proc ConstantRef(t: Type, node: Ast)
    {   var v: type.Valu;

	v = node@.valu;
	if v == 0 then
	    f.str("null");
	else
	{   f.str("inttoptr(");
	    PType(type.wordtype);
	    f.chr(' ');
	    f.uint64(v);
	    f.str(" to ");
	    if t == 0 then	// FIXME: CONST REFs inconsistent
	    {   PType(node@.type);
		f.chr('*');
	    }
	    else
		PType(t);
	    f.chr(')');
	}
    }
	
    proc NodeType(node: Ast)
    {
	if node@.kind
	is UTYPE then	      { f.str("void"); }
	is REF then           { PType(node@.type); f.str("*"); }
	is ARRAY, RECORD, REFPROC then { PType(node@.type); }
	else                  { f.str("i"); f.uint(node@.size); }
    }

    proc PPkgPfx(s: Symb)
    {   if s@.package != 0 then PPkgPfx(s@.package);    // recursive
	f.str(s@.ident); 
	f.chr(package_delimiter);
    }

    proc PName(s: Symb)
    {
	if s@.linkage
	is LOCAL then  { f.chr('%'); f.str(s@.ident); }
	is NORMAL, INLINE then
	{   f.chr('@');
	    if s@.kind == PROC && s@.bound then
	    {   var bs: Symb;
		var bt: Type;
		bt = s@.parmlist@.type;
		if bt@.kind == REF then bt = bt@.base;
		bs = bt@.name;
		if bs@.package != 0 then
		    PPkgPfx(bs@.package);
		f.str(bs@.ident);
		f.chr(package_delimiter);
	    }
	    else
	    {   if s@.package != 0 then
		    PPkgPfx(s@.package);
	    }
	    f.str(s@.ident);
	}
	is GLOBAL, EXTERN then { f.chr('@'); f.str(s@.ident); }
	is FIXED then
	{   f.str("inttoptr(");
	    PType(type.wordtype);
	    f.chr(' ');
	    f.uint64(s@.xaddr);
	    f.str(" to ");
	    if s@.kind == PROC then
	    {   PRetvType(s@.retvlist, true);
		PParmTypes(s@.parmlist);
	    }
	    else
		PType(s@.type);
	    f.str("*)");
	}
    }

    proc PTempName(n: seqnoT)
    {
	f.chr('%');
	f.uint(n-1);
    }

    proc NodeName(node: Ast)
    {   var s: Symb;

	s = node@.symb;
	if s != 0 then
	    PName(s);
	else
	    f.str("__NoName__");
    }

    proc NodeDst(node: Ast)
    {
	if node@.op
	is CONST then lex.ErrorS(COMPILER, "Assignment to constant");
	is VAR, DCLVAR then NodeName(node);
	else PTempName(node@.seqno);
    }

    proc NodeSrc(node: Ast)
    {
	if node@.op
	is CONST then
	{   if node@.kind
	    is ENUM, UINT then f.uint64(node@.valu);
	    is SINT then       f.int64(_int64(node@.valu));
	    is REF, REFPROC then ConstantRef(0, node);
	    is ARRAY, RECORD then f.uint64(node@.valu);	    // packed?
	}
	is VAR then NodeName(node);
	else        PTempName(node@.seqno);
    }

    proc Print(fmt: @[]Char, anode: Ast)
    {   var i: _uint;
	var c: Char;
	var n: ast.NSubNodes;
	var node: Ast;

	i = 0;
	loop
	{   c = fmt[i];
	  exit c == 0;
	    if c == '%' then
	    {   i += 1;  c = fmt[i];
		node = anode;
		if c
		is '0'..'9' then
		{   n = 0;
		    loop
		    {   n = (n * 10) + (c - '0');
			i += 1;  c = fmt[i];
		      exit c < '0' || c > '9';
		    }
		    node = anode@.child[n];
		}
		if c
		is 'B' then PType(node@.type);
		is 'A' then PType(node@.type@.base);
		is 'T' then NodeType(node);
		is 'I' then NodeName(node);
		is 'N' then NodeSrc(node);
		is 'D' then NodeDst(node);
		is 'W' then PType(type.wordtype);	// target word type
		is 'S' then // string name
		{   f.chr('@');
		    f.str(scon_prefix);
		    f.uint32(_uint32(node@.valu));
		}
		is '%' then f.chr(c);
	    }
	    else
		f.chr(c);
	    i += 1;
	}
    }

    proc PRetValName(n: ast.NSubNodes)
    {
	f.str("%rv.");
	f.uint(n);
    }

    proc DclType(t: Type)
    {   var s: Symb;
	var size: type.BitSize;

	if t != 0 && !t@.printed then
	{   if t@.kind
	    is REF, ARRAY then DclType(t@.base);
	    is REFPROC then
	    {   // make sure formals are all recursively defined
		s = t@.list@.parmlist;
		while s != 0 do
		{   DclType(s@.type);
		    s = s@.next;
		}
	    }
	    is RECORD then
	    {   t@.printed = true;
		// make sure all types are recursively defined
		s = t@.list;
		while s != 0 do
		{   DclType(s@.type);
		    s = s@.next;
		}
		// now deal with the record
		PTypeName(t);
		f.str(" = type ");
		if t@.packed == BIT then
		{   // LLVM doesn't do bit pack records, handle as integers
		    size = target.isize(t@.size);
		    f.str("i"); f.uint(size);
		}
		else
		{   if t@.packed == MEM then
			f.str("<");
		    f.str("{");
		    s = t@.list;
		    while s != 0 do
		    {   PType(s@.type);
			s = s@.next;
		      exit s == 0;
			f.str(", ");
		    }
		    f.str("}");
		    if t@.packed == MEM then
			f.str(">");
		}
		f.nl();
	    }
	}		
    }

    proc DclProc(node: Ast, isdefine: boolean)
    {   var s, ps: Symb;

	ps = node@.symb;
	if isdefine then f.str("define"); else f.str("declare");
	if ps@.linkage
	is NORMAL then f.str(" internal");
	is EXTERN then f.str(" external");
	PRetvType(ps@.retvlist, true);
	Print(" %I(", node);
	s = ps@.parmlist;
	while s != 0 do
	{   PType(s@.type);
	    PExtend(s@.type);
	    if isdefine then
	    {   f.str(" %");
		f.str(s@.ident);
		f.str(".arg");
	    }
	    s = s@.next;
	  exit s == 0;
	    f.str(", ");
	}
	f.str(")");
    }

    proc PString(s:@[]_byte, n:0..lex.StringMax, prefix: boolean)
    {   var i: 0..lex.StringMax;
	var c: Char;

	if prefix then f.chr('c');
	f.chr('"');
	i = 0;
	while i < n do
	{   c = s[i];
	    if c < ' ' || c >= 0x7F || c == '"' || c == '\\' then
	    {   f.chr('\\');
		f.hex8(c);
	    }
	    else
		f.chr(c);
	    i += 1;
	}
	f.chr('"');
    }

    proc Constant(node: Ast, t: Type)
    {   var i: ast.NSubNodes;

	if t != 0 then
	{
	    if t@.kind
	    is ENUM, UINT then
	    {   if node != 0 then
		    f.uint64(node@.valu);
		else
		    f.uint(0);
	    }
	    is SINT then
	    {   if node != 0 then
		    f.int64(_int64(node@.valu));
		else
		    f.uint(0);
	    }
	    is REF then
	    {   if node == 0 || node@.valu == 0 then
		    f.str("zeroinitializer");
		else
		    ConstantRef(t, node);
	    }
	    is RECORD then
	    {   if node != 0 then
		{   if t@.packed == BIT then	// assert node@.op == CONST
			f.uint64(_uint64(node@.valu));
		    else			// assert node@.op == CLIST
		    {   f.str("{ ");
			i = 0;
			loop
			{   PType(node@.child[i]@.type);
			    f.str(" ");
			    Constant(node@.child[i], node@.child[i]@.type);
			    i += 1;
			  exit i >= node@.num;
			    f.str(", ");
			}
			f.str(" }");
		    }
		}
		else
		    f.str("zeroinitializer");
	    }
	    is ARRAY then
	    {   if node != 0 then
		{   if t@.packed == BIT then	// assert node@.op == CONST
			f.uint64(_uint64(node@.valu));
		    else if node@.op
		    is CLIST then
		    {   f.str("[ ");
			i = 0;
			loop
			{   PType(node@.child[i]@.type);
			    f.str(" ");
			    Constant(node@.child[i], node@.child[i]@.type);
			    i += 1;
			  exit i >= node@.num;
			    f.str(", ");
			}
			f.str(" ]");
		    }
		    is BYREF then
		    {   f.str("* ");
			if node@.child[0]@.op
			is SCON then
			{   if t@.flex then
				Print("bitcast( %T ", node@.child[0]);
			    Print("getelementptr( %T %S ) ", node@.child[0]);
			    if t@.flex then
				Print(" to %T )", node);
			}
			is VAR then
			{   if t@.flex then
				Print("bitcast( %T ", node@.child[0]);
			    Print("getelementptr( %T %N ) ", node@.child[0]);
			    if t@.flex then
				Print(" to %T )", node);
			}
			is CONST then
			    ConstantRef(t, node@.child[0]);
		    }
		    is SCON then
		    {   var n: StringRange;
			if t@.flex then
			    n = StringRange(node@.type@.hi);
			else
			    n = StringRange(t@.hi);
			PString(pstring(node@.symb), n, true);
		    }
		}
		else
		    f.str("zeroinitializer");
	    }
	    is REFPROC then
		f.str("null");
	}
    }

    proc Alignment(t: Type)
    {   var n: type.BitSize;

	n = t@.align;
	if n >= Target.membits then
	{   f.str(", align ");
	    f.uint(n / Target.membits);
	}
    }

    proc DclVar(node: Ast)
    {   var s: Symb;

	s = node@.symb;
	if s != 0 then
	{   DclType(s@.type);
	    if s@.linkage
	    is LOCAL then
	    {   Print("\t%I = alloca %B", node);
		if node@.child[0] != 0 then     // initialized local
		{   if node@.type@.kind <= REF then // scalar
		    {   f.nl();
			f.chr('\t');   // FIXME: refactor with Store
			f.str("store ");
			NodeType(node@.child[0]); f.chr(' ');
			NodeSrc(node@.child[0]);  f.str(", ");
			NodeType(node); f.chr(' ');
			NodeDst(node);
		    }
		    else lex.ErrorS(NOTIMPL, "initialized local composites");
		}
	    }
	    is NORMAL then
	    {   Print("%I = internal global %B ", node);
		Constant(node@.child[0], node@.type);
		Alignment(s@.type);
	    }
	    is GLOBAL then
	    {   Print("%I = global %B ", node);
		Constant(node@.child[0], node@.type);
		Alignment(s@.type);
	    }
	    is EXTERN then
		Print("%I = external global %B", node);
	    f.nl();
	    if feature.gflag then llvmdb.DefVar(s);
	}
    }

    proc DclString(node: Ast)
    {   var n: StringRange;

	Print("%S = internal constant %B ", node);
	n = StringRange(node@.type@.hi);
	PString(pstring(node@.symb), n, true);
	f.nl();
    }

    // Look at nodes under a constant to see if there are any
    // string constants by reference.  If so, declare the string.
    proc ConstScan(node: Ast)
    {   var i: ast.NSubNodes;

	if node@.op == BYREF && node@.child[0].op == SCON then
	{
//f.str("ConstScan: BYREF SCON\n");
	    DclString(node@.child[0]);
	    f.str(";\n");
	}
	else
	{   i = 0;
	    while i < node@.num do
	    {   ConstScan(node@.child[i]);
		i += 1;
	    }
	}
    }

    proc DclCon(node: Ast)
    {   var s: Symb;

	s = node@.symb;
	if s != 0 then
	{   DclType(s@.type);
	    ConstScan(node);
	    if s@.linkage
	    is NORMAL then Print("%I = internal constant %B ", node);
	    is GLOBAL then Print("%I = constant %B ", node);
	    Constant(node@.child[0], node@.type);
	    Alignment(s@.type);
	}
	f.nl();
    }

    proc DclAggregate(node: Ast)
    {
	ConstScan(node);
	Print("%S = internal constant %B ", node);
	Constant(node, node@.type);
	// FIXME: Alignment(node@.type)?
    }

    proc Declare()
    {   var i: Intrinsics;

	i = MEMCPY;
	while i < END do
	{   if UseIntrinsic[i] then
		if i
		is MEMCPY then
		    Print("declare void @llvm.memcpy.p0i8.p0i8.%W(i8*, i8*, %W, i32, i1) nounwind\n", 0);
		is BSWAP2 then
		    Print("declare i16 @llvm.bswap.i16(i16)\n", 0);
		is BSWAP4 then
		    Print("declare i32 @llvm.bswap.i32(i32)\n", 0);
		is BSWAP8 then
		    Print("declare i64 @llvm.bswap.i64(i64)\n", 0);
		is MEMCMP1 then
		    Print("declare i1 @memcmp1(i8*, i8*, %W)\n", 0);
		is MEMCMP2 then
		    Print("declare i1 @memcmp2(i16*, i16*, %W)\n", 0);
		is MEMCMP4 then
		    Print("declare i1 @memcmp4(i32*, i32*, %W)\n", 0);
		is MEMCMP8 then
		    Print("declare i1 @memcmp8(i64*, i64*, %W)\n", 0);
	    i += 1;
	}
    }

    proc PLabel(n: seqnoT)
    {
	f.str("L.");
	f.uint(n);
    }

    proc Label(n: seqnoT)
    {
	PLabel(n);
	f.str(":\n");
	labthis = n;
    }

    proc RefLabel(n: seqnoT)
    {
	f.str("label %");
	PLabel(n);
    }
	
    proc Branch(n: seqnoT)
    {
	f.str("\tbr ");
	RefLabel(n);
	f.nl();
    }

    proc BranchConditional(node: Ast, ntrue: seqnoT, nfalse: seqnoT)
    {
	f.str("\tbr i1 ");
	NodeSrc(node);
	f.str(", ");
	RefLabel(ntrue);
	f.str(", ");
	RefLabel(nfalse);
	f.nl();
    }

    proc If(node: Ast): boolean
    {   var labend, labtrue, labfalse: seqnoT;
	var term: boolean;

	GenSub(node@.child[0]);
	labend = Lseqno;  Lseqno += 1;
	labtrue = Lseqno;  Lseqno += 1;
	if node@.child[2] != 0 then
	{   labfalse = Lseqno;  Lseqno += 1;
	}
	else
	    labfalse = labend;
	BranchConditional(node@.child[0], labtrue, labfalse);
	Label(labtrue);
	term = GenSub(node@.child[1]);
	if !term then Branch(labend);
	if node@.child[2] != 0 then
	{   Label(labfalse);
	    term = GenSub(node@.child[2]);
	    if !term then Branch(labend);
	}
	Label(labend);
	return false;
    }

    proc Select(node: Ast): boolean
    {	var i, j: ast.NSubNodes;
	var isnode, selnode: Ast;
	var labend, labelse: seqnoT;
	var lo, hi: Valu;

	// LLVM wants selector to be register width
	node@.child[0] = expr.ExtendT(node@.child[0], type.wordtype);
	GenSub(node@.child[0]);		// the selector value
	labelse = Lseqno;  Lseqno += 1;
	labend = Lseqno;  Lseqno += 1;
	Print("\tswitch %T %N, ", node@.child[0]);
	RefLabel(labelse);
	f.str(" [\n");
	// first pass through all the "is" nodes to generate labels
	i = 1;
	while i < node@.num -1 do
	{   isnode = node@.child[i];
	    if isnode@.op == IS then
	    {   isnode@.seqno = Lseqno;  Lseqno += 1;
		j = 0;
		while j < isnode@.num -1 do
		{   selnode = isnode@.child[j];
		    lo = 0; hi = 0;	// in case of internal error
		    if selnode@.op
		    is CONST then { lo = selnode@.valu; hi = lo; }
		    is CRANGE then
		    {   if selnode@.child[0]@.op == CONST &&
			   selnode@.child[1]@.op == CONST then
			{   lo = selnode@.child[0]@.valu;
			    hi = selnode@.child[1]@.valu;
			}
		    }
		    while lo <= hi do
		    {   Print("\t\t%0T ", node);
			f.uint32(_uint32(lo));
			f.str(", ");
			RefLabel(isnode@.seqno);
			f.nl();
			lo += 1;
		    }
		    j += 1;
		}
	    }
	    i += 1;
	}
	f.str("\t]\n");
	// second pass through all the "is" nodes to generate the code
	i = 1;
	while i < node@.num -1 do
	{   isnode = node@.child[i];
	    Label(isnode@.seqno);
	    if !GenSub(isnode@.child[isnode@.num-1]) then
		Branch(labend);
	    i += 1;
	}
	Label(labelse);
	// now the else node
	if !GenSub(node@.child[node@.num-1]) then
	    Branch(labend);
	Label(labend);
	return false;
    }

    proc Loop(node: Ast): boolean
    {   var loopcont, saveexit: seqnoT;

	saveexit = loopexit;
	loopcont = Lseqno;  Lseqno += 1;
	loopexit = Lseqno;  Lseqno += 1;
	Branch(loopcont);		// start a new basic block
	Label(loopcont);
	GenSub(node@.child[0]);
	Branch(loopcont);		// end of loop, continue
	Label(loopexit);		// loop exit
	loopexit = saveexit;
	return false;
    }

    proc Exit(node: Ast): boolean
    {   var labtrue, labfalse: seqnoT;
	var term: boolean;

	labfalse = Lseqno;  Lseqno += 1;
	GenSub(node@.child[0]);
	if (node@.child[1] != 0) then	// has "with" clause
	{   labtrue = Lseqno;  Lseqno += 1;
	    BranchConditional(node@.child[0], labtrue, labfalse);
	    Label(labtrue);		// exit with ...
	    term = GenSub(node@.child[1]);
	    if !term then
		Branch(loopexit);	// exit loop
	}
	else				// no "with" clause
	    BranchConditional(node@.child[0], loopexit, labfalse);
	Label(labfalse);		// come here if continuing
	return false;	
    }

    proc Conditional(node: Ast, isand: boolean): boolean
    {   var lablhs, labrhs, labend: seqnoT;

	labrhs = Lseqno;  Lseqno += 1;
	labend = Lseqno;  Lseqno += 1;
	GenSub(node@.child[0]);
	if isand then
	    BranchConditional(node@.child[0], labrhs, labend);
	else
	    BranchConditional(node@.child[0], labend, labrhs);
	lablhs = labthis;	// left hand side final basic block
	Label(labrhs);
	GenSub(node@.child[1]);
	labrhs = labthis;	// right hand side final basic block
	Branch(labend);
	Label(labend);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = phi i1 [ ", node);
	if isand then f.str("false"); else f.str("true");
	f.str(", %");
	PLabel(lablhs);
	f.str(" ], [ ");
	PTempName(node@.child[1]@.seqno);
	f.str(", %");
	PLabel(labrhs);
	f.str(" ]\n");
	return false;
    }

    proc Copy(node: Ast)
    {
	// LLVM wants i8* types
	node@.child[0] = expr.Cast(node@.child[0], pbytetype);
	node@.child[1] = expr.Cast(node@.child[1], pbytetype);
	GenSub(node@.child[0]);
	GenSub(node@.child[1]);
	// LLVM wants count to be register width
	node@.child[2] = expr.ExtendT(node@.child[2], type.wordtype);
	GenSub(node@.child[2]);
	// FIXME: need to check for potential overlap and use memmove if necessary
	// FIXME: find alignment, here or during parsing?
	Print(
	   "\tcall void @llvm.memcpy.p0i8.p0i8.%2T(i8* %0N, i8* %1N, %2T %2N, i32 %3N, i1 0)\n", node);
	UseIntrinsic[MEMCPY] = true;
    }

    proc GetChunkSize(size: _uint, align: _uint): 0..target.IntSizesMax
    {   var is, ia: 0..target.IntSizesMax;

	ia = 0;
	if align > 0 then
	{
	    while ia < Target.nisize-1 &&
		  align > Target.isizes[ia].align/Target.membits do
		ia += 1;
	}
	is = ia;
	if size > 0 then
	{   is = 0;
	    while is < Target.nisize-1 &&
		  size > Target.isizes[is].size/Target.membits do
		is += 1;
	}
	if ia < is then is = ia;
	return is;
    }

    // This horrible mess would be straighforward if only LLVM would support
    // an instrinsic llvm.memcmp().
    proc ArrayCompare(node: Ast): boolean
    {   var length, align, size: _uint;
	var i: 0..target.IntSizesMax;

	length = 0;	// 0 means variable
	if node@.child[2]@.op == CONST then
	    length = _uint(node@.child[2]@.valu) *
		(node@.child[0]@.type@.base@.width/Target.membits);
	align = _uint(node@.child[3]@.valu);
	// find the largest target chunk we can use
	i = GetChunkSize(length, align);
	size = Target.isizes[i].size/Target.membits;
	align = Target.isizes[i].align/Target.membits;
if debug.tests then { err.str("Array compare: length=");
if length == 0 then err.str("variable"); else err.uint(length);
err.str(" size="); err.uint(size);
err.str(" align="); err.uint(align);}
	if length != 0 && length <= size then	// can do with one load
	{
	    node@.child[0] = expr.Cast(node@.child[0], puinttype[i]);
	    node@.child[0]@.size = puinttype[i]@.base@.width;
	    node@.child[0] = ast.New1(LOAD, puinttype[i]@.base, node@.child[0]);
	    node@.child[0]@.kind = puinttype[i]@.base@.kind;
	    node@.child[1] = expr.Cast(node@.child[1], puinttype[i]);
	    node@.child[1]@.size = puinttype[i]@.base@.width;
	    node@.child[1] = ast.New1(LOAD, puinttype[i]@.base, node@.child[1]);
	    node@.child[1]@.kind = puinttype[i]@.base@.kind;
	    if length < size then
	    {   var mask: _uint64;
		// Assert size <= 64;
		if Target.order == BE then
		    mask = ~((1 << ((size-length)*8)) -1);
		else	// assume LE
		    mask = (1 << (length*8)) - 1;
if debug.tests then { err.str(" mask=0x"); err.hex64(mask);}
		node@.child[0] = ast.New2(XOR, puinttype[i]@.base,
					  node@.child[0], node.child[1]);
		node@.child[0] = ast.New2(AND, puinttype[i]@.base,
					  node@.child[0],
					  ast.Const(puinttype[i]@.base, mask));
		node@.child[1] = ast.Const(puinttype[i]@.base, 0);
	    }
	    GenSub(node@.child[0]);
	    GenSub(node@.child[1]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    node@.kind = ENUM;
	    node@.size = 1;
	    if node@.op == AEQ then
		Print("\t%N = icmp eq %0T %0N, %1N\n", node);
	    else
		Print("\t%N = icmp ne %0T %0N, %1N\n", node);
if debug.tests then { err.nl();}
	    return true;
	}
	else
	{
	    node@.child[0] = expr.Cast(node@.child[0], puinttype[i]);
	    node@.child[0]@.size = puinttype[i]@.base@.width;
	    node@.child[1] = expr.Cast(node@.child[1], puinttype[i]);
	    node@.child[1]@.size = puinttype[i]@.base@.width;
	    GenSub(node@.child[0]);
	    GenSub(node@.child[1]);
	    if size > 1 then
		node@.child[2] = ast.New2(DIV, type.wordtype,
				 node@.child[2],
				 ast.Const(type.wordtype, size));
	    // LLVM wants count to be register width
	    node@.child[2] = expr.ExtendT(node@.child[2], type.wordtype);
	    GenSub(node@.child[2]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    node@.kind = ENUM;
	    node@.size = 1;
	    Print("\t%N = call i1 @memcmp", node);
	    f.uint(puinttype[i]@.base@.width/Target.membits);
	    Print("(%0T %0N, %1T %1N, %2T %2N)\n", node);
	    UseIntrinsic[MEMCMP1+i] = true;
	    if node@.op == ANE then     // ugly invert in place
	    {   node@.child[0].seqno = node@.seqno;
		node@.seqno = Tseqno;  Tseqno += 1;
		Print("\t%N = xor i1 %0N, true\n", node);
	    }
	}
if debug.tests then { err.nl();}
	return false;
    }

    proc Swap(node: Ast)
    {
	GenSub(node@.child[0]);
	if node@.size
	is 16 then  UseIntrinsic[BSWAP2] = true;
	is 32 then  UseIntrinsic[BSWAP4] = true;
	is 64 then  UseIntrinsic[BSWAP8] = true;
	else
	{   node@.seqno = node@.child[0]@.seqno;
	    return;
	}
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = call %T @llvm.bswap.%T(%T %0N)\n", node);
    }

    proc PStringCon(node: Ast)
    {   var p: pstring;
	var n: StringRange;
    
	if node == 0 then
	    f.str("\"\"");
	else
	{   p = pstring(node@.symb);
	    n = StringRange(zstr.len(p, lex.StringMax));
	    PString(p, n, false);
	}
    }
	    
    proc GetRV(node: Ast)
    {   var tl: type.TypeList;
	var ps: Symb;

	if node@.valu == 0 then
	    GenSub(node@.child[0]);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = extractvalue ", node);
	ps = node@.child[0]@.symb;
	if ps != 0 then
	    tl = ps@.retvlist;
	else
	    tl = type.TypeList(node@.child[0]@.type);	// hack
	PRetvType(tl, false);
	Print(" %0N, ", node);
	f.uint32(_uint32(node@.valu));
	f.nl();
    }

    // FIXME: re-factor to merge stuff with Call()
    proc Asm(node: Ast)
    {	var i: ast.NSubNodes;

	i = 2;
	while i < node@.num do
	{   GenSub(node@.child[i]);
	    i += 1;
	}
	f.chr('\t');
	if node@.type != 0 then		// has return value
	{   node@.seqno = Tseqno;  Tseqno += 1;
	    Print("%N = ", node);
	}
	f.str("call");
	PRetvType(type.TypeList(node@.type), false);
	f.str(" asm sideeffect ");
	PStringCon(node@.child[0]);
	f.str(", ");
	PStringCon(node@.child[1]);
	f.str(" (");
	i = 2;
	if node@.num > i then
	{   loop
	    {
		Print("%T %N", node@.child[i]);
		i += 1;
	      exit i >= node@.num;
		f.str(", ");
	    }
	}
	f.str(")\n");
    }

    // Declare parameter types and return value types
    proc DclParmRetv(ps: Symb)
    {   var tl: type.TypeList;
        var s: Symb;

	s = ps@.parmlist;
	while s != 0 do
	{   DclType(s@.type);
	    s = s@.next;
	}
	tl = ps@.retvlist;
	while tl != 0 do
	{   DclType(tl@.type);
	    tl = tl@.next;
	}
    }

    proc Call(node: Ast, indirect:boolean)
    {	var i: ast.NSubNodes;

	i = 0;
	while i < node@.num do
	{   GenSub(node@.child[i]);
	    i += 1;
	}
	f.chr('\t');
	if node@.type != 0 then		// has return value
	{   node@.seqno = Tseqno;  Tseqno += 1;
	    Print("%N = ", node);
	}
	if feature.tcall then f.str("tail ");
	f.str("call");
	PRetvType(node@.symb@.retvlist, false);
	if indirect then
	{   Print(" %0N(", node);
	    i = 1;	// actuals start here
	}
	else
	{   Print(" %I(", node);
	    i = 0;	// all children are actuals
	}
	if node@.num > i then
	{   loop
	    {
		Print("%T %N", node@.child[i]);
		i += 1;
	      exit i >= node@.num;
		f.str(", ");
	    }
	}
	f.str(")\n");
	if node@.symb@.forward then
	    lex.ErrorI(FORWPROC, node@.symb@.ident);
    }

    // Search AST of a procedure for
    // 1. DCLVAR so types can be pre-declared and externs/globals declared
    // 2. DCLCON so they can be declared
    // 3. SCON,CLIST so they can be declared
    // 4. CALL of external so parm and retv types can be pre-declared
    // 5. Operators that must be expanded because of lack of LLVM support.
    proc DclProcSearch(node: Ast)
    {   var i: ast.NSubNodes;
	var lhs, rhs: Ast;
	var s: Symb;
	var op: ast.Op;

	if node != 0 then
	{   if node@.op
	    is DCLVAR then
	    {   s = node@.symb;
	        DclType(s@.type);
		if s@.linkage != LOCAL then
		{   DclVar(node);
		    node@.op = NULL;
		}
		return;
	    }
	    is DCLCON then
	    {   s = node@.symb;
		if s != 0 then
		{   s@.linkage = NORMAL;	// promote linkage
		    DclCon(node);
		}
		node@.op = NULL;		// ignore for code generation
		return;
	    }
	    is SCON then
	    {   DclString(node);
		return;
	    }
	    is CLIST then
	    {   DclAggregate(node);
	    }
	    is CALL then
	    {   var ps: Symb;
		ps = node@.symb;
		if ps@.linkage == EXTERN && !ps@.declared then
		{   DclParmRetv(ps);
		    DclProc(node, false);
		    f.str(";\n");
		    ps@.declared = true;
		}
	    }
//
	    is ABS then			    // must convert
	    {   rhs = node@.child[0];
		lhs = ast.New1(NEG, rhs@.type, rhs);
		node@.child[0] = ast.New2(SLT, type.booltype, rhs,
				ast.Const(rhs@.type, 0));
		node = ast.Child(node, lhs);    // must return same node
		node = ast.Child(node, rhs);    // must return same node
		node@.op = IFEXPR;
	    }
	    is UMIN, UMAX, SMIN, SMAX then  // must convert
	    {   lhs = node@.child[0];
		rhs = node@.child[1];
		if node@.op
		is SMIN then op = SLT;
		is SMAX then op = SGT;
		is UMIN then op = ULT;
		is UMAX then op = UGT;
		node@.child[0] = ast.New2(op, type.booltype, lhs, rhs);
		node@.child[1] = lhs;
		node = ast.Child(node, rhs);    // must return same node
		node@.op = IFEXPR;
	    }
//
	    is ASM then return;     // ignore SCONs under an ASM
	    i = 0;
	    while i < node@.num do
	    {   DclProcSearch(node@.child[i]);
		i += 1;
	    }
	}
    }

    proc Procedure(node: Ast)
    {   var s, ps: Symb;
	var tl: type.TypeList;
	var i: ast.NSubNodes;

	ps = node@.symb;
	if ps != 0 then
	{   DclParmRetv(ps);    // declare parameter and retv types
	    // Make sure any local variables have type declared
	    // and DCLCONs are moved outside
	    DclProcSearch(node@.child[0]);
	    // Now declare the procedure with its parameters
	    DclProc(node, true);
	    if ps@.linkage == INLINE then
		f.str(" alwaysinline");
	    if feature.size then
		f.str(" optsize");
	    f.str(" nounwind {\n");
	    Pseqno += 1;
	    Tseqno = 1;
	    Lseqno = 0;
	    Label(Lseqno);  Lseqno += 1;
	    // allocate returned values
	    tl = ps@.retvlist;
	    i = 0;
	    while tl != 0 do
	    {   f.chr('\t');
		PRetValName(i);
		f.str(" = alloca ");
		PType(tl@.type);
		f.nl();
		i += 1;
		tl = tl@.next;
	    }
	    // allocate parameters
	    s = ps@.parmlist;
	    while s != 0 do
	    {   f.str("\t%"); f.str(s@.ident);
		f.str(" = alloca ");
		PType(s@.type);
		f.nl();
		s = s@.next;
	    }
	    s = ps@.parmlist;
	    while s != 0 do
	    {
		f.str("\tstore ");
		PType(s@.type);
		f.str(" %");
		f.str(s@.ident);
		f.str(".arg, ");
		PType(s@.type);
		f.str("* %");
		f.str(s@.ident);
		f.nl();
		if feature.gflag then llvmdb.DefVar(s);
		s = s@.next;
	    }
	    if !GenSub(node@.child[0]) then
	    {   f.str("\tbr label %return");
		PEndLine(node);
	    }
	    f.str("return:\n");
	    tl = ps@.retvlist;
	    if tl != 0 then
	    {   // load up returned values
		i = 0;
		while tl != 0 do
		{   f.chr('\t');
		    PTempName(Tseqno+i);
		    f.str(" = load ");
		    PType(tl@.type);
		    f.str("* ");
		    PRetValName(i);
//		    PEndLine(node);	//FIXME: wrong line number
		    f.nl();
		    i += 1;
		    tl = tl@.next;
		}
		tl = ps@.retvlist;
		i = 0;
		if tl@.next != 0 then   // multiple returned values
		{   // first, must insert each value into aggregate
		    loop
		    {   f.str("\t%mrv"); f.uint(i);
			f.str(" = insertvalue");
			PRetvType(ps@.retvlist, false);
			if i == 0 then
			    f.str(" undef");
			else
			{   f.str(" %mrv"); f.uint(i-1);
			}
			f.chr(',');
			PType(tl@.type);
			f.chr(' ');
			PTempName(Tseqno+i);
			f.chr(',');
			f.uint(i);
			f.nl();
			i += 1;
			tl = tl@.next;
		      exit tl == 0;
		    }
		    // finally return the aggregate
		    f.str("\tret ");
		    PRetvType(ps@.retvlist, false);
		    f.str(" %mrv"); f.uint(i-1);
		    f.nl();
		}
		else		    // only one returned value
		{   f.str("\tret ");
		    PType(tl@.type);
		    f.chr(' ');
		    PTempName(Tseqno+i);
		}
	    }
	    else
		f.str("\tret void");
	    f.str("\n}\n");
	}
    }

    proc BinaryOp(node: Ast, op: @[]Char): boolean
    {

	GenSub(node@.child[0]);
	GenSub(node@.child[1]);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = ", node);
	f.str(op);
	Print(" %T %0N, %1N", node);
	PEndLine(node);
	return false;
    }

    proc CompareOp(node: Ast, op: @[]Char): boolean
    {

	GenSub(node@.child[0]);
	GenSub(node@.child[1]);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = ", node);
	f.str(op);
	Print(" %0T %0N, %1N", node);
	PEndLine(node);
	return true;
    }

    proc ChangeSize(node: Ast, op: @[]Char)
    {
	GenSub(node@.child[0]);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = ", node);
	f.str(op);
	Print(" %0T %0N to %T", node);
	PEndLine(node);
    }

    proc BitfieldOffset(trec: Type, fno: type.Valu): type.BitSize
    {   var foffs, rsize, fsize: type.BitSize;
	var s: Symb;
	var i: ast.NSubNodes;

	// assert trec@.kind == RECORD
	rsize = trec@.width;
	if trec@.bitorder == MSB then foffs = rsize; else foffs = 0;
	s = trec@.list;
	i = 0;
	while s != 0 do
	{   fsize = s@.type@.size;
	    if trec@.bitorder == MSB then foffs -= fsize;
	  exit i == fno;
	    if trec@.bitorder != MSB then foffs += fsize;
	    s = s@.next;
	    i += 1;
	}
//err.str("BitfieldOffset="); err.uint(WSfoffs); err.nl();
	return foffs;
    }

    proc BitfieldIndex(node: Ast, size: type.BitSize, tree: Ast): Ast
    {   var indx: Ast;

	// FIXME: what about bitorder?
	indx = expr.ExtendT(node@.child[1], type.wordtype);
	indx = ast.New2(MUL, type.wordtype, indx,
                        ast.Const(type.wordtype, size));
	if tree != 0 then
	    tree = ast.New2(ADD, type.wordtype, tree, indx);
	else
	    tree = indx;
	return tree;
    }

    proc BitfieldRewrite(offs: Ast): Ast, Ast, Ast
    {   var varb, tree: Ast;
	var shft: type.BitSize;

	shft = 0;
	varb = 0;
	loop
	{   if offs@.op
	    is OFFSET then
		shft += BitfieldOffset(offs@.child[0]@.type, offs@.valu);
	    is INDEX then
		varb = BitfieldIndex(offs, offs@.type@.size, varb);
	    is SLICE then
		varb = BitfieldIndex(offs, offs@.type@.base@.size, varb);
	    offs = offs@.child[0];
	  exit (offs@.op < OFFSET || offs@.op > SLICE) ||
	    offs@.child[0]@.type@.packed != BIT;
	}
	if shft != 0 then
	{   tree = ast.Const(type.wordtype, shft);
	    if varb != 0 then
		varb = ast.New2(ADD, type.wordtype, varb, tree);
	    else
		varb = tree;
	}
	// load the container of the bitfield
	tree = ast.New1(LOAD, offs@.type, offs);
	tree@.kind = UINT;
	tree@.size = offs@.type@.width;
	// make sure the endian is correct
	if tree@.size > Target.membits && 
	   tree@.type@.memorder != Target.order then
	    tree = ast.New1(REVB, tree@.type, tree);
	// make register sized, this simplifies things
	tree = expr.ExtendT(tree, type.wordtype);
	return tree,    // return the loaded container,
	       varb,    // the shift computation,
	       offs;    // and the base address 
    }

    proc BitfieldMask(node: Ast): Ast
    {   var mask: Ast;
	var bits: type.Valu;
	var size: type.BitSize;

	if node@.op == SLICE then
	{   if node@.child[2]@.op != CONST then
	    {
err.str("BitfieldMask of variable SLICE\n");
	    }
	    else
	    {   size = node@.type@.base@.size;
		size = size * type.BitSize(node@.child[2]@.valu);
	    }
	}
	else
	    size = node@.type.size;
	bits = (1<<size)-1;
	mask = ast.Const(type.wordtype, bits);
	return mask;
    }
	
    proc Load(load: Ast)
    {   var offs, tree, varb, mask: Ast;
	var size: type.BitSize;
	var t: Type;

	// LLVM doesn't handle bitfields (packed records or arrays)
	// so we expand bitfield extract
	offs = load@.child[0];
	if (offs@.op >= OFFSET && offs@.op <= SLICE) &&
	    offs@.child[0]@.type@.packed == BIT then
	{   // We are dealing with a packed record or array (aka bitfield).
	    t = offs@.type;		// final type
	    size = t@.size;		// final bit size
	    mask = BitfieldMask(offs);
	    // Rewrite the AST to extract item.
	    tree, varb, offs = BitfieldRewrite(offs);
	    // shift item rightward, if necessary
	    if varb != 0 then
		tree = ast.New2(LSR, t, tree, varb);
	    // mask off the parts we don't want
	    tree = ast.New2(AND, t, tree, mask);
	    // possibly narrow the size
	    tree = expr.Extend(tree, load@.size, true);
//err.str("BFLoad tree=\n"); ast.Dump(tree); err.nl();
	    GenSub(tree);
	    load@.child[0] = tree;      // load@.op == LOAD, we're done with it
	    load@.seqno = tree@.seqno;  // copy up seqno of node below
	}
	else	// normal load
	{   GenSub(offs);
	    load@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = ", load);
	    if offs@.type@.input then
		f.str("volatile ");
	    Print("load %T* %0N", load);
	    PEndLine(load);
	}
    }

    proc Store(store: Ast)
    {   var rhs, lhs, varb, tree, mask: Ast;
	var size: type.BitSize;
	var t: Type;
	var i, n: ast.NSubNodes;

	i = 0;
	n = store@.num / 2;
	while i < n do
	{   lhs = store@.child[i];
	    rhs = store@.child[n+i];
	    // LLVM doesn't handle bitfields (packed records or arrays)
	    // so we expand bitfield insert
	    if (lhs@.op >= OFFSET && lhs@.op <= SLICE) &&
		lhs@.child[0]@.type@.packed == BIT then
	    {   // We are dealing with a packed record or array (aka bitfield).
		t = lhs@.type;			// final type
		size = t@.size;			// final bit size
		mask = BitfieldMask(lhs);
		// Rewrite the AST to extract item.
		tree, varb, lhs = BitfieldRewrite(lhs);
		// shift the mask leftward, if necessary
		if varb != 0 then
		    mask = ast.New2(LSL, type.wordtype, mask, varb);
		mask = ast.New1(NOT, type.wordtype, mask);
		// mask out the field in the target
		tree = ast.New2(AND, type.wordtype, tree, mask);
		// make the value word size
		rhs = expr.ExtendT(rhs, type.wordtype);
		// shift the value leftward, if necessary
		if varb != 0 then
		    rhs  = ast.New2(LSL, type.wordtype, rhs, varb);
		// or in the new value
		rhs  = ast.New2(OR, type.wordtype, tree, rhs);
		// adjust width of final result
		rhs = expr.Extend(rhs, lhs@.type@.width, true);
		// make sure the endian is correct
		if lhs@.size > Target.membits && 
		   lhs@.type@.memorder != Target.order then
		    rhs = ast.New1(REVB, rhs@.type, rhs);
		store@.child[i] = lhs;
		store@.child[n+i] = rhs;
//err.str("BFStore tree=\n"); ast.Dump(store); err.nl();
	    }
	    GenSub(rhs);	// rhs first
	    i += 1;
	}
	i = 0;
	while i < n do
	{   lhs = store@.child[i];
	    rhs = store@.child[n+i];
	    if lhs != 0 then
	    {   GenSub(lhs);	// then lhs
		f.chr('\t');
		if store@.child[i]@.type@.output then
		   f.str("volatile ");
		f.str("store ");
		NodeType(rhs); f.chr(' ');
		NodeSrc(rhs);  f.str(", ");
		NodeType(lhs); f.chr(' ');
		NodeDst(lhs);
		PEndLine(store);
	    }
	    i += 1;
	}
    }

    proc Return(node: Ast): boolean
    {   var i: ast.NSubNodes;
	var rnode: Ast;

	if node@.num > 0 then
	{   i = 0;
	    while i < node@.num do
	    {   rnode = node@.child[i];
		GenSub(rnode);
		Print("\tstore %T %N, %T* ", rnode);
		PRetValName(i);
		PEndLine(node);
		i += 1;
	    }
	    node@.seqno = node@.child[0]@.seqno;
	}
	f.str("\tbr label %return");
	PEndLine(node);
	return true;	// always terminates a block
    }

    proc IfExpr(node: Ast)
    {
	GenSub(node@.child[1]);
	GenSub(node@.child[2]);
	GenSub(node@.child[0]);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = select i1 %0N, %1T %1N, %2T %2N", node);
	PEndLine(node);
    }
	
    proc GenSub(node: Ast): boolean
    {   var term: boolean;	// basic block has been terminated

	term = false;
	if node == 0 then return term;
	if node@.seqno != 0 then return term;
//{   err.str("node "); err.uint(Snode@.seqno);
//    err.str(" visited before, ignoring.\n");
//    return term;
//}
	if node@.op
	is NOP then { GenSub(node@.child[0]); node@.seqno = node@.child[0]@.seqno; }
	is FILE then
	{   if feature.gflag then llvmdb.FileStart(node@.symb@);
	    GenSub(node@.child[0]);
	    if feature.gflag then llvmdb.FileFinish(node@.symb@);
	}
	is PACKAGE then
	{   if feature.gflag then llvmdb.PackageStart(node@.symb@.ident);
	    GenSub(node@.child[0]);
	    if feature.gflag then llvmdb.PackageEnd();
	}
	is PROC then
	{   if feature.gflag then llvmdb.ProcStart(node@.symb@);
	    Procedure(node);
	    if feature.gflag then llvmdb.ProcFinish(node@.symb@);
	}
	is DCLVAR then DclVar(node);
	is DCLCON then DclCon(node);
	is VAR, CONST then {}
	is SCON, CLIST then
	{
	    node@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = getelementptr %T %S\n", node);
	}
	is ACOPY then Copy(node);
	is AEQ, ANE then term = ArrayCompare(node);
	is COPY then Copy(node);
	is RET then term = Return(node);
	is GETRV then GetRV(node);
	is STORE then Store(node);
	is LOAD  then Load(node);
	is BYREF then
	{   GenSub(node@.child[0]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = getelementptr %T %0N\n", node);
	}
	is OFFSET then
	{   GenSub(node@.child[0]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = getelementptr %0T %0N, %W 0, i32 ", node);
	    f.uint32(_uint32(node@.valu));
	    f.nl();
	}
	is INDEX then
	{   GenSub(node@.child[0]);
	    // LLVM wants index value to be register width
	    node@.child[1] = expr.ExtendT(node@.child[1], type.wordtype);
	    GenSub(node@.child[1]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = getelementptr %0T %0N, %W 0, %1T %1N\n", node);
	}
	is SLICE then
	{   var nextseqno: seqnoT;
	    // Treat this like an index followed by cast back to original type
	    // Ignore the count, for now
	    GenSub(node@.child[0]);
	    // LLVM wants index value to be register width
	    node@.child[1] = expr.ExtendT(node@.child[1], type.wordtype);
	    GenSub(node@.child[1]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    nextseqno = Tseqno; Tseqno += 1;
	    Print("\t%N = getelementptr %0T %0N, %W 0, %1T %1N\n", node);
	    f.chr('\t'); PTempName(nextseqno);
	    Print(" = bitcast %A* %N to %T\n", node);
	    node@.seqno = nextseqno;
	}	
	is CAST then
	{   GenSub(node@.child[0]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    if node@.kind == REF then
	    {   if node@.child[0]@.kind == REF then
		    Print("\t%N = bitcast %0T %0N to %T\n", node);
		else
		    Print("\t%N = inttoptr %0T %0N to %T\n", node);
	    }
	    else
	    {   if node@.child[0]@.kind == REF then
		    Print("\t%N = ptrtoint %0T %0N to %T\n", node);
		else
		    Print("\t%N = bitcast %0T %0N to %T\n", node);
	    }
	}	
	is ZEXT then  ChangeSize(node, "zext");
	is SEXT then  ChangeSize(node, "sext");
	is TRUNC then ChangeSize(node, "trunc");
	is REVB then  Swap(node);
	is NOT then
	{   GenSub(node@.child[0]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = xor %0T %0N, -1\n", node);
	}
	is NEG then
	{   GenSub(node@.child[0]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = sub %0T 0, %0N\n", node);
	}
	is ADD then BinaryOp(node, "add");
	is SUB then BinaryOp(node, "sub");
	is MUL then BinaryOp(node, "mul");
	is DIV then BinaryOp(node, "udiv");	// FIXME: signed version
	is MOD then BinaryOp(node, "urem");	// FIXME: signed version
	is LSL, ASL then BinaryOp(node, "shl");
	is LSR then BinaryOp(node, "lshr");
	is ASR then BinaryOp(node, "ashr");
	is EQ then  term = CompareOp(node, "icmp eq");
	is NE then  term = CompareOp(node, "icmp ne");
	is UGT then term = CompareOp(node, "icmp ugt");
	is ULT then term = CompareOp(node, "icmp ult");
	is UGE then term = CompareOp(node, "icmp uge");
	is ULE then term = CompareOp(node, "icmp ule");
	is SGT then term = CompareOp(node, "icmp sgt");
	is SLT then term = CompareOp(node, "icmp slt");
	is SGE then term = CompareOp(node, "icmp sge");
	is SLE then term = CompareOp(node, "icmp sle");
	is AND then BinaryOp(node, "and");
	is OR then  BinaryOp(node, "or");
	is XOR then BinaryOp(node, "xor");
	is BNOT then
	{   GenSub(node@.child[0]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = xor i1 %0N, true\n", node);
	}
	is BOR then  term = Conditional(node, false);
	is BAND then term = Conditional(node, true);
	is IFEXPR then IfExpr(node);
	is CALL then  Call(node, false);
	is CALLI then Call(node, true);
	is ASM then Asm(node);
	is IF then   term = If(node);
	is SEL then  term = Select(node);
	is LOOP then term = Loop(node);
	is EXIT then term = Exit(node);
	is SEQ then
	{   var i: ast.NSubNodes;
	    i = 0;
	    while i < node@.num do
	    {   if term then
		{   // a block ends in a sequence, unreachable code
		    Label(Lseqno);  Lseqno += 1;
		    term = false;
		}
		term = GenSub(node@.child[i]);
		i += 1;
	    }
	}
	return term;
    }

    proc Gen(fd: file, tree: Ast)
    {   var i: 0..target.IntSizesMax;

	f = bout.buffer(fd, 4096);;
	// These pointer types might be useful to other packages.
	pbytetype = type.New(REF);
	pbytetype.base = type.bytetype;
	puinttype[0] = type.New(REF);
	puinttype[0].base = type.uinttypes[0];
	puinttype[1] = type.New(REF);
	puinttype[1].base = type.uinttypes[1];
	puinttype[2] = type.New(REF);
	puinttype[2].base = type.uinttypes[2];
	puinttype[3] = type.New(REF);
	puinttype[3].base = type.uinttypes[3];

	f.str("target datalayout = \"");
	if Target.order == BE then f.str("E"); else f.str("e");
	f.str("-p:");  f.uint(Target.ptr.size);
	f.str(":");    f.uint(Target.ptr.align);
	f.str(":");    f.uint(Target.ptr.align);
	f.str("-i1:"); f.uint(Target.isizes[0].align);
	f.str(":");    f.uint(Target.isizes[0].align);
	i = 0;
	while i < Target.nisize do
	{   f.str("-i"); f.uint(Target.isizes[i].size);
	    f.str(":");  f.uint(Target.isizes[i].align);
	    f.str(":");  f.uint(Target.isizes[i].align);
	    i += 1;
	}
	f.str("\"\ntarget triple = \"");
	f.str(Target.triple);
	f.str("\"\n");
	GenSub(tree);
	Declare();
	if feature.gflag then llvmdb.ProgFinish();
	f.flush();
    }
}
// vim: ts=8 sw=4 noet nowrap

