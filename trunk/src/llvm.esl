// Copyright (c) 2009-2011, Brian G. Lucas.  See LICENSE file.
// $Id$

// Convert AST to LLVM assembly
import bout;
package llvm
{
    alias lex.StringRange as StringRange;
    const package_delimiter:Char = '_';
    const anon_prefix: []Char = "A.";
    const scon_prefix: []Char = "S.";
    type file: sys.fildes;
    var  f: bout.pBufIO;
    proc PType(t: Type);					// forward
    proc PName(s: Symb);					// forward
    proc PRetvType(tl: type.TypeList, extend: boolean);		// forward
    proc PParmTypes(s: Symb);					// forward
}

import llvmdb;

package llvm
{
    // These pointer types might be useful to other packages.
    var pbytetype: Type;
    var puinttype: [target.IntSizesMax]Type;
    type seqnoT: 0..0xFFFF;
    var Tseqno: seqnoT;
    var Pseqno: seqnoT = 0;
    var Lseqno: seqnoT = 0;
    var Aseqno: _uint16 = 0;
    var labthis: seqnoT;	// label sequence number of this basic block
    var loopexit: seqnoT;	// label sequence number for this loop exit
    type Intrinsics:
    (   MEMCPY, MEMMOVE, MEMSET, MEMCMP, ZLEN, BSWAP,
	CLZ, CTZ, POP,
	END
    );
    type IntrinsicUse:
    {   next:   @IntrinsicUse;
	type:   Type;
	size:   _uint;
    };
    type pIntrinsicUse: @IntrinsicUse;
    var UsedIntrinsic: [Intrinsics]pIntrinsicUse;

    proc UseIntrinsic(which: Intrinsics, size: _uint, t: Type)
    {   var piu: pIntrinsicUse;

	if size == 0 then size = 1;
//err.str("Use "); err.uint(_uint8(which));
//err.str(" size="); err.uint(size); err.nl();
	piu = UsedIntrinsic[which];
	while piu != 0 && piu@.size != size do
	    piu = piu@.next;
	if piu == 0 then    // new usage
	{   piu = pIntrinsicUse(sys.malloc(IntrinsicUse?size));
	    piu.size = size;
	    piu.type = t;
	    piu.next = UsedIntrinsic[which];
	    UsedIntrinsic[which] = piu;
	}
    }

    proc Print(fmt: @[]Char, anode: Ast);   // forward

    proc DeclareIntrinsics()
    {   var i: Intrinsics;
	var piu: pIntrinsicUse;
	var dummy: ast.AstNode;     // just to Print width/align of type

	dummy.type = 0;
	i = MEMCPY;
	while i < END do
	{   if UsedIntrinsic[i] != 0 then
	    {   piu = UsedIntrinsic[i];
		if i
		is MEMCPY then
		    Print("declare void @llvm.memcpy.p0i8.p0i8.%W(i8*, i8*, %W, i32, i1) nounwind\n", dummy);
		is MEMSET then
		    Print("declare void @llvm.memset.p0i8.%W(i8*, i8, %W, i32, i1) nounwind\n", dummy);
		is BSWAP then
		{   do
		    {   dummy.type = piu@.type;
			Print("declare %K @llvm.bswap.%K(%K)\n", dummy);
			piu = piu@.next;
		    } while piu != 0;
		}
		is CLZ then
		{   do
		    {   dummy.type = piu@.type;
			Print("declare %K @llvm.ctlz.%K(%K, i1)\n", dummy);
			piu = piu@.next;
		    } while piu != 0;
		}
		is CTZ then
		{   do
		    {   dummy.type = piu@.type;
			Print("declare %K @llvm.cttz.%K(%K, i1)\n", dummy);
			piu = piu@.next;
		    } while piu != 0;
		}
		is POP then
		{   do
		    {   dummy.type = piu@.type;
			Print("declare %K @llvm.ctpop.%K(%K)\n", dummy);
			piu = piu@.next;
		    } while piu != 0;
		}
		is MEMCMP then
		{   do
		    {   dummy.type = piu@.type;
			Print("declare i1 @memcmp%*B(%K, %K, %W)\n", dummy);
			piu = piu@.next;
		    } while piu != 0;
		}
		is ZLEN then
		{   do
		    {   dummy.type = piu@.type;
			Print("declare %W @memlen%*A(%K)\n", dummy);
			piu = piu@.next;
		    } while piu != 0;
		}
	    }
	    i += 1;
	}
    }

    proc GenSub(node: Ast): boolean;	// forward
    proc ProcParmTypes(s: Symb);	// forward

    proc PEndLine(node: Ast)
    {
	if feature.gflag then llvmdb.PLine(node@.lineno);
	f.nl();
    }

    proc PTypeName(t: Type)
    {   var s: Symb;

	f.str("%");
	s = t@.name;
	if s != 0 then
	{   if s@.package != 0 then
	    {   f.str(s@.package@.ident);
		f.str(".");
	    }
	    f.str(s@.ident);
	}
	else
	{   f.str(anon_prefix);
	    if t@.antag == 0 then
	    {   Aseqno += 1;
		t@.antag = Aseqno;
	    }
	    f.uint16(t@.antag);
	}
    }

    proc PRecordType(t: Type)
    {   var s: Symb;

	if t@.noepad || t@.nofpad then
	    f.chr('<');
	f.str("{");
	s = t@.list;
	while s != 0 do
	{   PType(s@.type);
	    s = s@.next;
	  exit s == 0;
	    f.str(", ");
	}
	f.str("}");
	if t@.noepad || t@.nofpad then
	    f.chr('>');
	 
    }

    proc PWidth(t: Type)
    {
	if t != 0 then
	    f.uint(t@.width/Target.membits);
    }

    proc PAlign(t: Type)
    {
	if t != 0 then
	    f.uint(t@.align/Target.membits);
    }

    proc PType(t: Type)
    {   var size: type.BitSize;

	if t != 0 then
	{   if t@.kind
	    is ENUM, UINT, SINT then
	    {   size = target.isize(t@.size);
		f.chr('i'); f.uint(size);
	    }
	    is FLOAT then
	    {
		if t@.size
		is 32 then f.str("float");
		is 64 then f.str("double");
	    }
	    is REF then
	    {   PType(t@.base);
		f.chr('*');
	    }
	    is RECORD then
	    {   if t@.packed then
		{   // LLVM doesn't do bit pack records, handle as integers
		    size = target.isize(t@.size);
		    f.chr('i'); f.uint(size);
		}
		else
		{   if t@.printed then
			PTypeName(t);
		    else
			PRecordType(t);
		}
	    }
	    is ARRAY then
	    {
		if t@.packed then
		{   // LLVM doesn't do bit pack arrays, handle as integers
		    size = target.isize(t@.size);
		    f.chr('i'); f.uint(size);
		}
		else
		{   f.chr('[');
		    f.uint32(t.Span());
		    f.str(" x ");
		    PType(t@.base);
		    f.chr(']');
		}
	    }
	    is REFPROC then
	    {   PRetvType(t@.list@.retvlist, false);
		f.chr(' ');
		PParmTypes(t@.list@.parmlist);
		f.chr('*');
	    }
	}
    }

    proc PExtend(t: Type)
    {
	if t != 0 then
	{   if t@.kind
	    is ENUM, UINT, SINT then
	    {   var size: type.BitSize;
		size = target.isize(t@.size);
		if size < type.wordtype@.size then
		{
		    if t@.kind == SINT then
			f.str(" signext");
		    else
			f.str(" zeroext");
		}
	    }
	}
    }

    proc PRetvType(tl: type.TypeList, extend: boolean)
    {   var t: Type;

	if tl != 0 then
	{   if  tl@.next != 0 then		// has multiple returned values
	    {   f.str(" { ");
		loop
		{   PType(tl@.type);
		    tl = tl@.next;
		  exit tl == 0;
		    f.str(", ");
		}
		f.str(" }");
	    }
	    else				// single returned value
	    {   t = tl@.type;
		if extend then PExtend(t);
		f.chr(' ');
		PType(t);
	    }
	}
	else					// has no returned value
	    f.str(" void");
    }
    
    proc PParmTypes(s: Symb)
    {
	f.chr('(');
	while s != 0 do
	{   PType(s@.type);
	    s = s@.next;
	  exit s == 0;
	    f.str(", ");
	}
	f.chr(')');
    }
 
    proc ConstantRef(node: Ast)
    {   var v: type.Valu;

	v = node@.valu;
	if v == 0 then
	    f.str("null");
	else
	{   f.str("inttoptr(");
	    PType(type.wordtype);
	    f.chr(' ');
	    f.uint64(v);
	    f.str(" to ");
	    PType(node@.type);
	    f.chr(')');
	}
    }
	
    proc NodeType(node: Ast)
    {
	if node@.type@.kind
	is UTYPE then	      { f.str("void"); }
	is FLOAT then         { PType(node@.type); }
	is REF then           { PType(node@.type); /* f.str("*"); */ }
	is ARRAY, RECORD, REFPROC then { PType(node@.type); }
	else                  { f.str("i"); f.uint(node@.width); }
    }

    proc PPkgPfx(s: Symb)
    {   if s@.package != 0 then PPkgPfx(s@.package);    // recursive
	f.str(s@.ident); 
	f.chr(package_delimiter);
    }

    proc PMethod(s: Symb)
    {   var bs: Symb;
	var bt: Type;

	bt = s@.parmlist@.type;
	if bt@.kind == REF then bt = bt@.base;
	bs = bt@.name;
	if bs@.package != 0 then
	    PPkgPfx(bs@.package);
	f.str(bs@.ident);
	f.chr(package_delimiter);
    }
    
    proc PName(s: Symb)
    {
	if s@.linkage
	is FORMAL, LOCAL then
	{   f.chr('%');
	    f.str(s@.ident);
	}
	is NORMAL, INLINE then
	{   f.chr('@');
	    if s@.kind == PROC && s@.bound then
		PMethod(s);
	    else
	    {   if s@.package != 0 then
		    PPkgPfx(s@.package);
	    }
	    f.str(s@.ident);
	}
	is GLOBAL, WEAK, EXTERN then
	{   f.chr('@');
	    if s@.kind == PROC && s@.bound then
		PMethod(s);
            if s@.altsymb != 0 then
                f.str(s@.altsymb@.ident);
	    else
		f.str(s@.ident);
	}
	is FIXED then
	{   f.str("inttoptr(");
	    PType(type.wordtype);
	    f.chr(' ');
	    f.uint64(s@.xaddr);
	    f.str(" to ");
	    if s@.kind == PROC then
	    {   PRetvType(s@.retvlist, true);
		PParmTypes(s@.parmlist);
	    }
	    else
		PType(s@.type);
	    f.str("*)");
	}
    }

    proc PTempName(n: seqnoT)
    {
	f.chr('%');
	f.uint(n-1);
    }

    proc NodeName(node: Ast)
    {   var s: Symb;

	s = node@.symb;
	if s != 0 then
	    PName(s);
	else
	    f.str("__NoName__");
    }

    proc PFloat(node: Ast)
    {
	f.uint64(node@.valu);
	f.str(".0e");
	f.int16(-node@.scale);
    }

    proc NodeDst(node: Ast)
    {
	if node@.op
	is CONST then
	{   if node@.type@.kind != REF then
	        lex.ErrorS(COMPILER, "Assignment to constant");
	    ConstantRef(node);
	}
	is VAR, DCLVAR then NodeName(node);
	else PTempName(node@.seqno);
    }

    proc NodeSrc(node: Ast)
    {
	if node@.op
	is CONST then
	{   if node@.type@.kind
	    is ENUM, UINT then f.uint64(node@.valu);
	    is SINT then       f.int64(_int64(node@.valu));
	    is REF, REFPROC then ConstantRef(node);
	    is ARRAY, RECORD then f.uint64(node@.valu);	    // packed?
	}
	is FCON then PFloat(node);
	is SCON, CLIST then
	{   f.chr('@');
	    f.str(scon_prefix);
	    f.uint32(_uint32(node@.valu));
	}
	is VAR then NodeName(node);
	else        PTempName(node@.seqno);
    }

    proc Print(fmt: @[]Char, anode: Ast)
    {   var i: _uint;
	var c: Char;
	var n: ast.NSubNodes;
	var node: Ast;
	var t: Type;

	i = 0;
	loop
	{   c = fmt[i];
	  exit c == 0;
	    if c == '%' then
	    {   i += 1;  c = fmt[i];
		node = anode;
		if c
		is '0'..'9' then
		{   n = 0;
		    loop
		    {   n = (n * 10) + (c - '0');
			i += 1;  c = fmt[i];
		      exit c < '0' || c > '9';
		    }
		    node = anode@.child[n];
		}
		t = node@.type;
		while c == '*' do
		{   if t != 0 then t = t@.base;
		    i += 1;  c = fmt[i];
		}
		if c
		is 'K' then PType(t);
		is 'A' then PAlign(t);
		is 'B' then PWidth(t);
		is 'T' then NodeType(node);
		is 'I' then NodeName(node);
		is 'N' then NodeSrc(node);
		is 'D' then NodeDst(node);
		is 'W' then PType(type.wordtype);	// target word type
		is 'S' then // string name
		{   f.chr('@');
		    f.str(scon_prefix);
		    f.uint32(_uint32(node@.valu));
		}
		is '%' then f.chr(c);
	    }
	    else
		f.chr(c);
	    i += 1;
	}
    }

    proc PRetValName(n: ast.NSubNodes)
    {
	f.str("%rv.");
	f.uint(n);
    }

    proc Alignment(t: Type)
    {   var n: type.BitSize;

	n = t@.align;
	if n >= Target.membits then
	{   f.str(", align ");
	    f.uint(n / Target.membits);
	}
    }

    proc Section(s: Symb, comma: boolean)
    {
	if s != 0 then
	{
	    if comma then
	    {
		f.str(",");
	    }
	    f.str(" section \"");
	    f.str(s@.ident);
	    f.str("\"");
	}
    }

    proc DclType(t: Type)
    {   var s: Symb;
	var size: type.BitSize;

	if t != 0 && !t@.printed then
	{   if t@.kind
	    is REF, ARRAY then DclType(t@.base);
	    is REFPROC then
	    {   // make sure formals are all recursively defined
		s = t@.list@.parmlist;
		while s != 0 do
		{   DclType(s@.type);
		    s = s@.next;
		}
	    }
	    is RECORD then
	    {   t@.printed = true;
		// make sure all types are recursively defined
		s = t@.list;
		while s != 0 do
		{   DclType(s@.type);
		    s = s@.next;
		}
		// now deal with the record
		PTypeName(t);
		f.str(" = type ");
		if t@.packed then
		{   // LLVM doesn't do bit pack records, handle as integers
		    size = target.isize(t@.size);
		    f.str("i"); f.uint(size);
		}
		else
		    PRecordType(t);
		f.nl();
	    }
	}		
    }

    proc DclProc(node: Ast, isdefine: boolean)
    {   var s, ps: Symb;

	ps = node@.symb;
	if isdefine then f.str("define"); else f.str("declare");
	if ps@.linkage
	is NORMAL, INLINE then f.str(" internal");
	is WEAK then f.str(" weak");
	is EXTERN then f.str(" external");
	PRetvType(ps@.retvlist, true);
	Print(" %I(", node);
	s = ps@.parmlist;
	while s != 0 do
	{   PType(s@.type);
	    PExtend(s@.type);
	    if isdefine then
	    {   f.str(" %");
		f.str(s@.ident);
		f.chr('$');
	    }
	    s = s@.next;
	  exit s == 0;
	    f.str(", ");
	}
	f.str(")");
    }

    proc PString(s:@[]_byte, n:0..lex.StringMax, prefix: boolean)
    {   var i: 0..lex.StringMax;
	var c: Char;

	if prefix then f.chr('c');
	f.chr('"');
	i = 0;
	while i < n do
	{   c = s[i];
	    if c < ' ' || c >= 0x7F || c == '"' || c == '\\' then
	    {   f.chr('\\');
		f.hex8(c);
	    }
	    else
		f.chr(c);
	    i += 1;
	}
	f.chr('"');
    }

    proc DefaultInitializer(t: Type)
    {
	if t@.kind
	is ENUM, UINT, SINT then
	    f.uint(0);
	is FLOAT then
	    f.str("0.0");
	is REF then
	    f.str("zeroinitializer");   // FIXME: "null" ?
	is ARRAY, RECORD then
	    f.str("zeroinitializer");
	is REFPROC then
	    f.str("null");
    }

    proc Constant(node: Ast)
    {   var i: ast.NSubNodes;
	var t: Type;
	var n: StringRange;

	t = node@.type;
	if t != 0 then
	{   if node.op
	    is CONST then
	    {   if t@.kind
		is REF, REFPROC then ConstantRef(node);
		is SINT then f.int64(_int64(node@.valu));
		is ARRAY then
		{   if t.packed then
			f.uint64(node@.valu);
		    else
			f.str("zeroinitializer");
		}
		else         f.uint64(node@.valu);
	    }
	    is FCON then PFloat(node);
	    is SCON then
	    {   if t@.flex then
		    n = StringRange(node@.type.Span());
		else
		    n = StringRange(t.Span());
		PString(node@.symb@.ident, n, true);
	    }
	    is CLIST then
	    {   if t@.kind
		is RECORD then
		{   if t@.noepad || t@.nofpad then
			f.chr('<');
		    f.str("{ ");
		    i = 0;
		    loop
		    {
		        PType(node@.child[i]@.type);
			f.str(" ");
			Constant(node@.child[i]);
			i += 1;
		      exit i >= node@.num;
			f.str(", ");
		    }
		    f.str(" }");
		    if t@.noepad || t@.nofpad then
			f.chr('>');
		}
		is ARRAY then
		{   f.str("[ ");
		    i = 0;
		    loop
		    {
		        PType(node@.child[i]@.type);
			f.str(" ");
			Constant(node@.child[i]);
			i += 1;
		      exit i >= node@.num;
			f.str(", ");
		    }
		    f.str(" ]");
		}
	    }
	    is BYREF then
	    {   if t@.base@.flex then
		    Print("bitcast( %T* ", node@.child[0]);
		Print("getelementptr( %T* %N ) ", node@.child[0]);
		if t@.base@.flex then
		    Print(" to %T )", node);
	    }
	    is CAST then
	    {   if t@.base@.flex then
		    Print("bitcast( %T ", node@.child[0]);
		Print("getelementptr( %T %N ) ", node@.child[0]);
		if t@.base@.flex then
		    Print(" to %T )", node);
	    }
	    is VAR then    // reference another const by name
	    {   if t@.kind == REFPROC then
		{
		    PName(node@.symb);
		}
		else
		{   if t@.base@.flex then
			Print("bitcast( %T ", node);
		    Print("getelementptr( %T %N ) ", node);
		    if t@.base@.flex then
			Print(" to %T )", node);
		}
	    }
	}
    }

    proc DclVar(node: Ast)
    {   var s: Symb;
        var rhs: Ast;

	s = node@.symb;
	rhs = node@.child[0];
	if s != 0 then
	{   DclType(s@.type);
	    if s@.linkage
	    is LOCAL then
	    {   Print("\t%I = alloca %K", node);
		if rhs != 0 then     // initialized local
		{   if node@.type@.kind <= REF then // scalar
		    {   f.nl();
			// FIXME: Print("store %T %N", rhs);
			GenSub(rhs);
			f.chr('\t');
			f.str("store ");
			NodeType(rhs); f.chr(' ');
			NodeSrc(rhs);
			Print(", %K* %D", node);
		    }
		    else lex.ErrorS(NOTIMPL, "initialized local composites");
		}
	    }
	    is NORMAL then
	    {   Print("%I = internal global %K ", node);
		if rhs != 0 then
		    Constant(rhs);
		else
		    DefaultInitializer(node@.type);
		Alignment(s@.type);
		Section(s@.section, true);
	    }
	    is GLOBAL then
	    {   Print("%I = global %K ", node);
		if rhs != 0 then
		    Constant(rhs);
		else
		    DefaultInitializer(node@.type);
		Alignment(s@.type);
		Section(s@.section, true);
	    }
	    is WEAK then
	    {   Print("%I = weak global %K ", node);
		if rhs != 0 then
		    Constant(rhs);
		else
		    DefaultInitializer(node@.type);
		Alignment(s@.type);
		Section(s@.section, true);
	    }
	    is EXTERN then
		Print("%I = external global %K", node);
	    f.nl();
	    if feature.gflag then llvmdb.DefVar(s);
	}
    }

    proc DclString(node: Ast)
    {   var n: StringRange;

	Print("%S = internal constant %K ", node);
	n = StringRange(node@.type.Span());
	PString(node@.symb@.ident, n, true);
	f.nl();
    }

    // Look at nodes under a constant to see if there are any
    // string constants by reference.  If so, declare the string.
    proc ConstScan(node: Ast)
    {   var i: ast.NSubNodes;

	if node@.op == BYREF && node@.child[0].op == SCON then
	    DclString(node@.child[0]);
	else
	{   i = 0;
	    while i < node@.num do
	    {   ConstScan(node@.child[i]);
		i += 1;
	    }
	}
    }

    proc DclCon(node: Ast)
    {   var s: Symb;

	s = node@.symb;
	if s != 0 then
	{   DclType(s@.type);
	    ConstScan(node);
	    if s@.linkage
	    is NORMAL then Print("%I = internal constant %K ", node);
	    is GLOBAL then Print("%I = constant %K ", node);
	    Constant(node@.child[0]);
	    Alignment(s@.type);
	    Section(s@.section, true);
	}
	f.nl();
    }

    proc DclAggregate(node: Ast)
    {
	ConstScan(node);
	Print("%S = internal constant %K ", node);
	Constant(node);
	// FIXME: Alignment(node@.type)?
	f.nl();
    }

    proc PLabel(n: seqnoT)
    {
	f.str("L.");
	f.uint(n);
    }

    proc Label(n: seqnoT)
    {
	PLabel(n);
	f.str(":\n");
	labthis = n;
    }

    proc RefLabel(n: seqnoT)
    {
	f.str("label %");
	PLabel(n);
    }
	
    proc Branch(n: seqnoT)
    {
	f.str("\tbr ");
	RefLabel(n);
	f.nl();
    }

    proc BranchConditional(node: Ast, ntrue: seqnoT, nfalse: seqnoT)
    {
	f.str("\tbr i1 ");
	NodeSrc(node);
	f.str(", ");
	RefLabel(ntrue);
	f.str(", ");
	RefLabel(nfalse);
	PEndLine(node);
    }

    proc If(node: Ast): boolean
    {   var labend, labtrue, labfalse: seqnoT;
	var term: boolean;

	GenSub(node@.child[0]);
	labend = Lseqno;  Lseqno += 1;
	labtrue = Lseqno;  Lseqno += 1;
	if node@.child[2] != 0 then
	{   labfalse = Lseqno;  Lseqno += 1;
	}
	else
	    labfalse = labend;
	BranchConditional(node@.child[0], labtrue, labfalse);
	Label(labtrue);
	term = GenSub(node@.child[1]);
	if !term then Branch(labend);
	if node@.child[2] != 0 then
	{   Label(labfalse);
	    term = GenSub(node@.child[2]);
	    if !term then Branch(labend);
	}
	Label(labend);
	return false;
    }

    proc Select(node: Ast): boolean
    {	var i, j: ast.NSubNodes;
	var isnode, selnode: Ast;
	var labend, labelse: seqnoT;
	var lo, hi: Valu;

	// LLVM wants selector to be register width
	node@.child[0] = ast.ExtendT(node@.child[0], type.wordtype);
	GenSub(node@.child[0]);		// the selector value
	labelse = Lseqno;  Lseqno += 1;
	labend = Lseqno;  Lseqno += 1;
	Print("\tswitch %T %N, ", node@.child[0]);
	RefLabel(labelse);
	f.str(" [\n");
	// first pass through all the "is" nodes to generate labels
	i = 1;
	while i < node@.num -1 do
	{   isnode = node@.child[i];
	    if isnode@.op == IS then
	    {   isnode@.seqno = Lseqno;  Lseqno += 1;
		j = 0;
		while j < isnode@.num -1 do
		{   selnode = isnode@.child[j];
		    lo = 0; hi = 0;	// in case of internal error
		    if selnode@.op
		    is CONST then { lo = selnode@.valu; hi = lo; }
		    is CRANGE then
		    {   if selnode@.child[0]@.op == CONST &&
			   selnode@.child[1]@.op == CONST then
			{   lo = selnode@.child[0]@.valu;
			    hi = selnode@.child[1]@.valu;
			}
		    }
		    while lo <= hi do
		    {   Print("\t\t%0T ", node);
			f.uint32(_uint32(lo));
			f.str(", ");
			RefLabel(isnode@.seqno);
			f.nl();
			lo += 1;
		    }
		    j += 1;
		}
	    }
	    i += 1;
	}
	f.str("\t]\n");
	// second pass through all the "is" nodes to generate the code
	i = 1;
	while i < node@.num -1 do
	{   isnode = node@.child[i];
	    Label(isnode@.seqno);
	    if !GenSub(isnode@.child[isnode@.num-1]) then
		Branch(labend);
	    i += 1;
	}
	Label(labelse);
	// now the else node
	if !GenSub(node@.child[node@.num-1]) then
	    Branch(labend);
	Label(labend);
	return false;
    }

    proc Loop(node: Ast): boolean
    {   var loopcont, saveexit: seqnoT;

	saveexit = loopexit;
	loopcont = Lseqno;  Lseqno += 1;
	loopexit = Lseqno;  Lseqno += 1;
	Branch(loopcont);		// start a new basic block
	Label(loopcont);
	GenSub(node@.child[0]);
	Branch(loopcont);		// end of loop, continue
	Label(loopexit);		// loop exit
	loopexit = saveexit;
	return false;
    }

    proc Exit(node: Ast): boolean
    {   var labtrue, labfalse: seqnoT;
	var term: boolean;

	labfalse = Lseqno;  Lseqno += 1;
	GenSub(node@.child[0]);
	if (node@.child[1] != 0) then	// has "with" clause
	{   labtrue = Lseqno;  Lseqno += 1;
	    BranchConditional(node@.child[0], labtrue, labfalse);
	    Label(labtrue);		// exit with ...
	    term = GenSub(node@.child[1]);
	    if !term then
		Branch(loopexit);	// exit loop
	}
	else				// no "with" clause
	    BranchConditional(node@.child[0], loopexit, labfalse);
	Label(labfalse);		// come here if continuing
	return false;	
    }

    proc Conditional(node: Ast, isand: boolean): boolean
    {   var lablhs, labrhs, labend: seqnoT;

	labrhs = Lseqno;  Lseqno += 1;
	labend = Lseqno;  Lseqno += 1;
	GenSub(node@.child[0]);
	if isand then
	    BranchConditional(node@.child[0], labrhs, labend);
	else
	    BranchConditional(node@.child[0], labend, labrhs);
	lablhs = labthis;	// left hand side final basic block
	Label(labrhs);
	GenSub(node@.child[1]);
	labrhs = labthis;	// right hand side final basic block
	Branch(labend);
	Label(labend);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = phi i1 [ ", node);
	if isand then f.str("false"); else f.str("true");
	f.str(", %");
	PLabel(lablhs);
	f.str(" ], [ ");
	PTempName(node@.child[1]@.seqno);
	f.str(", %");
	PLabel(labrhs);
	f.str(" ]\n");
	return false;
    }

    proc Copy(node: Ast)
    {
	// LLVM wants i8* types
	node@.child[0] = ast.Cast(node@.child[0], pbytetype);
	node@.child[1] = ast.Cast(node@.child[1], pbytetype);
	GenSub(node@.child[0]);
	GenSub(node@.child[1]);
	// LLVM wants count to be register width
	node@.child[2] = ast.ExtendT(node@.child[2], type.wordtype);
	GenSub(node@.child[2]);
	// FIXME: need to check for potential overlap and use memmove if necessary
	// FIXME: find alignment, here or during parsing?
	Print(
	   "\tcall void @llvm.memcpy.p0i8.p0i8.%2T(i8* %0N, i8* %1N, %2T %2N, i32 %3N, i1 0)\n", node);
	UseIntrinsic(MEMCPY, 1, 0);     // FIXME - alignment
    }

    proc Set(node: Ast)
    {
	// LLVM wants i8* type
	node@.child[0] = ast.Cast(node@.child[0], pbytetype);
	GenSub(node@.child[0]);
	GenSub(node@.child[1]);
	// LLVM wants count to be register width
	node@.child[2] = ast.ExtendT(node@.child[2], type.wordtype);
	GenSub(node@.child[2]);
	Print(
	   "\tcall void @llvm.memset.p0i8.%W(i8* %0N, %1T %1N, %2T %2N, i32 %3N, i1 0)\n", node);
	UseIntrinsic(MEMSET, 1, 0);     // FIXME - alignment
    }

    proc GetChunkSize(size: _uint, align: _uint): 0..target.IntSizesMax
    {   var is, ia: 0..target.IntSizesMax;

	ia = 0;
	if align > 0 then
	{
	    while ia < Target.nisize-1 &&
		  align > Target.isizes[ia].align/Target.membits do
		ia += 1;
	}
	is = ia;
	if size > 0 then
	{   is = 0;
	    while is < Target.nisize-1 &&
		  size > Target.isizes[is].size/Target.membits do
		is += 1;
	}
	if ia < is then is = ia;
	return is;
    }

    // This horrible mess would be straighforward if only LLVM would support
    // an instrinsic llvm.memcmp().
    proc ArrayCompare(node: Ast): boolean
    {   var length, align, size: _uint;
	var i: 0..target.IntSizesMax;

	length = 0;	// 0 means variable
	if node@.child[2]@.op == CONST then
	    length = _uint(node@.child[2]@.valu) *
		(node@.child[0]@.type@.base@.base@.width/Target.membits);
	align = _uint(node@.child[3]@.valu);
	// find the largest target chunk we can use
	i = GetChunkSize(length, align);
	size = Target.isizes[i].size/Target.membits;
	align = Target.isizes[i].align/Target.membits;
	if length != 0 && length <= size then	// can do with one load
	{
	    node@.child[0] = ast.Cast(node@.child[0], puinttype[i]);
	    node@.child[0]@.width = puinttype[i]@.base@.width;
	    node@.child[0] = ast.New1(LOAD, puinttype[i]@.base, node@.child[0]);
	    node@.child[1] = ast.Cast(node@.child[1], puinttype[i]);
	    node@.child[1]@.width = puinttype[i]@.base@.width;
	    node@.child[1] = ast.New1(LOAD, puinttype[i]@.base, node@.child[1]);
	    if length < size then
	    {   var mask: _uint64;
		// Assert size <= 64;
		if Target.memorder == BE then
		    mask = ~((1 << ((size-length)*8)) -1);
		else	// assume LE
		    mask = (1 << (length*8)) - 1;
		node@.child[0] = ast.New2(XOR, puinttype[i]@.base,
					  node@.child[0], node.child[1]);
		node@.child[0] = ast.New2(AND, puinttype[i]@.base,
					  node@.child[0],
					  ast.Const(puinttype[i]@.base, mask));
		node@.child[1] = ast.Const(puinttype[i]@.base, 0);
	    }
	    GenSub(node@.child[0]);
	    GenSub(node@.child[1]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    node@.width = 1;
	    if node@.op == AEQ then
		Print("\t%N = icmp eq %0T %0N, %1N\n", node);
	    else
		Print("\t%N = icmp ne %0T %0N, %1N\n", node);
	    return true;
	}
	else
	{
	    node@.child[0] = ast.Cast(node@.child[0], puinttype[i]);
	    node@.child[0]@.width = puinttype[i]@.base@.width;
	    node@.child[1] = ast.Cast(node@.child[1], puinttype[i]);
	    node@.child[1]@.width = puinttype[i]@.base@.width;
	    GenSub(node@.child[0]);
	    GenSub(node@.child[1]);
	    if size > 1 then
		node@.child[2] = ast.New2(DIV, type.wordtype,
				 node@.child[2],
				 ast.Const(type.wordtype, size));
	    // LLVM wants count to be register width
	    node@.child[2] = ast.ExtendT(node@.child[2], type.wordtype);
	    GenSub(node@.child[2]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    node@.width = 1;
	    Print("\t%N = call i1 @memcmp%0*B(%0T %0N, %1T %1N, %2T %2N)\n", node);
	    UseIntrinsic(MEMCMP, size, puinttype[i]);
	    if node@.op == ANE then     // ugly invert in place
	    {   node@.child[0].seqno = node@.seqno;
		node@.seqno = Tseqno;  Tseqno += 1;
		Print("\t%N = xor i1 %0N, true\n", node);
	    }
	}
	return false;
    }

    proc ZLen(node: Ast)
    {   var align: _uint;
	var t, at, bt: Type;

//err.str("ZLen:\n");
//ast.Dump(node);
	at = node@.child[0]@.type@.base;    // assert at@.kind == ARRAY
	bt = at@.base;			    // base type of array
	t = type.Clone(bt);
	t@.align = at@.align;
	t = type.MakeRef(t);
//err.str("at="); type.DumpT(at, true);  err.nl();
//err.str("bt="); type.DumpT(bt, true);  err.nl();
//err.str("t="); type.DumpT(t, true);  err.nl();
	node@.child[0]= ast.Cast(node@.child[0], t);
	GenSub(node@.child[0]);
	node@.child[0]@.type = t;
	align = _uint(node@.child[1]@.valu);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = call %T @memlen%0*A(%0T %0N)\n", node);
	UseIntrinsic(ZLEN, align, t);
    }

    proc UnaryOp(node: Ast): boolean
    {
	GenSub(node@.child[0]);
	node@.seqno = Tseqno;  Tseqno += 1;
	if node@.op
	is NOT then
	    Print("\t%N = xor %0T %0N, -1", node);
	is NEG then
	    Print("\t%N = sub %0T 0, %0N", node);
	is FNEG then
	    Print("\t%N = fsub %0T 0.0, %0N", node);
	is FCVTL then
	    Print("\t%N = fpext %0T %0N to %T", node);
	is FCVTS then
	    Print("\t%N = fptrunc %0T %0N to %T", node);
	is CVTUF then
	    Print("\t%N = uitofp %0T %0N to %T", node);
	is CVTIF then
	    Print("\t%N = sitofp %0T %0N to %T", node);
	is CVTFU then
	    Print("\t%N = fptoui %0T %0N to %T", node);
	is CVTFI then
	    Print("\t%N = fptosi %0T %0N to %T", node);
	is REVB then
	{   Print("\t%N = call %T @llvm.bswap.%T(%T %0N)", node);
	    UseIntrinsic(BSWAP, node@.width/Target@.membits, node@.type);
	}
	is CLZ then
	{   Print("\t%N = call %T @llvm.ctlz.%T(%0T %0N, i1 false)", node);
	    UseIntrinsic(CLZ, node@.width/Target@.membits, node@.type);
	}
	is CLZNZ then
	{   Print("\t%N = call %T @llvm.ctlz.%T(%0T %0N, i1 true)", node);
	    UseIntrinsic(CLZ, node@.width/Target@.membits, node@.type);
	}
	is CTZ then
	{   Print("\t%N = call %T @llvm.cttz.%T(%0T %0N, i1 false)", node);
	    UseIntrinsic(CTZ, node@.width/Target@.membits, node@.type);
	}
	is CTZNZ then
	{   Print("\t%N = call %T @llvm.cttz.%T(%0T %0N, i1 true)", node);
	    UseIntrinsic(CTZ, node@.width/Target@.membits, node@.type);
	}
	is POP then
	{   Print("\t%N = call %T @llvm.ctpop.%T(%0T %0N)", node);
	    UseIntrinsic(POP, node@.width/Target@.membits, node@.type);
	}
	PEndLine(node);
	return false;
	
    }

    proc PStringCon(node: Ast)
    {   var n: StringRange;
    
	if node == 0 then
	    f.str("\"\"");
	else
	{   n = StringRange(zstr.len(node@.symb@.ident, lex.StringMax));
	    PString(node@.symb@.ident, n, false);
	}
    }
	    
    proc GetRV(node: Ast)
    {   var tl: type.TypeList;
	var ps: Symb;

	if node@.valu == 0 then
	    GenSub(node@.child[0]);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = extractvalue ", node);
	ps = node@.child[0]@.symb;
	if ps != 0 then
	    tl = ps@.retvlist;
	else
	    tl = type.TypeList(node@.child[0]@.type);	// hack
	PRetvType(tl, false);
	Print(" %0N, ", node);
	f.uint32(_uint32(node@.valu));
	f.nl();
    }

    // FIXME: re-factor to merge stuff with Call()
    proc Asm(node: Ast)
    {	var i: ast.NSubNodes;

	i = 2;
	while i < node@.num do
	{   GenSub(node@.child[i]);
	    i += 1;
	}
	f.chr('\t');
	if node@.type != 0 then		// has return value
	{   node@.seqno = Tseqno;  Tseqno += 1;
	    Print("%N = ", node);
	}
	f.str("call");
	PRetvType(type.TypeList(node@.type), false);
	f.str(" asm sideeffect ");
	PStringCon(node@.child[0]);
	f.str(", ");
	PStringCon(node@.child[1]);
	f.str(" (");
	i = 2;
	if node@.num > i then
	{   loop
	    {
		Print("%T %N", node@.child[i]);
		i += 1;
	      exit i >= node@.num;
		f.str(", ");
	    }
	}
	f.str(")\n");
    }

    // Declare parameter types and return value types
    proc DclParmRetv(ps: Symb)
    {   var tl: type.TypeList;
        var s: Symb;

	s = ps@.parmlist;
	while s != 0 do
	{   DclType(s@.type);
	    s = s@.next;
	}
	tl = ps@.retvlist;
	while tl != 0 do
	{   DclType(tl@.type);
	    tl = tl@.next;
	}
    }

    proc Call(node: Ast, indirect:boolean)
    {	var i: ast.NSubNodes;

	i = 0;
	while i < node@.num do
	{   GenSub(node@.child[i]);
	    i += 1;
	}
	f.chr('\t');
	if node@.type != 0 && node@.type@.kind != UTYPE then // has return value
	{   node@.seqno = Tseqno;  Tseqno += 1;
	    Print("%N = ", node);
	}
	if feature.tcall then f.str("tail ");
	f.str("call");
	PRetvType(node@.symb@.retvlist, false);
	if indirect then
	{   Print(" %0N(", node);
	    i = 1;	// actuals start here
	}
	else
	{   Print(" %I(", node);
	    i = 0;	// all children are actuals
	}
	if node@.num > i then
	{   loop
	    {
		Print("%T %N", node@.child[i]);
		i += 1;
	      exit i >= node@.num;
		f.str(", ");
	    }
	}
	f.str(")\n");
	if node@.symb@.forward then
	    lex.ErrorI(FORWPROC, node@.symb@.ident);
    }

    // Search AST of a procedure for
    // 1. DCLVAR so types can be pre-declared and externs/globals declared
    // 2. DCLCON so they can be declared
    // 3. SCON,CLIST so they can be declared
    // 4. CALL of external so parm and retv types can be pre-declared
    // 5. Operators that must be expanded because of lack of LLVM support.
    proc DclProcSearch(node: Ast)
    {   var i: ast.NSubNodes;
	var lhs, rhs: Ast;
	var s: Symb;
	var op: ast.Op;

	if node != 0 then
	{   if node@.op
	    is DCLVAR then
	    {   s = node@.symb;
	        DclType(s@.type);
		if s@.linkage != LOCAL then
		{   DclVar(node);
		    node@.op = NULL;
		}
		return;
	    }
	    is DCLCON then
	    {   s = node@.symb;
		if s != 0 then
		{   s@.linkage = NORMAL;	// promote linkage
		    DclCon(node);
		}
		node@.op = NULL;		// ignore for code generation
		return;
	    }
	    is SCON then
	    {   DclString(node);
		return;
	    }
	    is CLIST then
	    {   DclAggregate(node);
		return;
	    }
	    is CALL then
	    {   var ps: Symb;
		ps = node@.symb;
		if ps@.linkage == EXTERN && !ps@.declared then
		{   DclParmRetv(ps);
		    DclProc(node, false);
		    f.chr('\n');
		    ps@.declared = true;
		}
	    }
	    is ABS then			    // must convert
	    {   rhs = node@.child[0];
		lhs = ast.New1(NEG, rhs@.type, rhs);
		node@.child[0] = ast.New2(SLT, type.booltype, rhs,
				ast.Const(rhs@.type, 0));
		node = ast.Child(node, lhs);    // must return same node
		node = ast.Child(node, rhs);    // must return same node
		node@.op = IFEXPR;
	    }
	    is UMIN, UMAX, SMIN, SMAX then  // must convert
	    {   lhs = node@.child[0];
		rhs = node@.child[1];
		if node@.op
		is SMIN then op = SLT;
		is SMAX then op = SGT;
		is UMIN then op = ULT;
		is UMAX then op = UGT;
		node@.child[0] = ast.New2(op, type.booltype, lhs, rhs);
		node@.child[1] = lhs;
		node = ast.Child(node, rhs);    // must return same node
		node@.op = IFEXPR;
	    }
	    is ASM then return;     // ignore SCONs under an ASM
	    i = 0;
	    while i < node@.num do
	    {   DclProcSearch(node@.child[i]);
		i += 1;
	    }
	}
    }

    proc Procedure(node: Ast)
    {   var s, ps: Symb;
	var tl: type.TypeList;
	var i: ast.NSubNodes;

	ps = node@.symb;
	if ps != 0 then
	{   DclParmRetv(ps);    // declare parameter and retv types
	    // Make sure any local variables have type declared
	    // and DCLCONs are moved outside
	    DclProcSearch(node@.child[0]);
	    // Now declare the procedure with its parameters
	    DclProc(node, true);
	    if ps@.linkage
	    is INLINE then f.str(" alwaysinline");
	    is NOINLINE then f.str(" noinline");
	    if feature.size != NO then
	    {   if feature.size == MIN then
		    f.str(" minsize");
		f.str(" optsize");
	    }
	    f.str(" nounwind");
	    Section(ps@.section, false);
	    f.str(" {\n");
	    Pseqno += 1;
	    Tseqno = 1;
	    Lseqno = 0;
	    Label(Lseqno);  Lseqno += 1;
	    // allocate returned values
	    tl = ps@.retvlist;
	    i = 0;
	    while tl != 0 do
	    {   f.chr('\t');
		PRetValName(i);
		f.str(" = alloca ");
		PType(tl@.type);
		f.nl();
		i += 1;
		tl = tl@.next;
	    }
	    // allocate parameters
	    s = ps@.parmlist;
	    while s != 0 do
	    {   f.str("\t%"); f.str(s@.ident);
		f.str(" = alloca ");
		PType(s@.type);
		f.nl();
		s = s@.next;
	    }
	    s = ps@.parmlist;
	    while s != 0 do
	    {
		f.str("\tstore ");
		PType(s@.type);
		f.str(" %");
		f.str(s@.ident);
		f.str("$, ");
		PType(s@.type);
		f.str("* %");
		f.str(s@.ident);
		f.nl();
		if feature.gflag then llvmdb.DefVar(s);
		s = s@.next;
	    }
	    if !GenSub(node@.child[0]) then
	    {   f.str("\tbr label %return");
		PEndLine(node);
	    }
	    f.str("return:\n");
	    tl = ps@.retvlist;
	    if tl != 0 then
	    {   // load up returned values
		i = 0;
		while tl != 0 do
		{   f.chr('\t');
		    PTempName(Tseqno+i);
		    f.str(" = load ");
		    PType(tl@.type);
		    f.str("* ");
		    PRetValName(i);
//		    PEndLine(node);	//FIXME: wrong line number
		    f.nl();
		    i += 1;
		    tl = tl@.next;
		}
		tl = ps@.retvlist;
		i = 0;
		if tl@.next != 0 then   // multiple returned values
		{   // first, must insert each value into aggregate
		    loop
		    {   f.str("\t%mrv"); f.uint(i);
			f.str(" = insertvalue");
			PRetvType(ps@.retvlist, false);
			if i == 0 then
			    f.str(" undef");
			else
			{   f.str(" %mrv"); f.uint(i-1);
			}
			f.chr(',');
			PType(tl@.type);
			f.chr(' ');
			PTempName(Tseqno+i);
			f.chr(',');
			f.uint(i);
			f.nl();
			i += 1;
			tl = tl@.next;
		      exit tl == 0;
		    }
		    // finally return the aggregate
		    f.str("\tret ");
		    PRetvType(ps@.retvlist, false);
		    f.str(" %mrv"); f.uint(i-1);
		    f.nl();
		}
		else		    // only one returned value
		{   f.str("\tret ");
		    PType(tl@.type);
		    f.chr(' ');
		    PTempName(Tseqno+i);
		}
	    }
	    else
		f.str("\tret void");
	    f.str("\n}\n");
	}
    }

    proc BinaryOp(node: Ast, op: @[]Char): boolean
    {

	GenSub(node@.child[0]);
	GenSub(node@.child[1]);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = ", node);
	f.str(op);
	Print(" %T %0N, %1N", node);
	PEndLine(node);
	return false;
    }

    proc SignedBinaryOp(node: Ast, uop: @[]Char, sop: @[]Char): boolean
    {
        if node@.type@.kind == SINT then
	    return BinaryOp(node, sop);
	else
	    return BinaryOp(node, uop);
    }

    proc CompareOp(node: Ast, op: @[]Char): boolean
    {

	GenSub(node@.child[0]);
	GenSub(node@.child[1]);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = ", node);
	f.str(op);
	Print(" %0T %0N, %1N", node);
	PEndLine(node);
	return true;
    }

    proc ChangeSize(node: Ast, op: @[]Char)
    {
	GenSub(node@.child[0]);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = ", node);
	f.str(op);
	Print(" %0T %0N to %T", node);
	PEndLine(node);
    }

    proc IsPacked(node: Ast): boolean
    {
	if node@.type@.kind != REF then
	    return node@.type@.packed;
	else
	    return node@.type@.base@.packed;
    }

    proc BitfieldOffset(node: Ast, fno: type.Valu): type.BitSize
    {   var foffs, rsize, fsize: type.BitSize;
	var s: Symb;
	var i: ast.NSubNodes;
	var t: Type;

        t = node@.type;
        if t@.kind == REF then t = t@.base;
	// assert t@.kind == RECORD
	rsize = t@.width;
	if t@.bitorder == MSB then foffs = rsize; else foffs = 0;
	s = t@.list;
	i = 0;
	while s != 0 do
	{   fsize = s@.type@.size;
	    if t@.bitorder == MSB then foffs -= fsize;
	  exit i == fno;
	    if t@.bitorder != MSB then foffs += fsize;
	    s = s@.next;
	    i += 1;
	}
	return foffs;
    }

    proc BitfieldIndex(node: Ast, size: type.BitSize, tree: Ast): Ast
    {   var indx: Ast;

	// FIXME: what about bitorder?
	indx = ast.ExtendT(node@.child[1], type.wordtype);
	indx = ast.New2(MUL, type.wordtype, indx,
                        ast.Const(type.wordtype, size));
	if tree != 0 then
	    tree = ast.New2(ADD, type.wordtype, tree, indx);
	else
	    tree = indx;
	return tree;
    }

    proc BitfieldRewrite(offs: Ast): Ast, Ast, Ast
    {   var varb, tree: Ast;
	var shft: type.BitSize;
	var t: Type;

	shft = 0;
	varb = 0;
	loop
	{   if offs@.op
	    is OFFSET then
		shft += BitfieldOffset(offs@.child[0], offs@.valu);
	    is INDEX then
		varb = BitfieldIndex(offs, offs@.type@.base@.size, varb);
	    is SLICE then
		varb = BitfieldIndex(offs, offs@.type@.base@.size, varb);
	    offs = offs@.child[0];
	  exit (offs@.op < OFFSET || offs@.op > SLICE) ||
	    !IsPacked(offs@.child[0]);
	}
	if shft != 0 then
	{   tree = ast.Const(type.wordtype, shft);
	    if varb != 0 then
		varb = ast.New2(ADD, type.wordtype, varb, tree);
	    else
		varb = tree;
	}
	t = offs@.type;
	if t@.kind != REF then
	{   // assert offs@.op == CONST
	    tree = offs;
	    tree@.type = type.wordtype;
	    tree@.width = type.wordtype@.width;
	}
	else
	{   t = t@.base;
	    // load the container of the bitfield as a UINT
	    tree = ast.New1(LOAD, target.utype(t@.width), offs);
	    tree@.width = tree@.type@.width;
	    // make sure the endian is correct
	    if tree@.width > Target.membits && 
	       t@.memorder != Target.memorder then
		tree = ast.New1(REVB, tree@.type, tree);
	}
	// make register sized, this simplifies things
	tree = ast.ExtendT(tree, type.wordtype);
	return tree,    // return the loaded container,
	       varb,    // the shift computation,
	       offs;    // and the base address 
    }

    proc BitfieldMask(node: Ast): Ast
    {   var mask: Ast;
	var bits: type.Valu;
	var size: type.BitSize;

	if node@.op == SLICE then
	{   if node@.child[2]@.op != CONST then
	    {
		lex.ErrorS(COMPILER, "BitfieldMask of variable SLICE");
	    }
	    else
	    {   size = node@.type@.base@.size;
		size = size * type.BitSize(node@.child[2]@.valu);
	    }
	}
	else
	    size = node@.type@.base.size;
	bits = (1<<size)-1;
	mask = ast.Const(type.wordtype, bits);
	return mask;
    }

    proc LoadPacked(load: Ast, offs: Ast)
    {   var tree, varb, mask: Ast;

	{   // We are dealing with a packed record or array (aka bitfield).
	    mask = BitfieldMask(offs);
	    // Rewrite the AST to extract item.
	    tree, varb, offs = BitfieldRewrite(offs);
	    // shift item rightward, if necessary
	    if varb != 0 then
		tree = ast.New2(LSR, type.wordtype, tree, varb);
	    // mask off the parts we don't want
	    tree = ast.New2(AND, type.wordtype, tree, mask);
	    // possibly narrow the size
	    tree = ast.Extend(tree, load@.width, true);
	    GenSub(tree);
	    load@.child[0] = tree;      // load@.op == LOAD, we're done with it
	    load@.seqno = tree@.seqno;  // copy up seqno of node below
	}
    }
	
    proc Load(load: Ast)
    {   var offs: Ast;

	// LLVM doesn't handle bitfields (packed records or arrays)
	// so we expand bitfield extract
	offs = load@.child[0];
	if (offs@.op >= OFFSET && offs@.op <= SLICE) &&
	    IsPacked(offs@.child[0]) then
		LoadPacked(load, offs);
	else    // normal load
	{   GenSub(offs);
	    load@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = load ", load);
	    if offs@.type@.base@.input then
		f.str("volatile ");
	    Print("%T* %0N", load);
	    if offs@.type@.base@.unalgn then
	    {   f.str(", align ");
		f.uint64(offs@.type@.base@.align/Target.membits);
	    }
	    PEndLine(load);
	}
    }

    proc Store(store: Ast)
    {   var rhs, lhs, varb, tree, mask: Ast;
	var i, n: ast.NSubNodes;

	i = 0;
	n = store@.num / 2;
	while i < n do
	{   lhs = store@.child[i];
	    rhs = store@.child[n+i];
	    // LLVM doesn't handle bitfields (packed records or arrays)
	    // so we expand bitfield insert
	    if (lhs != 0 && lhs@.op >= OFFSET && lhs@.op <= SLICE) &&
		IsPacked(lhs@.child[0]) then
	    {   // We are dealing with a packed record or array (aka bitfield).
		mask = BitfieldMask(lhs);
		// Rewrite the AST to extract item.
		tree, varb, lhs = BitfieldRewrite(lhs);
		// shift the mask leftward, if necessary
		if varb != 0 then
		    mask = ast.New2(LSL, type.wordtype, mask, varb);
		mask = ast.New1(NOT, type.wordtype, mask);
		// mask out the field in the target
		tree = ast.New2(AND, type.wordtype, tree, mask);
		// make the value word size
		rhs = ast.ExtendT(rhs, type.wordtype);
		// shift the value leftward, if necessary
		if varb != 0 then
		    rhs  = ast.New2(LSL, type.wordtype, rhs, varb);
		// or in the new value
		rhs  = ast.New2(OR, type.wordtype, tree, rhs);
		// adjust width of final result
		rhs = ast.Extend(rhs, lhs@.type@.base@.width, true);
		// make sure the endian is correct
		if lhs@.width > Target.membits && 
		   lhs@.type@.memorder != Target.memorder then
		    rhs = ast.New1(REVB, rhs@.type, rhs);
		store@.child[i] = lhs;
		store@.child[n+i] = rhs;
	    }
	    GenSub(rhs);	// rhs first
	    i += 1;
	}
	i = 0;
	while i < n do
	{   lhs = store@.child[i];
	    rhs = store@.child[n+i];
	    if lhs != 0 then
	    {   GenSub(lhs);	// then lhs
		f.chr('\t');
		f.str("store ");
		if lhs@.type@.base@.output then
		    f.str("volatile ");
		NodeType(rhs); f.chr(' ');
		NodeSrc(rhs);
		Print(", %K %D", lhs);
		if lhs@.type@.base@.unalgn then
		{   f.str(", align ");
		    f.uint64(lhs@.type@.base@.align/Target.membits);
		}
		PEndLine(store);
	    }
	    i += 1;
	}
    }

    proc Return(node: Ast): boolean
    {   var i: ast.NSubNodes;
	var rnode: Ast;

	if node@.num > 0 then
	{   i = 0;
	    while i < node@.num do
	    {   rnode = node@.child[i];
		GenSub(rnode);
		Print("\tstore %T %N, %T* ", rnode);
		PRetValName(i);
		PEndLine(node);
		i += 1;
	    }
	    node@.seqno = node@.child[0]@.seqno;
	}
	f.str("\tbr label %return");
	PEndLine(node);
	return true;	// always terminates a block
    }

    proc IfExpr(node: Ast)
    {
	GenSub(node@.child[1]);
	GenSub(node@.child[2]);
	GenSub(node@.child[0]);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = select i1 %0N, %1T %1N, %2T %2N", node);
	PEndLine(node);
    }
	
    proc GenSub(node: Ast): boolean
    {   var term: boolean;	// basic block has been terminated

	term = false;
	if node == 0 then return term;
	if node@.seqno != 0 then return term;
	if node@.op
	is NOP then { GenSub(node@.child[0]); node@.seqno = node@.child[0]@.seqno; }
	is FILE then
	{   if feature.gflag then llvmdb.FileStart(node@.symb@);
	    GenSub(node@.child[0]);
	    if feature.gflag then llvmdb.FileFinish(node@.symb@);
	}
	is PACKAGE then
	{   if feature.gflag then llvmdb.PackageStart(node@.symb@.ident);
	    GenSub(node@.child[0]);
	    if feature.gflag then llvmdb.PackageEnd();
	}
	is PROC then
	{   if feature.gflag then llvmdb.ProcStart(node@.symb@);
	    Procedure(node);
	    if feature.gflag then llvmdb.ProcFinish(node@.symb@);
f.flush();
	}
	is DCLVAR then DclVar(node);
	is DCLCON then DclCon(node);
	is VAR, CONST, FCON, SCON, CLIST then {}
	is ACOPY then Copy(node);
	is AEQ, ANE then term = ArrayCompare(node);
	is SET then Set(node);
	is COPY then Copy(node);
	is RET then term = Return(node);
	is GETRV then GetRV(node);
	is STORE then Store(node);
	is LOAD  then Load(node);
	is BYREF then
	{   GenSub(node@.child[0]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = getelementptr %K %0N\n", node);
	}
	is OFFSET then
	{   GenSub(node@.child[0]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = getelementptr %0K %0N, %W 0, i32 ", node);
	    f.uint32(_uint32(node@.valu));
	    f.nl();
	}
	is INDEX then
	{   GenSub(node@.child[0]);
	    // LLVM wants index value to be register width
	    node@.child[1] = ast.ExtendT(node@.child[1], type.wordtype);
	    GenSub(node@.child[1]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = getelementptr %0K %0N, %W 0, %1T %1N\n", node);
	}
	is SLICE then
	{   var nextseqno: seqnoT;
	    // Treat this like an index followed by cast back to original type
	    // Ignore the count, for now
	    GenSub(node@.child[0]);
	    // LLVM wants index value to be register width
	    node@.child[1] = ast.ExtendT(node@.child[1], type.wordtype);
	    GenSub(node@.child[1]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    nextseqno = Tseqno; Tseqno += 1;
	    Print("\t%N = getelementptr %0T %0N, %W 0, %1T %1N\n", node);
	    f.chr('\t'); PTempName(nextseqno);
	    Print(" = bitcast %**K* %N to %T\n", node);
	    node@.seqno = nextseqno;
	}	
	is CAST then
	{   GenSub(node@.child[0]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    if node@.type@.kind == REF then
	    {   if node@.child[0]@.type@.kind == REF then
		    Print("\t%N = bitcast %0K %0N to %K\n", node);
		else
		    Print("\t%N = inttoptr %0T %0N to %T\n", node);
	    }
	    else
	    {   if node@.child[0]@.type@.kind == REF then
		    Print("\t%N = ptrtoint %0T %0N to %T\n", node);
		else
		    Print("\t%N = bitcast %0K %0N to %K\n", node);
	    }
	}	
	is ZEXT then  ChangeSize(node, "zext");
	is SEXT then  ChangeSize(node, "sext");
	is TRUNC then ChangeSize(node, "trunc");
	is REVB, NOT, NEG, FNEG, FCVTL, FCVTS, CVTUF, CVTIF, CVTFU, CVTFI then
	    UnaryOp(node);
	is CLZ, CLZNZ, CTZ, CTZNZ, POP then UnaryOp(node);
	is ZLEN then ZLen(node);
	is ADD then BinaryOp(node, "add");
	is SUB then BinaryOp(node, "sub");
	is MUL then BinaryOp(node, "mul");
	is DIV then SignedBinaryOp(node, "udiv", "sdiv");
	is MOD then SignedBinaryOp(node, "urem", "srem");
	is LSL, ASL then BinaryOp(node, "shl");
	is LSR then BinaryOp(node, "lshr");
	is ASR then BinaryOp(node, "ashr");
	is FADD then BinaryOp(node, "fadd");
	is FSUB then BinaryOp(node, "fsub");
	is FMUL then BinaryOp(node, "fmul");
	is FDIV then BinaryOp(node, "fdiv");
	is FREM then BinaryOp(node, "frem");
	is EQ then  term = CompareOp(node, "icmp eq");
	is NE then  term = CompareOp(node, "icmp ne");
	is UGT then term = CompareOp(node, "icmp ugt");
	is ULT then term = CompareOp(node, "icmp ult");
	is UGE then term = CompareOp(node, "icmp uge");
	is ULE then term = CompareOp(node, "icmp ule");
	is SGT then term = CompareOp(node, "icmp sgt");
	is SLT then term = CompareOp(node, "icmp slt");
	is SGE then term = CompareOp(node, "icmp sge");
	is SLE then term = CompareOp(node, "icmp sle");
	is AND then BinaryOp(node, "and");
	is OR then  BinaryOp(node, "or");
	is XOR then BinaryOp(node, "xor");
	is BNOT then
	{   GenSub(node@.child[0]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = xor i1 %0N, true\n", node);
	}
	is BOR then  term = Conditional(node, false);
	is BAND then term = Conditional(node, true);
	is IFEXPR then IfExpr(node);
	is CALL then  Call(node, false);
	is CALLI then Call(node, true);
	is ASM then Asm(node);
	is IF then   term = If(node);
	is SEL then  term = Select(node);
	is LOOP then term = Loop(node);
	is EXIT then term = Exit(node);
	is SEQ then
	{   var i: ast.NSubNodes;
	    i = 0;
	    while i < node@.num do
	    {   if term then
		{   // a block ends in a sequence, unreachable code
		    Label(Lseqno);  Lseqno += 1;
		    term = false;
		}
		term = GenSub(node@.child[i]);
		i += 1;
	    }
	}
	return term;
    }

    proc Gen(fd: file, tree: Ast)
    {   var i: 0..target.IntSizesMax;

	f = bout.buffer(fd, 4096);;
	// These pointer types might be useful to other packages.
	pbytetype = type.MakeRef(type.bytetype);
	i = 0;
	while i < Target.nisize do
	{   puinttype[i] = type.MakeRef(type.uinttypes[i]);
	    i += 1;
	}
	f.str("target datalayout = \"");
	if Target.memorder == BE then f.str("E"); else f.str("e");
	f.str("-p:");  f.uint(Target.ptr.size);
	f.str(":");    f.uint(Target.ptr.align);
	f.str(":");    f.uint(Target.ptr.align);
	f.str("-i1:"); f.uint(Target.isizes[0].align);
	f.str(":");    f.uint(Target.isizes[0].align);
	i = 0;
	while i < Target.nisize do
	{   f.str("-i"); f.uint(Target.isizes[i].size);
	    f.str(":");  f.uint(Target.isizes[i].align);
	    f.str(":");  f.uint(Target.isizes[i].align);
	    i += 1;
	}
	f.str("\"\ntarget triple = \"");
	f.str(target.Triple);
	f.str("\"\n");
	if feature.gflag then llvmdb.ProgStart(tree@.symb@, false);
	GenSub(tree);
	DeclareIntrinsics();
	if feature.gflag then llvmdb.ProgFinish();
	f.flush();
    }
}
// vim: ts=8 sw=4 noet nowrap

