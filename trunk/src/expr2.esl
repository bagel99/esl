// Copyright (c) 2009-2011, Brian G. Lucas.  See LICENSE file.
// $Id: expr2.esl 736 2012-10-25 20:22:41Z bgl $

package expr
{
    const skiplist:[4]TokenT = { PEND, GEND, SEMI, NONE };

    proc ForceBoolean(tree: Ast): Ast
    {
	if tree@.type != 0 && !type.Compat(tree@.type,type.booltype) then
	    lex.Error(WANTBOOL);
	if tree@.width > 1 then		// llvm wants a 1-bit boolean
	{   if tree@.op != CONST then
		tree = ast.New2(NE, type.booltype, tree, ast.Const(tree@.type, 0));
	    tree@.width = 1;
	}
	return tree;
    }

    const proplist:[]TokenT = { KMIN, KMAX, KBITSZ, KMEMSZ, KALIGN, KLEN, NONE };
    proc Property(node: Ast): Ast
    {   var tree: Ast;
	var t: Type;
	var tok: TokenT;

	tree = 0;
	t = node@.type;
	if node@.op
	is TYPE, CONST then ;  // ok
	is VAR  then { t = t@.base; if t == 0 then return 0; }
	else return 0;  // must be TYPE, CONST or VAR?
	tok = Token;
	if tok == ID then
	{   tok = lex.Keyword(proplist);
	    if tok
	    is KMIN then tree = ast.Const(t, t@.lo);
	    is KMAX then tree = ast.Const(t, t@.hi);
	    is KBITSZ then tree = ast.Const(type.wordtype, t@.size);
	    is KMEMSZ then tree = ast.Const(type.wordtype, t@.width/Target.membits);
	    is KALIGN then tree = ast.Const(type.wordtype, t@.align/Target.membits);
	    is KLEN then
	    {   if t@.kind == ARRAY then
		    tree = ast.Const(type.wordtype, t@.hi);
		else lex.Error(OPTYPE);
	    }
	    else lex.Error(PROPID);
	}
	else lex.Error(PROPID);
	tok = Next();
	return tree;					
    }

    var strid: Valu = 0;

    proc String(): Ast
    {   var tree: Ast;
	var t: Type;

	t = type.New(ARRAY);
	t@.base = type.bytetype;
	t@.index = type.wordtype;
	t@.lo = 0;
	t@.hi = lex.StringLen;
	t@.align = t@.base@.align;
	t@.memorder = Target.memorder;
	tree = ast.New(SCON, t);
	tree@.symb = Symb(sys.memdup(lex.StringBuf, lex.StringLen));
	strid += 1;
	tree@.valu = strid;
	return tree;
    }

    proc StringCat(tree: Ast): Ast
    {   var sr: _address;
	var t: Type;
	var nl, nr, i, j: _uint;

	// modify the ARRAY type
	t = tree@.type;     // assert t@.kind == ARRAY
	nl = t@.hi - 1;	    // LHS string length without nul termination
	nr = lex.StringLen; // RHS string length with nul termination
	t@.hi = nl+nr;
	// move RHS down in StringBuf, include nul termination
	// potential overlap, must do a reverse copy
	i = nr;
	loop
	{   lex.StringBuf[i+nl] = lex.StringBuf[i];
	  exit i == 0;
	    i -= 1;
	}
	// copy in LHS, symbol pointer actually points to LHS string
	sr = _address(tree@.symb);
	lex.StringBuf[0:nl] = sr[0:nl];
	// create a new string long enough
	tree@.symb = Symb(sys.memdup(lex.StringBuf, nl+nr));
	return tree;   
    }

    proc EnumConst(t: Type): Ast
    {   var s: Symb;
	var tree: Ast;

	// assert t@.kind == ENUM
	s = t@.list;
	while s != 0 do
	{   if zstr.eq(s@.ident, lex.Ident, lex.IdentMax) then
	    {   tree = ast.Dup(s@.const);
		tree@.width = s@.const@.type@.width;
		return tree;
	    }
	    s = s@.next;
	}
	lex.ErrorI(UNDEFID, lex.Ident);
	return 0;
    }

    proc CheckConstTruncate(node: Ast, size: type.BitSize)
    {
	// assert node@.op == CONST
	if size >= type.Valu?bits then return;
	if node@.type@.kind == SINT then
	{   if type.SValu(node@.valu) < 0 then
	    {   if type.SValu(node@.valu) >> (size+1) != -1 then
		    lex.Error(TRUNC);
	    }
	    else
	    {   if node@.valu >> (size+1) != 0 then
		    lex.Error(TRUNC);
	    }
	}
	else
	{   if node@.valu >> size != 0 then
		lex.Error(TRUNC);
	}
    }
	
    // FIXME: move to ast.esl
    proc Extend(tree: Ast, size: type.BitSize, iscast: boolean): Ast
    {
	if tree@.width < size then
	{   if tree@.op != CONST then
	    {   if tree@.type@.kind == SINT then
		    tree = ast.New1(SEXT, tree@.type, tree);
		else
		    tree = ast.New1(ZEXT, tree@.type, tree);
	    }
	    tree@.width = size;
	}
	else if tree@.width > size then
	{
	    if tree@.op != CONST then
	    {   tree = ast.New1(TRUNC, tree@.type, tree);
		if feature.trunc && !iscast then lex.Error(TRUNC);
	    }
	    else
		CheckConstTruncate(tree, size);
	    tree@.width = size;
	}
	return tree;
    }

    proc ExtendT(tree: Ast, t: Type): Ast
    {
	tree = Extend(tree, t@.width, false);
	tree@.type = t;
	return tree;
    }

    proc ExtendCast(tree: Ast, t: Type): Ast
    {
	tree = Extend(tree, t@.width, true);
	tree@.type = t;
	return tree;
    }

    proc Cast(tree: Ast, to: Type): Ast
    {
	if tree == 0 then return tree;
	if to@.kind
	is ENUM then
	{   if tree@.type@.kind == UINT then		// UINT -> ENUM
		tree = ExtendCast(tree, to);
	    else
		lex.Error(BADCAST);
	}
	is UINT then
	{   if tree@.type@.kind
	    is ENUM, UINT, SINT then		// ENUM|UINT|SINT -> UINT
		tree = ExtendCast(tree, to);
	    is REF then				// REF -> UINT
	    {   tree = ast.New1(CAST, to, tree);
		tree@.width = to@.size;	// FIXME: width?
	    }
	    is RECORD, ARRAY then		// PACKED -> UINT
	    {
		if tree@.type@.packed && tree@.width == to@.size then
		{   tree@.type = to;
		}
		else
		    lex.Error(BADCAST);
	    }
	    else
		lex.Error(BADCAST);
	}
	is SINT then
	{   if tree@.type@.kind
	    is UINT, SINT then			// UINT|SINT -> SINT
		tree = ExtendCast(tree, to);
	    else
		lex.Error(BADCAST);
	}
	is REF then
	{   if tree@.type@.kind
	    is REF then				// REF -> REF
	    {   tree = ast.New1(CAST, to, tree);
		tree@.width = Target.ptr.size;
	    }
	    is UINT then			// UINT -> REF
	    {   if tree@.width != Target.ptr.size then lex.Error(BADINTPTR);
		tree = ast.New1(CAST, to, tree);
		tree@.width = to@.size;	// FIXME: width?
	    }
	    is ARRAY then	// cast from slice of memory
	    {   if tree@.op == LOAD then
		    tree = tree@.child[0];	// undo load
		// Should check for large enough slice?
		if tree@.op == SLICE && tree@.type@.base@.base == type.bytetype then
		{   tree = ast.New1(CAST, to, tree);
		    tree@.width = to@.size;	// width?
		}
		else
		    lex.Error(BADCAST);
	    }
	    else
		lex.Error(BADCAST);
	}
	is RECORD, ARRAY then
	{   if to@.packed &&
	       tree@.type@.kind == UINT && tree@.width == to@.size then
	    {					// UINT -> PACKED
		tree@.type = to;
	    }
	    else
		lex.Error(BADCAST);
	}
	return tree;
    }

    proc IsAggregateConst(node: Ast): boolean
    {   var i: ast.NSubNodes;

//err.str("IsAggregateConst op="); err.str(ast.OpName[node@.op]); err.nl();
	if node@.op
	is SCON, CONST then return true;
	is VAR then return node@.symb@.kind == CONSTANT;
	is BYREF, CAST then return IsAggregateConst(node@.child[0]);
	is CLIST then
	{   i = 0;
	    while i < node@.num do
	    {   if !IsAggregateConst(node@.child[i]) then return false;
		i += 1;
	    }
	    return true;
	}
	return false;
    }

    proc CompositeNamedConstant(t: Type): Ast
    {   var cs: Symb;
	var ct: Type;
	var tree: Ast;
	var tok: TokenT;

        tree = 0;
	cs = symb.Find(lex.Ident);
	if cs != 0 then
	{   if cs@.kind == CONSTANT then
	    {   ct = cs@.type;
		if type.Compat(ct, t) then
		{   tree = cs@.const;
		    tree@.type = ct;
		}
		else lex.Error(BADCOMPV);
	    }
	    else lex.Error(EXPCONST);
	    tok = Next();
	}
	else lex.ErrorI(UNDEFID, lex.Ident);
	return tree;
    }

    proc ArrayPack(t:Type, intree:Ast): Ast
    {   var offs, tsize, fsize: type.BitSize;
	var i: ast.NSubNodes;
	var tree, vpart, node: Ast;
	var cpart, mask: type.Valu;
	var bt: Type;		// base type

	vpart = 0;
	cpart = 0;
	if intree@.op != CLIST then
	{   lex.ErrorS(COMPILER, "No CLIST for packed array");
	    return tree;
	}
	tsize = t@.width;
	bt = t@.base;
	fsize = bt@.size;
	mask = ((1 << fsize)-1);
	if t@.bitorder == MSB then offs = tsize; else offs = 0;
	i = 0;
	while i < intree@.num do
	{
	    if t@.bitorder == MSB then offs -= fsize;
	    node = intree@.child[i];
	    if node@.op == CONST then
	    {   CheckConstTruncate(node, fsize);
		cpart = cpart | ((node@.valu&mask) << offs);
	    }
	    else
	    {   node = expr.Extend(node, tsize, false);
		node = ast.New2(LSL, bt, node,
				ast.Const(type.wordtype, offs));
		if vpart == 0 then
		    vpart = node;
		else
		    vpart = ast.New2(OR, bt, vpart, node);
	    }
	    if t@.bitorder != MSB then offs += fsize;
	    i += 1;
	}
	tree = expr.Extend(ast.Const(type.wordtype, cpart), tsize, false);
	if vpart != 0 then
	    tree = ast.New2(OR, type.wordtype, tree, vpart);
	tree@.type = t;
	return tree;
    }

    proc ArrayFixFlex(bt: Type, len: _uint): Type
    {   var t: Type;

	t = type.Clone(bt);
	t@.flex = false;
	t@.hi = len;
	t@.size = 0;
	t@.width = 0;
	t@.final = false;
	type.Final(t);
	return t;
    }

    proc ArrayConst(t: Type): Ast
    {   var tree, stree: Ast;
	var i, j, m, n: ast.NSubNodes;	// what type should this be
	var tok: TokenT;
	var once: boolean;

	tree = 0;
	tok = Token;
	if tok == GBEG then
	{   tree = ast.New(CLIST, t);
	    strid += 1;
	    tree@.valu = strid;
	    once = false;
	    n = ast.NSubNodes(t@.hi);
	    if t@.flex then n = 0;
	    i = 0;
	    m = 0;
	    loop
	    {   j = i;  // for non-designated initializer
		tok = Next();
		if tok == ABEG then	// designated initializer
		{   tok = Next();
		    i = ast.NSubNodes(ConstValue(t@.index));
		    j = i;
		    if Token == RANGE then
		    {   tok = Next();
			j = ast.NSubNodes(ConstValue(t@.index));
		    }
		    tok = lex.Expect(AEND);
		    tok = lex.Expect(ASGN);
		}
		stree = Const(t@.base);
		if (n == 0 || j < n) && i <= j then	// still room
		{   while i <= j do
		    {   tree = ast.ChildIndexed(tree, i, stree);
		        i += 1;
		    }
		    if i > m then m = i;
		}
		else if !once then
		{   once = true;
		    lex.Error(INITHI);
		}
		tok = Token;
	      exit tok != COMMA;
	    }
	    tok = lex.Expect(GEND);
	    if t@.flex then	// flex array becomes a static array
		t = ArrayFixFlex(t, m);
	    // make sure all elements are initialized in gaps
	    i = 0;
	    while i < m do
	    {	if tree@.child[i] == 0 then
		    tree@.child[i] = ast.Const(t@.base, 0);
		i += 1;
	    }
	    // make sure all fields are initialized at end
	    while i < n do
	    {   tree = ast.ChildIndexed(tree, i, ast.Const(t@.base, 0));
		i += 1;
	    }
	    tree@.type = t;
	    if t@.packed then
		tree = ArrayPack(t, tree);
	    else
	    {   if !IsAggregateConst(tree) then
		    lex.Error(BADCONST);
	    }
	}
	else if tok == STR then
	{   tree = String();
	    tok = Next();
	}
	else if tok == ID then
	    tree = CompositeNamedConstant(t);
	else lex.ErrorT(EXPECT, GBEG);
	return tree;
    }

    proc RecordPack(t:Type, intree:Ast): Ast
    {   var offs, tsize, fsize: type.BitSize;
	var f: Symb;
	var i: ast.NSubNodes;
	var tree, vpart, node: Ast;
	var cpart, mask: type.Valu;
	var ft: Type;		// field type

	vpart = 0;
	cpart = 0;
	if intree@.op != CLIST then
	{   lex.ErrorS(COMPILER, "No CLIST for packed record");
	    return tree;
	}
	tsize = t@.width;
	f = t@.list;
	if t@.bitorder == MSB then offs = tsize; else offs = 0;
	i = 0;
	while f != 0 do
	{   if f@.type != 0 then
	    {   ft = f@.type;
		fsize = ft@.size;
		mask = ((1 << fsize)-1);
		if t@.bitorder == MSB then offs -= fsize;
		if i >= intree@.num then
		{   lex.ErrorS(COMPILER, "Malformed LIST for packed record");
		    return 0;
		}
		node = intree@.child[i];
		if node@.op == CONST then
		{   CheckConstTruncate(node, fsize);
		    cpart = cpart | ((node@.valu&mask) << offs);
		}
		else
		{   node = expr.Extend(node, tsize, false);
		    node = ast.New2(LSL, ft, node,
				    ast.Const(type.wordtype, offs));
		    if vpart == 0 then
			vpart = node;
		    else
			vpart = ast.New2(OR, ft, vpart, node);
		}
		if t@.bitorder != MSB then offs += fsize;
	    }
	    f = f@.next;
	    i += 1;
	}
	tree = expr.Extend(ast.Const(type.wordtype, cpart), tsize, false);
	if vpart != 0 then
	    tree = ast.New2(OR, type.wordtype, tree, vpart);
	tree@.type = t;
	return tree;
    }

    // Convert flex record to non-flex record
    proc RecordFixFlex(bt: Type, node: Ast): Type
    {   var t: Type;
	var s, ps, bs: Symb;

//err.str("Init flex record\n");
	t = type.Clone(bt);
	// copy all fields because we need the change the final one
	ps = 0;
	bs = bt@.list;
	while bs != 0 do
	{   s = symb.New(FIELD, bs@.ident, PRIVATE);
	    if ps != 0 then ps@.next = s; else t@.list = s;
	    ps = s;
	    s@.type = bs@.type;
	    bs = bs@.next;
	}
	// final field must be the flex, change its type
	ps@.type = node@.child[node@.num-1]@.type;
	// Recalculate size and width
	t@.size = 0;
	t@.width = 0;
	t@.final = false;
	type.Final(t);
	return t;
    }

    proc RecordConst(t: Type): Ast
    {   var tree, stree: Ast;
	var fs, ds: Symb;
	var ft: Type;
	var max: symb.OffsT;
	var tok: TokenT;
	var once: boolean;

	tree = 0;
	tok = Token;
	if tok == GBEG then
	{   tree = ast.New(CLIST, t);
	    strid += 1;
	    tree@.valu = strid;
	    once = false;
	    max = 0;
	    fs = t@.list;
	    loop
	    {   
		tok = Next();
		if tok == DOT then	// designated initializer
		{   tok = Next();
		    if tok == ID then
		    {   ds = symb.FindLocal(t@.list, lex.Ident);
			if ds != 0 then
			    fs = ds;
			else
			    lex.ErrorI(UNDEFID, lex.Ident);
			tok = Next();
		    }
		    else
			lex.Error(EXPECTID);
		    tok = lex.Expect(ASGN);
		}
		else		// sequential initializer
		{   while fs != 0 && fs.ispad do    // skip padding
			fs = fs@.next;
		}
		ft = 0;
		if fs != 0 then ft = fs@.type;
		stree = Const(ft);
		if fs != 0 then
		{   tree = ast.ChildIndexed(tree, fs@.addr, stree);
		    if fs@.addr > max then max = fs@.addr;
		    fs = fs@.next;
		}
		else if !once then
		{   once = true;
		    lex.Error(INITHI);
		}
		tok = Token;
	      exit tok != COMMA;
	    }
	    tok = lex.Expect(GEND);
	    // make sure all fields are initialized in gaps
	    fs = t@.list;
	    while fs != 0 && fs@.addr <= max do
	    {	if tree@.child[fs@.addr] == 0 then
		    tree@.child[fs@.addr] = ast.Const(fs@.type, 0);
		fs = fs@.next;
	    }
	    // make sure all fields are initialized at end
	    while fs != 0 do
	    {   tree = ast.ChildIndexed(tree, fs@.addr, ast.Const(fs@.type, 0));
		fs = fs@.next;
	    }
	    if t@.flex then
		tree@.type = RecordFixFlex(t, tree);
	    if t@.packed then
		tree = RecordPack(t, tree);
	    else
	    {   if !IsAggregateConst(tree) then
		    lex.Error(BADCONST);
	    }
	}
	else if tok == ID then
	    tree = CompositeNamedConstant(t);
	else lex.ErrorT(EXPECT, GBEG);
	return tree;
    }

    proc CompositeValue(t: Type): Ast
    {   var tree: Ast;

	tree = 0;
	if t != 0 then
	{   if t@.kind
	    is RECORD then tree = RecordConst(t);
	    is ARRAY  then tree = ArrayConst(t);
	    is REF then tree = CompositeValue(t@.base);
	    else lex.Error(BADCOMPV);
	}
	else lex.Error(UNDFCOMPV);
	return tree;
    }

    proc CalcAlign(base: _uint, offset: _uint): _uint
    {   var new, tz: _uint;


//err.str("CalcAlign: base="); err.uint(base);
//err.str(" offset="); err.uint(offset);
	if offset == 0 then
	    new = base;
	else
	{   tz = 0;
	    while offset&1 == 0 do	// count trailing zeros
	    {   offset = offset >> 1;
		tz += 1;
	    }
	    new = 1 << tz;
	    new = _min(base, new);      // can't be greater than base
	}
//err.str(" new="); err.uint(new); err.nl();
	return new;
    }

    proc FieldAlign(base: _uint, record: Type, fieldno: _uint): _uint
    {   var offs, i: _uint;
	var s: Symb;

	if record@.kind != RECORD then return 0;	// can't happen?
//err.str("FieldAlign: base="); err.uint(base);
//err.str(" fieldno="); err.uint(fieldno);
	offs = 0;
	i = 0;
	s = record@.list;
	while i < fieldno && s != 0 do
	{   if record@.packed then
		offs += s@.type@.size;
	    else
		offs += s@.type@.width / Target.membits;
	    i += 1;
	    s = s@.next;
	}
//err.str(" offs="); err.uint(offs); err.nl();
	return CalcAlign(base, offs);
    }

    proc GetAlignment(tree:Ast): _uint
    {   var alignment: _uint;

	if tree == 0 then return 0;
//err.str("GetAlignment op="); err.str(ast.OpName[tree@.op]); err.nl();
	if tree@.op
	is VAR then 		// direct variable, use its alignment
	{   if tree@.type != 0 then
		alignment = tree@.type@.base@.align/Target.membits;
	    else
		alignment = 0;
	}
	is LOAD then 		// via a pointer
	{   if tree@.type@.kind == REF && tree@.type != 0 then
		alignment = tree@.type@.base@.align/Target.membits;
	    else
		alignment = 0;
	}
	is REVB, BYREF then
	    alignment = GetAlignment(tree@.child[0]);
	is OFFSET then 		// fixed offset
	{   alignment = GetAlignment(tree@.child[0]);
//err.str("GetAlignment OFFSET initial align="); err.uint(alignment); err.nl();
	    if alignment != 0 then
		alignment = FieldAlign(alignment, 
				       tree@.child[0]@.type@.base, _uint(tree@.valu));
	}
	is INDEX, SLICE then 	// possible variable offset
	{   alignment = GetAlignment(tree@.child[0]);
//err.str("GetAlignment INDEX/SLICE initial align="); err.uint(alignment); err.nl();
	    if alignment != 0 then
	    {   if tree@.child[1]@.op == CONST then
	        {
		    var size: _uint;
		    size = tree@.child[0]@.type@.base@.base@.width/Target.membits;
//err.str("\tsize="); err.uint(size); err.nl();
//err.str("\tindex="); err.uint(_uint(tree@.child[1]@.valu)); err.nl();
		    alignment = CalcAlign(alignment,
			_uint(tree@.child[1]@.valu)*size);
		}
		else
		    alignment = 0;
	    }
	}
	is CLIST, SCON then	// constant aggregate
	    alignment = tree@.type@.align;
	else
	{   lex.ErrorS(NOTIMPL, "GetAlignment: unexpected node");
	    ast.Dump(tree);
	}
//err.str("GetAlignment: final align="); err.uint(alignment); err.nl();
	return alignment;
    }

    proc GetOffset(node: Ast): Ast
    {   var tree, ctree: Ast;

	tree = 0;
	if node@.op
	is OFFSET then
	{   var f: Symb;    // field symbol
	    var n, offset: _uint;   // field index
	    ctree = GetOffset(node@.child[0]);
	    // assert node@.child[0]@.type@.base@.kind == RECORD
	    offset = 0;
	    n = 0;
	    f = node@.child[0]@.type@.base@.list;
	    while f != 0 && n < node@.valu do
	    {   offset += f@.type@.width / Target.membits;
		f = f@.next;
		n += 1;
	    }
	    tree = ast.Const(type.wordtype, offset);		
	}   
	is INDEX then
	{
	    ctree = GetOffset(node@.child[0]);
	    // assert node@.child[0]@.type@.base@.kind == ARRAY
	    tree = ast.Const(type.wordtype,
		node@.child[0]@.type@.base@.base@.width / Target.membits);
	    tree = ast.New2(MUL, type.wordtype,
		ExtendT(node@.child[1], type.wordtype), tree); 
	}
	if tree != 0 && ctree != 0 then
	    tree = ast.New2(ADD, type.wordtype, tree, ctree);
//err.str("GetOffset: final="); err.uint(offset); err.nl();
	return tree;
    }

    proc Slice(array: Ast, inx: Ast, len: Ast): Ast
    {   var at, st: Type;
	var tree: Ast;
	var blen, slen: type.BitSize;

	at = array@.type@.base;
	st = type.New(ARRAY);       // FIXME: use Clone()?
	st@.base = at@.base;
	st@.packed = at@.packed;
	st@.memorder = at@.memorder;
	blen = 0;
	slen = 0;
	if !at@.flex then blen = type.BitSize(at@.hi);
	if len != 0 then
	{   if len@.op == CONST then slen = type.BitSize(len@.valu);
	}
	else
	    len = ast.Const(type.wordtype, 0);  // stop error propagation
	if blen == 0 && slen == 0 then
	    st@.flex = true;
	else
	{   if slen == 0 then
	    {	slen = blen;	// worst case
		if inx@.op == CONST then
		    slen = blen - type.BitSize(inx@.valu);
	    }
	    else
	    {   // check slen < blen unless olen == 0
	    }
	    st@.hi = slen;
	}
	st@.size = at@.base@.size * slen;
	st@.width = st@.size;
	if inx != 0 then
	{   if inx@.op == CONST then
	    {   var offs: _uint;
		offs = _uint(inx@.valu) * (at@.base@.width/Target.membits);
		st@.align = CalcAlign(at@.align/Target.membits, offs) *
		    Target.membits;
	    }
	    else    // Just take the alignment of the base type.
		st@.align = at@.base@.align;
	}
	else
	    inx = ast.Const(type.wordtype, 0);  // stop error propagation
	tree = ast.New2(SLICE, type.MakeRef(st), array, inx);
	tree = ast.Child(tree, len);
	return tree;
    }

    proc Load(tree: Ast): Ast
    {   var t: Type;

	if tree == 0 then return tree;
//err.str("Load: "); ast.Print(tree);
	if tree@.op
	is TYPE then
	{   lex.ErrorI(BADTYPE, tree@.type@.name@.ident);
	    tree = 0;
	}
	is VAR, INDEX, OFFSET, SLICE, LOAD then
	{   t = tree@.type;
	    if t@.kind != REF then
	    {   lex.ErrorS(COMPILER, "Load via non-REF");
ast.Dump(tree);
		return 0;
	    }
	    t = t@.base;
	    if t != 0 then
	    {   tree = ast.New1(LOAD, t, tree);
		tree@.width = t@.width;
	    }
	    else lex.Error(BADREF);
	}
	is CONST then   // FIXME: merge with above?
	{   t = tree@.type;
	    if t@.kind == REF then
	    {   t = t@.base;
		if t != 0 then
		{   tree = ast.New1(LOAD, t, tree);
		    tree@.width = t@.width;
		}
		else lex.Error(BADREF);
	    }
	}
	return tree;
    }

    proc CoerceToRef(tree: Ast): Ast
    {
	if tree@.op == LOAD then
	    tree = tree@.child[0];		// undo the load
	else if tree@.op == REVB && tree@.child[0]@.op == LOAD then
	    tree = tree@.child[0]@.child[0];
	// FIXME: this is very likely wrong
	if tree@.op
	is SCON, CLIST then
	    tree = ast.New1(BYREF, type.MakeRef(tree@.type), tree);
	is VAR then
	    {}
	else
	    tree = ast.New1(BYREF, tree@.type, tree);
	return tree;
    }

    proc CheckRefAttributes(to: Type, fm: Type): boolean
    {
	if to == 0 || fm == 0 then return false;
	// Check endian
	if to@.memorder != fm@.memorder then
	    return false;
	// Check alignment
	if to@.align > fm.align then
	    return false;
	if to@.kind == REF && fm@.kind == REF then
	    return CheckRefAttributes(to@.base, fm@.base);
	return true;
    }

    proc Actual(tree: Ast, to: Type): Ast
    {   var fm, bt: Type;
	var ok: boolean;

	if tree == 0 then
	{   tree = Bool(to);
	    if tree == 0 then	// invalid expression
		return tree;
	}
	fm = tree@.type;
	if fm == 0 then		// undefined type
	    return tree;
	ok = true;
	if to@.kind
	is REF then
	{   if to@.base != 0 then
	    {   if fm@.kind == REF && type.Compat(to, fm) then
		{   if fm != to then
		    {   tree = expr.Cast(tree, to);
			fm = tree@.type;
		    }
		}
		else
		{   tree = CoerceToRef(tree);
		    fm = tree@.type;
		    // Coerce to REF memtype is always OK
		    if to@.base == type.memtype || type.Compat(to, fm) then
		    {   if fm != to then
			{   tree = expr.Cast(tree, to);
			    fm = tree@.type;
			}
		    }
		    else ok = false;
		}
		// Fix types when formal is a flex
		if to@.flex && !fm@.flex then
		    tree = ast.New1(CAST, to, tree);
		// Check attributes
		if !CheckRefAttributes(to, fm) then
		    lex.ErrorS(NOTIMPL, "Ref alignment or endian mismatch\n");
	    }
	    else
	    {   lex.Error(BADREF);
		ok = false;
	    }
	}
	is REFPROC then
	{   ok = type.Compat(to, fm);
	}
	is ENUM, UINT, SINT then
	{   ok = type.Compat(fm, to);
	    if to@.width != tree@.width then
		tree = ExtendT(tree, to);
	    // NeedSwap?
	}
	is RECORD, ARRAY then ok = type.Compat(fm, to);
	if !ok then
	{   lex.Error(PARMTYPE);
//err.str("to=\n"); type.DumpT(to, true); err.nl();
//err.str("fm=\n"); type.DumpT(fm, true); err.nl();
	}
	return tree;
    }

    proc UnOp(op:ast.Op, rhs:Ast): Ast
    {   var tree: Ast;

	if rhs@.op == CONST then	// constant folding
	{   tree = rhs;			// assume nop
	    if op
	    is NEG  then tree@.valu = type.Valu(-tree@.valu);
	    is NOT  then tree@.valu = ~tree@.valu;
	    is BNOT then tree@.valu = tree@.valu ^ 1;
	    is ABS  then 
	    {   if tree@.type@.kind == SINT && type.SValu(tree@.valu) < 0 then
		    tree@.valu = type.Valu(-type.SValu(tree@.valu));
	    }
	}
	else
	    tree = ast.New1(op, rhs@.type, rhs);
	return tree; 
    }

    proc IsSignedBinOp(lhs: Ast, rhs: Ast): boolean
    {
	if lhs@.type@.kind == SINT || rhs@.type@.kind == SINT then
	    return true;
	return false;
    }

    proc BinOp(op:ast.Op, lhs:Ast, rhs:Ast): Ast
    {   var tree: Ast;
	var sl, sr: type.BitSize;
	var fold, swap: boolean;

	if lhs@.op == TYPE then
	{   lex.ErrorI(BADTYPE, lhs@.type@.name@.ident);
	    return 0;
	}
	if rhs@.op == TYPE then
	{   lex.ErrorI(BADTYPE,rhs@.type@.name@.ident);
	    return 0;
	}
	fold = false; swap = false;
	if lhs@.op == CONST then
	{   if rhs@.op == CONST then	// constant folding
	    {   if op
		is ADD then { lhs@.valu += rhs@.valu; return lhs; }
		is SUB then { lhs@.valu -= rhs@.valu; return lhs; }
		is OR then  { lhs@.valu = lhs@.valu | rhs@.valu; return lhs; }
		is XOR then { lhs@.valu = lhs@.valu ^ rhs@.valu; return lhs; }
		is AND then { lhs@.valu = lhs@.valu & rhs@.valu; return lhs; }
		is MUL then { lhs@.valu = lhs@.valu * rhs@.valu; return lhs; }
		is DIV then { lhs@.valu = lhs@.valu / rhs@.valu; return lhs; }
		is MOD then { lhs@.valu = lhs@.valu % rhs@.valu; return lhs; }
		is LSL,ASL then { lhs@.valu = lhs@.valu << rhs@.valu; return lhs; }
		is LSR then { lhs@.valu = lhs@.valu >> rhs@.valu; return lhs; }
		is ASR then
		{   lhs@.valu = Valu(type.SValu(lhs@.valu) << rhs@.valu);
		    return lhs;
		}
		is UMIN then
		{   if rhs@.valu < lhs.valu then lhs.valu = rhs.valu;
		    return lhs;
		}
		is UMAX then
		{   if rhs@.valu > lhs.valu then lhs.valu = rhs.valu;
		    return lhs;
		}
		is SMIN then
		{   if type.SValu(rhs@.valu) < type.SValu(lhs.valu) then
			lhs.valu = rhs.valu;
		    return lhs;
		}
		is SMAX then
		{   if type.SValu(rhs@.valu) > type.SValu(lhs.valu) then
			lhs.valu = rhs.valu;
		    return lhs;
		}
		is EQ then
		{   lhs@.valu = _uint(lhs@.valu == rhs@.valu);
		    return lhs;
		}
		is NE then
		{   lhs@.valu = _uint(lhs@.valu != rhs@.valu);
		    return lhs;
		}
		is ULT then
		{   lhs@.valu = _uint(lhs@.valu < rhs@.valu);
		    return lhs;
		}
		is UGT then
		{   lhs@.valu = _uint(lhs@.valu > rhs@.valu);
		    return lhs;
		}
		is ULE then
		{   lhs@.valu = _uint(lhs@.valu <= rhs@.valu);
		    return lhs;
		}
		is UGE then
		{   lhs@.valu = _uint(lhs@.valu >= rhs@.valu);
		    return lhs;
		}
		is SLT then
		{   lhs@.valu = _uint(type.SValu(lhs@.valu) < type.SValu(rhs@.valu));
		    return lhs;
		}
		is SGT then
		{   lhs@.valu = _uint(type.SValu(lhs@.valu) > type.SValu(rhs@.valu));
		    return lhs;
		}
		is SLE then
		{   lhs@.valu = _uint(type.SValu(lhs@.valu) <= type.SValu(rhs@.valu));
		    return lhs;
		}
		is SGE then
		{   lhs@.valu = _uint(type.SValu(lhs@.valu) >= type.SValu(rhs@.valu));
		    return lhs;
		}
	    }
	    else	// possible swap arms to get constant on rhs
		swap = true;
	}
	// FIXME: all the kinds should be examined for legality
	// for the various ops
	if lhs@.type@.kind == REF || lhs@.type@.kind == REFPROC then
	{   if rhs@.op == CONST then
	    {   if op == EQ || op == NE then
		    rhs@.width = Target.ptr.size;
	    }
	}
	sl = lhs@.width;
	sr = rhs@.width;
	if sl > sr then
	    rhs = Extend(rhs, sl, false);
	else
	{   if sr > sl then
		lhs = Extend(lhs, sr, false);
	}
	tree = ast.New2(op, lhs@.type, lhs, rhs);
	return tree;
    }

    proc FindFlexSize(t: Type): type.BitSize
    {   var size: type.BitSize;
	var bt: Type;

	size = 1;   // some default
	if t != 0 then
	{   if t@.flex then
	    {   if t@.kind
		is ARRAY then
		    bt = t@.base;
		is RECORD then
		{   var f, ff: Symb;
		    bt = 0;
		    f = t@.list;
		    while f != 0 do
		    {   bt = f@.type;
			f = f@.next;
		    }
		}
		if bt != 0 then size = FindFlexSize(bt);
	    }
	    else
		size = t@.width/Target.membits;
	}
	return size;
    }

    proc NewOrDelete(which: symb.IntrinsicT): Ast
    {   var tree, size, temp, space: Ast;
	var s: Symb;
	var tok: TokenT;
	var t: Type;

	tree = 0;
	tok = Token;
	if tok == ID then
	{   t = 0;
	    if which == NEW then
	    {   s = symb.FindKind(lex.Ident, TYPE);
		if s != 0 then
		    t = s@.type;
	    }
	    else    // DEL or ZERO
	    {   s = symb.FindKind(lex.Ident, VAR);
		if s != 0 then
		{   if s@.type@.kind == REF then
			t = s@.type@.base;
		    else
		    {   if which == ZERO then
			{   t = s@.type;
			}
			else
			    lex.Error(NOTREF);
		    }
		}
	    }   
	    tok = Next();
	    if t != 0 then
	    {   size = ast.Const(type.wordtype, t@.width/Target.membits);
		if tok == PBEG then
		{   tok = Next();
		    if !t@.flex then
			lex.ErrorS(NOTIMPL, "not a variable sized type");
		    temp = Const(type.wordtype);
		    temp = ast.New2(MUL, type.wordtype, temp,
			ast.Const(type.wordtype, FindFlexSize(t)));
		    size = ast.New2(ADD, type.wordtype, size, temp);
		    tok = lex.Expect(PEND);
		}
		if tok == COMMA then
		{   tok = Next();
		    space = Const(type.wordtype);
		}
		else
		    space = ast.Const(type.wordtype, 0);
		if which
		is NEW then
		{   tree = ast.New(CALL, 0);
		    tree@.symb = symb.libnew;
		    tree@.type = type.addrtype;
		    tree@.width = Target.ptr.size;
		    tree = ast.Child(tree, size);
		    tree = ast.Child(tree,
			   ast.Const(type.wordtype, t@.align/Target.membits));
		    tree = ast.Child(tree, space);
		    tree = ast.New1(CAST, type.MakeRef(s@.type), tree);
		}
		is DEL then
		{   tree = ast.New(CALL, 0);
		    tree@.symb = symb.libdel;
		    temp = ast.New(VAR, type.MakeRef(s@.type));
		    temp@.symb = s;
		    temp = Load(temp);
		    temp = ast.New1(CAST, type.addrtype, temp);
		    tree = ast.Child(tree, temp);
		    tree = ast.Child(tree, size);
		    tree = ast.Child(tree, space);
		}
		else    // ZERO
		{   if s@.type@.kind == REF then
		    {   temp = ast.New(VAR, type.MakeRef(s@.type));
		        temp@.symb = s;
		        temp = Load(temp);
		    }
		    else
		    {   temp = ast.New(VAR, s@.type);
		        temp@.symb = s;
		        temp = ast.New1(BYREF, type.MakeRef(s@.type), temp);
		    }
		    tree = ast.New3(SET, type.unkntype, temp,
			    ast.Const(type.bytetype, 0), size);
		    tree = ast.Child(tree,
			    ast.Const(type.wordtype, t@.align/Target.membits));
		}
	    }
	}
	else lex.Error(EXPECTID);
	return tree;
    }

    proc Intrinsic(ps: Symb): Ast
    {   var tree, lhs, rhs: Ast;
	var tok: TokenT;
	var which: symb.IntrinsicT;
	var op: ast.Op;

	tree = 0;
	tok = Token;
	if tok == PBEG then
	{   tok = Next();
	    which = symb.IntrinsicT(ps@.addr);
	    if which
	    is DEF then
	    {   if tok == ID then
		    tree = ast.Const(type.booltype,
				     _uint(symb.IsDefined(lex.Ident)));
		else lex.Error(EXPECTID);
	    }
	    is ABS then
	    {   rhs = Bool(0);
		if rhs != 0 then
		{   tree = UnOp(ABS, rhs);
		    if tree@.type@.kind == SINT then
		    {   var i: _uint;
			i = 0;
			while i < type.NINTS &&
			      tree@.width > type.inttypes[i]@.size do
			    i += 1;
			tree@.type = type.uinttypes[i];
		    }
		}
	    }
	    is MIN, MAX then
	    {   lhs = Bool(0);
		lex.Expect(COMMA);
		rhs = Bool(0);
		if lhs != 0 && rhs != 0 then
		{   if IsSignedBinOp(lhs, rhs) then
			if which == MIN then op = SMIN; else op = SMAX;
		    else
			if which == MIN then op = UMIN; else op = UMAX;
		    tree = BinOp(op, lhs, rhs);
		}
	    }
	    is CLZ, CLZNZ, CTZ, CTZNZ, POP then
	    {   rhs = Bool(0);
		if rhs != 0 then
		{   tree = UnOp(UNARY, rhs);
		    tree.valu = _uint(which);
		}
	    }
	    is NEW, DEL, ZERO then
		tree = NewOrDelete(which);
	    else
		lex.ErrorS(COMPILER, "Intrinsic unknown");
	    tok = lex.Expect(PEND);
	}
	else lex.ErrorT(EXPECT, PBEG);
	return tree;
    }

    proc Call(ps:Symb, tree: Ast, arg: Ast): Ast
    {   var t: Type;
	var s: Symb;
	var tok: TokenT;

	t = ps@.type;
	if tree == 0 then	// direct call
	    tree = ast.New(CALL, t);
	else			// indirect call
	    tree = ast.New1(CALLI, t, tree);
	tree@.symb = ps;
	if t != 0 then		// has returned value
	    tree@.width = t@.width;
	else
	    tree@.type = type.unkntype;
	s = ps@.parmlist;
	if arg != 0 then	// method call
	{   // assert s != 0
	    arg = Load(arg);
	    arg = Actual(arg, s@.type);
	    tree = ast.Child(tree, arg);
	    s = s@.next;
	}
	tok = Token;
	if tok == PBEG then
	{   tok = Next();
	    if tok != PEND then
	    {   loop
		{
		  exit s == 0 with
		    {   lex.Error(ARGSHI);
			tok = lex.Skip(skiplist);
		    }
		    arg = Actual(0, s@.type);
		    tree = ast.Child(tree, arg);
		    s = s@.next;
		    tok = Token;
		  exit tok != COMMA;
		    tok = Next();
		}
	    }
	    tok = lex.Expect(PEND);
	}
	else
	    lex.ErrorT(EXPECT, PBEG);
	if s != 0 && s@.isparam then
	    lex.Error(ARGSLO);
	return tree;
    }

    proc RefProc(s: Symb): Ast
    {   var t: Type;
	var tree: Ast;

	// must create a REFPROC type to point at proc symbol
	t = type.New(REFPROC);
	t@.list = s;
	tree = ast.New(VAR, t);
	tree@.symb = s;
	return tree;
    }

    proc Atom(s:Symb, et:Type): Ast
    {   var tree: Ast;
	var t: Type;

	tree = 0;
	if s != 0 then
	{
		t = s@.type;
		if s@.kind
		is VAR then
		{   tree = ast.New(VAR, type.MakeRef(t));
		    tree@.symb = s;
		    tree@.width = t@.width;
		}
		is CONSTANT then
		{   if t@.kind <= REF || t@.packed then
			tree = ast.Dup(s@.const);
		    else	// treat like a var
		    {   tree = ast.New(VAR, type.MakeRef(t));
			tree@.symb = s;
			tree@.width = t@.width;
		    }
		}
		is PROC then
		{   if s@.addr != 0 then
			tree = Intrinsic(s);
		    else
		    {   if et != 0 && et@.kind == REFPROC then
			    tree = RefProc(s);
			else
			    tree = Call(s, 0, 0);
		    }
		}
		is TYPE then
		{   tree = ast.New(TYPE, t);
		    tree@.symb = s;
		}
		else lex.ErrorI(BADID, s@.ident);	// FIXME; need better message
	}
	return tree;
    }

    proc Primary(s: Symb, et: Type): Ast
    {   var tree: Ast;
	var t, bt: Type;
	var tok: TokenT;
	var done: boolean;

	if s != 0 then
	    tree = Atom(s, et);
	else
	{   // fake a variable of the right type
	    tree = ast.New(VAR, type.MakeRef(et));
	    tree@.symb = 0;
	    tree@.width = et@.width;
	}
	tok = Token;
	done = false;
	while !done && tree != 0 && tree@.type != 0 do
	{   t = tree@.type;
	    if tok
	    is DOT then
	    {   tok = Next();
		if tree@.op == TYPE then
		{   if t@.kind == ENUM then
		    {   tree = EnumConst(t);
			tok = Next();
		    }
		    else
			lex.ErrorI(BADTYPE, s@.ident);
		}
		else
		{   if tok == ID then
		    {   s = 0;
			bt = t;
			if t@.kind == REF then bt = t@.base;
			if bt != 0 then	// don't bother with invalid base type
			{   loop
			    {   s = symb.FindMethod(bt@.meths, lex.Ident);
			      exit s != 0 || bt@.base == 0;
				bt = bt@.base;
			    }
			}
			if s != 0 then		// method call
			{   tok = Next();
			    if et != 0 && et@.kind == REFPROC then
				tree = RefProc(s);
			    else
				tree = Call(s, 0, tree);
			}
			else
			{
			    if tree@.op == CONST then
				bt = t;
			    else
				bt = t@.base;   // t should be REF
			    if bt != 0 then // and therefore bt should not be null
			    {   if bt@.kind == REF then
				{   if bt@.base != 0 then
				    {   if tree@.op != CONST then
					    tree = ast.New1(LOAD, bt, tree);
					tree@.width = Target.ptr.size;
					bt = bt@.base;
				    }
				    else
				    {   lex.Error(BADREF);
					tree = 0;	// give up
				    }
				}
				if bt@.kind == RECORD then
				{   s = symb.FindLocal(bt@.list, lex.Ident);
				    if s != 0 then
				    {   tok = Next();
					tree = ast.New1(OFFSET,
						type.MakeRef(s@.type), tree);
					tree@.valu = s@.addr;
					tree@.width = Target.ptr.size;
				    }
				    else
				    {   lex.ErrorI(UNDEFFIELD, lex.Ident);
					tok = Next();
				    }
				}
			    }
			    else lex.Error(NOTREF);
			}
		    }
		    else lex.Error(EXPECTID);
		}
	    }
	    is AT then
	    {   tok = Next();
		if tree@.op == TYPE then
		{   lex.ErrorI(BADTYPE, tree@.symb@.ident);
		    return 0;
		}
		if tree@.op == CONST then
		    bt = t;
		else
		    bt = t@.base;   // t should be REF
		if bt != 0 then // and therefore bt should not be null
		{   if bt@.kind == REF then
		    {   if bt@.base != 0 then
			{   if tree@.op != CONST then
				tree = ast.New1(LOAD, bt, tree);
			    tree@.width = Target.ptr.size;
			}
			else
			{   lex.Error(BADREF);
			    return 0;	// give up
			}
		    }
		    else if bt@.kind == REFPROC then
		    {   tree = ast.New1(LOAD, bt, tree);
			tree = Call(bt@.list, tree, 0);
		    }
		    else lex.Error(NOTREF);
		}
		else lex.Error(NOTREF);
	    }
	    is ABEG then
	    {   tok = Next();
		if tree@.op == TYPE then
		{   lex.ErrorI(BADTYPE, tree@.symb@.ident);
		    return 0;
		}
		if tree@.op == CONST then
		    bt = t;
		else
		    bt = t@.base;   // t should be REF
		if bt != 0 then // and therefore bt should not be null
		{   if bt@.kind == REF then
		    {   if bt@.base != 0 then
			{   if tree@.op != CONST then
				tree = ast.New1(LOAD, bt, tree);
			    tree@.width = Target.ptr.size;
			    bt = bt@.base;
			}
			else
			{   lex.Error(BADREF);
			    tree = 0;	// give up
			}
		    }
		    if bt@.kind == ARRAY then
		    {   var index: Ast;
			index = Bool(bt@.index);
			tok = Token;
			if tok == COLON then	// array slice
			{   var len: Ast;
			    tok = Next();
			    len = Bool(bt@.index);	// index type?
			    tree = Slice(tree, index, len);
			    done = true;
			}
			else
			{   tree = ast.New2(INDEX, type.MakeRef(bt@.base), tree, index);
			    tree@.width = Target.ptr.size;
			}			
		    }
		    else
			lex.Error(NOTARRAY);
		}
		else
		    lex.Error(NOTARRAY);
		tok = lex.Expect(AEND);
	    }
	    is QUEST then
	    {   tok = Next();
		tree = Property(tree);
	    }
	    else done = true;
	}
	return tree;
    }

    proc GetLHS(): Ast
    {   var s: Symb;
	var tok: TokenT;
	var tree: Ast;

	tree = 0;
	tok = Token;
	if tok == ID then
	{   s = symb.Find(lex.Ident);
	    tok = Next();
	    if s != 0 then
	    {   tree = expr.Primary(s, 0);
		if tree@.op == TYPE then lex.ErrorI(BADTYPE, tree@.symb@.ident);
	    }
	    else lex.ErrorI(UNDEFID, lex.Ident);
	}
	else lex.Error(EXPECTID);
	return tree;
    }

    proc Container(tree: Ast, t: Type): Ast
    {   var otree: Ast;
	var offset: _uint;

	otree = Primary(0, t);
	if otree != 0 then
	    otree = GetOffset(otree);
	if otree != 0 then
	{   tree = Cast(tree, type.wordtype);
	    tree = ast.New2(SUB, type.wordtype, tree, otree);
	    tree = Cast(tree, t);
	}
//ast.Dump(tree);
	return tree;                  
    }

    proc Term(et:Type): Ast
    {   var tree: Ast;
	var tok: TokenT;
	var t: Type;
	var s: Symb;

	tree = 0;
	tok = Token;
	if tok
	is ID then
	    {   s = symb.Find(lex.Ident);
		if s != 0 then
		{   tok = Next();
		    tree = Primary(s, et);
		    if tree != 0 then
		    {   if tree@.op == TYPE then
			{   if tok 
			    is PBEG then		// cast
			    {   tok = Next();
				t = tree@.type;
				tree = Bool(0);	// FIXME: is this right?
				tok = Token;
				if tok == COMMA then
				{   tok = Next();
				    tree = Container(tree, t);
				}
				else    // simple cast
				    tree = Cast(tree, t);
				tok = lex.Expect(PEND);
			    }
			    is GBEG then		// composite
				tree = CompositeValue(tree@.type);
			}
			else if tree@.type@.kind != REFPROC then
			{   tree = Load(tree);
			    if tree != 0 && tree@.op != CONST &&
			       type.NeedSwap(tree@.type, Target.memorder) then
			    {   tree = ast.New1(REVB, tree@.type, tree);
				tree@.type =
				  type.ChangeOrder(tree@.type, Target.memorder);
			    }
			}
		    }
		}
		else
		{   if et != 0 && et@.kind == ENUM then	// enum context
			tree = EnumConst(et);
		    else lex.ErrorI(UNDEFID, lex.Ident);
		    tok = Next();
		}
	    }
	is NUM then
	{   tree = ast.New(CONST, et);
	    tree@.valu = lex.Number;
	    tree@.width = type.bitsize(lex.Number);
	    if et == 0 then
		tree@.type = type.wordtype;	// FIXME: ?
	    else
	    {   if et@.kind == REF then		    // want pointer constant
		{   tree@.type = et;
		    tree@.width = Target.ptr.size;
		}
		else
		{   if et@.size > tree@.width then   // widen
			tree@.width = et@.size;
		}
	    }
	    tok = Next();
	}
	is STR then
	{   tree = String();
	    loop
	    {   tok = Next();
	      exit tok != STR;
		tree = StringCat(tree);
	    }
	}
	is PBEG then
	{   tok = Next();
	    tree = Bool(et);
	    tok = Token;
	    lex.Expect(PEND);
	}
	is GBEG then
	    tree = CompositeValue(et);
	return tree;
    }

    proc Unary(t:Type): Ast
    {   var tree: Ast;
	var tl: Type;
	var tok, savetok: TokenT;

	tok = Token;
	savetok = tok;
	if tok
	is MINUS, PLUS, INV, NOT then tok = Next();
	tree = Term(t);
	if tree != 0 then
	{   tl = tree@.type;
	    if savetok
	    is MINUS then
	    {   tree = UnOp(NEG, tree);
		if tree@.type@.kind == UINT then
		{   var i: _uint;
		    i = 0;
		    while i < type.NINTS &&
			  tree@.width > type.uinttypes[i]@.size do
			i += 1;
		    tree@.type = type.inttypes[i];
		}
	    }
	    is INV then
		tree = UnOp(NOT, tree);
	    is NOT then
	    {   tree = ForceBoolean(tree);
		tree = UnOp(BNOT, tree);
	    }
	}
	return tree;
    }

    const mulop: []ast.Op = { MUL, DIV, MOD, LSL, LSR, AND };
    proc Mul(t:Type): Ast
    {   var tree, rhs: Ast;
	var op: ast.Op;
	var tok: TokenT;

	tree = Unary(t);
	if tree != 0 then
	{   loop
	    {   tok = Token;
	      exit tok < STAR || tok > AND;
		op = mulop[tok - STAR];
		tok = Next();
		rhs = Unary(tree@.type);
	      exit rhs == 0;
		if tree@.type@.kind == SINT then
		{   if op
		    is LSL then op = ASL;
		    is LSR then op = ASR;
		}
if !debug.tests[0] then {
		// make LHS as wide as result wants it
		if op != AND && t != 0 && t@.width > tree@.type@.width then
		    tree = ExtendT(tree, t);
}
		tree = BinOp(op, tree, rhs);
	    }
	}
	return tree;
    }

    const addop: []ast.Op = { ADD, SUB, OR, XOR };
    proc Add(t:Type): Ast
    {   var tree, rhs: Ast;
	var op: ast.Op;
	var tok: TokenT;

	tree = Mul(t);
	if tree != 0 then
	{   loop
	    {   tok = Token;
	      exit tok < PLUS || tok > XOR;
		op = addop[tok - PLUS];
		tok = Next();
		rhs = Mul(tree@.type);
	      exit rhs == 0;
if !debug.tests[0] then {
		// make LHS as wide as result wants it
		if op != OR && op != XOR && t != 0 && t@.width > tree@.type@.width then
		    tree = ExtendT(tree, t);
}
		tree = BinOp(op, tree, rhs);
	    }
	}
	return tree;
    }


    const ucmpop: []ast.Op = { EQ, NE, ULT, UGT, ULE, UGE };
    const scmpop: []ast.Op = { EQ, NE, SLT, SGT, SLE, SGE };
    proc ScalarCompare(op: ast.Op, lhs: Ast, rhs: Ast): Ast
    {   var tree: Ast;

	tree = BinOp(op, lhs, rhs);
	if tree != 0 then
	{   tree@.type = type.booltype;
	    tree@.width = 1;
	}
	return tree;
    }

    proc ArrayCompare(op: ast.Op, lhs: Ast, rhs: Ast): Ast
    {   var tree: Ast;
	var lsize, rsize, align: Ast;
	var lalign, ralign: _uint;

	// FIXME: share code with stmt.AssignArray?
	if lhs@.type@.packed then
	{   if !rhs@.type@.packed then
		lex.ErrorS(NOTIMPL, "ArrayCompare: packed and not packed");
//	    lhs@.kind = UINT;   //FIXME
//	    rhs@.kind = UINT;   //FIXME
	    if op == AEQ then op = EQ; else op = NE;
	    tree = ast.New2(op, type.booltype, lhs, rhs);
	    tree@.width = 1;
	    return tree;
	}
	// FIXME the compares on lhs@.op and rhs@.op can be optimized
	if lhs@.op == LOAD && lhs@.type@.kind == ARRAY then	// undo LOAD
	    lhs = lhs@.child[0];
	if rhs@.op == LOAD && rhs@.type@.kind == ARRAY then	// undo LOAD
	    rhs = rhs@.child[0];
	if lhs@.op == CLIST || lhs@.op == SCON then
	    lhs = ast.New1(BYREF, type.MakeRef(lhs@.type), lhs);
	if rhs@.op == CLIST || rhs@.op == SCON then
	    rhs = ast.New1(BYREF, type.MakeRef(rhs@.type), rhs);
	lalign = GetAlignment(lhs);
	ralign = GetAlignment(rhs);
//err.str("ArrayCompare lalign="); err.uint(lalign);
//err.str(" ralign="); err.uint(ralign); err.nl();
	if ralign < lalign then lalign = ralign;
	if lhs@.op == SLICE then
	    lsize = lhs@.child[2];
	else
	    lsize = ast.Const(type.wordtype, lhs@.type@.base@.hi);
	if rhs@.op == SLICE then
	    rsize = rhs@.child[2];
	else
	    rsize = ast.Const(type.wordtype, rhs@.type@.base@.hi);
//err.str("ArrayCompare lsize=\n"); ast.Dump(lsize);
//err.str("rsize=\n"); ast.Dump(rsize);
	tree = ast.New2(op, type.booltype, lhs, rhs);
	tree@.width = 1;
	tree = ast.Child(tree, lsize);
	align = ast.Const(type.wordtype, lalign);
	tree = ast.Child(tree, align);
	return tree;
    }
 
    proc NodeKind(node: Ast): TypeT
    {   var kind: TypeT;

	if node@.op
	is VAR, SLICE, INDEX, OFFSET then
	    kind = node@.type@.base@.kind;
	else
	    kind = node@.type@.kind;
//err.str("NodeKind kind="); err.str(type.KindName[kind]); err.nl();
//ast.Dump(node);
	return kind;
    }

    proc Compare(t:Type): Ast
    {   var tree, rhs: Ast;
	var tok, savetok: TokenT;
	var op: ast.Op;
	var ok: boolean;

	tree = Add(t);
	tok = Token;
	if tok >= EQ && tok <= GE then
	{   savetok = tok;
	    tok = Next();
	    if tree != 0 then
	    {   rhs = Add(tree@.type);
		if rhs != 0 then
		{   ok = type.Compat(tree@.type, rhs@.type);
		    if NodeKind(tree)
		    is ENUM, UINT, SINT then
		    {   if IsSignedBinOp(tree, rhs) then
			    op = scmpop[savetok - EQ];
			else
			    op = ucmpop[savetok - EQ];
			tree = ScalarCompare(op, tree, rhs);
		    }
		    is REF, REFPROC then
		    {   if savetok
			is EQ then op = EQ;
			is NE then op = NE;
			else ok = false;
			if ok then
			    tree = ScalarCompare(op, tree, rhs);
		    }
		    is RECORD then
		    {   if NodeKind(rhs) == RECORD &&
			   tree@.type@.packed && rhs@.type@.packed then
			{   if savetok
			    is EQ then op = EQ;
			    is NE then op = NE;
			    else ok = false;
			    if ok then
				tree = ScalarCompare(op, tree, rhs);
			}
			else ok = false;
		    }
		    is ARRAY then
		    {   if NodeKind(rhs) == ARRAY then
			{   if tree@.type@.packed && rhs@.type@.packed then
			    {   if savetok
				is EQ then op = EQ;
				is NE then op = NE;
				else ok = false;
				if ok then
				    tree = ScalarCompare(op, tree, rhs);
			    }
			    else
			    {   if savetok
				is EQ then op = AEQ;
				is NE then op = ANE;
				else ok = false;
				if ok then
				    tree = ArrayCompare(op, tree, rhs);
			    }
			}
			else ok = false;
		    }
		    else ok = false;
		    if !ok then
			lex.Error(BADCOMPARE);
		}
	    }
	}
	return tree;
    }

    proc BoolAnd(t:Type): Ast
    {   var tree, rhs: Ast;
	var tok: TokenT;

	tree = Compare(t);
	loop
	{   tok = Token;
	  exit tok != BAND;
	    tok = Next();
	    rhs = Compare(tree@.type);
	    if tree != 0 && rhs != 0 then
	    {   tree = ForceBoolean(tree);
		rhs = ForceBoolean(rhs);
		// constant folding
		if tree@.op == CONST && rhs@.op == CONST then
		    tree@.valu = tree@.valu & rhs@.valu;
		else
		    tree = ast.New2(BAND, type.booltype, tree, rhs);
	    }
	}
	return tree;
    }

    proc Bool(t:Type): Ast
    {   var tree, rhs: Ast;
	var tok: TokenT;

	tree = BoolAnd(t);
	loop
	{   tok = Token;
	  exit tok != BOR;
	    tok = Next();
	    rhs = BoolAnd(tree@.type);
	    if tree != 0 && rhs != 0 then
	    {   tree = ForceBoolean(tree);
		rhs = ForceBoolean(rhs);
		// constant folding
		if tree@.op == CONST && rhs@.op == CONST then
		    tree@.valu = tree@.valu | rhs@.valu;
		else
		    tree = ast.New2(BOR, type.booltype, tree, rhs);
	    }
	}
	return tree;
    }


    proc Const(t: Type): Ast
    {   var tree: Ast;

	if t != 0 then
	{   if t@.kind
	    is REF then
	    {	if Token
		is GBEG, STR then
		{   tree = Const(t@.base);
		    tree = ast.New1(BYREF, t, tree);
		}
		else
		{   tree = Bool(t);
		    if tree != 0 then
		    {   if tree@.op
			is CONST then   // pointer constant
			    tree@.type = t;
			is LOAD then    // reference to stored const
			{
			    tree = tree@.child[0];
			    // assert tree@.op == VAR
			    if t@.base@.flex && !tree@.type@.base@.flex then
				tree = ast.New1(CAST, t, tree);
			}
			else if tree@.type != t then
			{   if type.Compat(tree@.type, t@.base) then
				tree = CoerceToRef(tree);
			    else
				lex.Error(BADCOMPV);
			}
		    }
		}
	    }
	    is RECORD then tree = RecordConst(t);
	    is ARRAY then  tree = ArrayConst(t);
	    is REFPROC then tree = Bool(t);     // FIXME?
	    else
	    {   tree = Bool(t);	    // scalar
		if tree != 0 then
		{   tree = Extend(tree, t@.width, false);   // usually truncates
		    tree@.type = t;
		}
	    }
	}
	else tree = Bool(t);		// unknown type
	return tree;
    }

    proc ConstValue(t: Type): Valu
    {   var tree: Ast;
	var rv: Valu;

	rv = 0;
	tree = Bool(t);
	if tree != 0 && tree@.op == CONST then
	{   // FIXME: should check that types are compatable
	    rv = tree@.valu;
	    // free(tree)
	}
	else
	    lex.Error(EXPCONST);
	return rv;
    }

    proc ConstString(): @[]Char
    {   var tree: Ast;
	type pstring: @[]_byte;

	tree = expr.Bool(0);
	if tree != 0 then
	{   if tree@.op == SCON then
		return pstring(tree@.symb);
	    else if tree@.op == LOAD &&
		    tree@.child[0]@.op == VAR &&
		    tree@.child[0]@.symb@.const != 0 &&
		    tree@.child[0]@.symb@.const@.op == SCON then
	    {
		return pstring(tree@.child[0]@.symb@.const@.symb);
	    }
	}
	return 0;
    }
}
// vim: ts=8 sw=4 noet nowrap

