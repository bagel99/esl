// Copyright (c) 2009-2011, Brian G. Lucas.  See LICENSE file.
// $Id$

package expr
{
    const skiplist:[4]TokenT = { PEND, GEND, SEMI, NONE };

    const proplist:[]TokenT = { KMIN, KMAX, KBITSZ, KMEMSZ, KALIGN, KLEN, NONE };

    proc TypeProperty(t: Type): Ast
    {   var tree: Ast;
	var tok: TokenT;

	tree = 0;
	tok = Token;
	if tok == ID then
	{   tok = lex.Keyword(proplist);
	    if t != 0 then
	    {   if tok
		is KMIN then tree = ast.Const(t, t@.lo);
		is KMAX then tree = ast.Const(t, t@.hi);
		is KBITSZ then tree = ast.Const(type.wordtype, t@.size);
		is KMEMSZ then tree = ast.Const(type.wordtype, t@.width/Target.membits);
		is KALIGN then tree = ast.Const(type.wordtype, t@.align/Target.membits);
		is KLEN then
		{   if t@.kind == ARRAY && !t@.flex then
			tree = ast.Const(type.wordtype, t.Span());
		    else lex.Error(BADLEN);
		}
		else lex.Error(PROPID);
	    }
	    else
		tree = ast.Const(type.wordtype, 0); // t == 0, return something
	}
	else lex.Error(PROPID);
	tok = Next();
	return tree;					
    }

    var strid: Valu = 0;

    proc NewString(): Ast
    {   var tree: Ast;
	var t: Type;

	t = type.New(ARRAY);
	t@.base = type.bytetype;
	t@.index = type.wordtype;
	t@.lo = 0;
	t@.hi = lex.StringLen-1;
	t@.align = t@.base@.align;
	t@.memorder = Target.memorder;
	tree = ast.New(SCON, t);
//err.str("NewString \"");  err.str(lex.StringBuf); err.str("\"\n");
	tree@.symb = symb.NewString(lex.StringBuf);
//symb.DumpS(tree@.symb);
	strid += 1;
	tree@.valu = strid;
	return tree;
    }

    proc StringCat(tree: Ast): Ast
    {   var sr: _address;
	var t: Type;
	var nl, nr, i: _uint;

	// modify the ARRAY type
	t = tree@.type;     // assert t@.kind == ARRAY
	nl = t@.hi - 1;	    // LHS string length without nul termination
	nr = lex.StringLen; // RHS string length with nul termination
	t@.hi = nl+nr;
	// move RHS down in StringBuf, include nul termination
	// potential overlap, must do a reverse copy
	i = nr;
	loop
	{   lex.StringBuf[i+nl] = lex.StringBuf[i];
	  exit i == 0;
	    i -= 1;
	}
	// copy in LHS, symbol is string
	sr = tree@.symb@.ident;
	lex.StringBuf[0:nl] = sr[0:nl];
	// create a new string long enough
//err.str("NewString \"");  err.str(lex.StringBuf); err.str("\"\n");
	tree@.symb = symb.NewString(lex.StringBuf);
//symb.DumpS(tree@.symb);
	return tree;   
    }

    // Parse string constants, perhaps concatenated
    proc String(): Ast
    {   var tree: Ast;
	var tok: TokenT;

        tree = NewString();
	loop
	{   tok = Next();
	  exit tok != STR;
	    tree = StringCat(tree);
	}
        return tree;
    }

    proc EnumConst(t: Type): Ast
    {   var s: Symb;
	var tree: Ast;

	// assert t@.kind == ENUM
	s = t@.list;
	while s != 0 do
	{   if zstr.eq(s@.ident, lex.Ident, lex.IdentMax) then
	    {   tree = ast.Dup(s@.const);
		tree@.width = s@.const@.type@.width;
		return tree;
	    }
	    s = s@.next;
	}
	lex.ErrorI(UNDEFID, lex.Ident);
	return 0;
    }

    proc IsAggregateConst(node: Ast): boolean
    {   var i: ast.NSubNodes;

//err.str("IsAggregateConst op="); err.str(ast.OpName[node@.op]); err.nl();
	if node@.op
	is SCON, FCON, CONST then return true;
	is VAR then
	{   if node@.type@.kind == REFPROC then
		return node@.symb@.kind == PROC;
	    else
		return node@.symb@.kind == CONSTANT;
	}
	is BYREF, CAST then return IsAggregateConst(node@.child[0]);
	is CLIST then
	{   i = 0;
	    while i < node@.num do
	    {   if !IsAggregateConst(node@.child[i]) then return false;
		i += 1;
	    }
	    return true;
	}
	return false;
    }

    proc CompositeNamedConstant(t: Type): Ast
    {   var cs: Symb;
	var ct: Type;
	var tree: Ast;
	var tok: TokenT;

        tree = 0;
	cs = symb.Find(lex.Ident);
	if cs != 0 then
	{   if cs@.kind == CONSTANT then
	    {   ct = cs@.type;
		if type.Compat(ct, t) then
		{   tree = cs@.const;
		    tree@.type = ct;
		}
		else lex.Error(BADCOMPV);
		tok = Next();
	    }
	    else if cs@.kind == TYPE then   // cast
	    {   tok = Next();
		if tok == PBEG then
		{   tok = Next();
		    tree = Bool(0);
		    lex.Expect(PEND);
		    tree = ast.Cast(tree, cs@.type);
		}
	    }
	    else
	    {   lex.Error(EXPCONST);
		tok = Next();
	    }
	}
	else lex.ErrorI(UNDEFID, lex.Ident);
	return tree;
    }

    proc ArrayPack(t:Type, intree:Ast): Ast
    {   var offs, tsize, fsize: type.BitSize;
	var i: ast.NSubNodes;
	var tree, vpart, node: Ast;
	var cpart, mask: type.Valu;
	var bt: Type;		// base type

	vpart = 0;
	cpart = 0;
	if intree@.op != CLIST then
	{   lex.ErrorS(COMPILER, "No CLIST for packed array");
	    return tree;
	}
	tsize = t@.width;
	bt = t@.base;
	fsize = bt@.size;
	mask = ((1 << fsize)-1);
	if t@.bitorder == MSB then offs = tsize; else offs = 0;
	i = 0;
	while i < intree@.num do
	{
	    if t@.bitorder == MSB then offs -= fsize;
	    node = intree@.child[i];
	    if node@.op == CONST then
	    {   ast.CheckConstTruncate(node, fsize);
		cpart = cpart | ((node@.valu&mask) << offs);
	    }
	    else
	    {   node = ast.Extend(node, tsize, false);
		node = ast.New2(LSL, bt, node,
				ast.Const(type.wordtype, offs));
		if vpart == 0 then
		    vpart = node;
		else
		    vpart = ast.New2(OR, bt, vpart, node);
	    }
	    if t@.bitorder != MSB then offs += fsize;
	    i += 1;
	}
	tree = ast.Extend(ast.Const(type.wordtype, cpart), tsize, false);
	if vpart != 0 then
	    tree = ast.New2(OR, type.wordtype, tree, vpart);
	tree@.type = t;
	return tree;
    }

    proc ArrayFixFlex(bt: Type, len: _uint): Type
    {   var t: Type;

	t = type.Clone(bt);
	t@.flex = false;
        t@.lo = 0;	    // FIXME
	t@.hi = len-1;      // FIXME
	t@.size = 0;
	t@.width = 0;
	t@.final = false;
	type.Final(t);
	return t;
    }

    proc ArrayConst(t: Type): Ast
    {   var tree, stree: Ast;
	var i, j, m, n: ast.NSubNodes;	// what type should this be
	var tok: TokenT;
	var once: boolean;

	tree = 0;
	tok = Token;
	if tok == GBEG then
	{   tree = ast.New(CLIST, t);
	    strid += 1;
	    tree@.valu = strid;
	    once = false;
//err.str("ArrayConst t="); type.DumpT(t, true); err.nl();
	    if t@.flex then n = 0;
		       else n = ast.NSubNodes(t.Span());
	    i = 0;
	    m = 0;
	    tok = Next();
	    loop
	    {   j = i;  // for non-designated initializer
		if tok == ABEG then	// designated initializer
		{   tok = Next();
//err.str("ArrayConst index="); type.DumpT(t@.index, true); err.nl();
		    i = ast.NSubNodes(ConstValue(t@.index)) -
			ast.NSubNodes(t@.lo);
		    j = i;
		    if Token == RANGE then
		    {   tok = Next();
			j = ast.NSubNodes(ConstValue(t@.index)) -
			    ast.NSubNodes(t@.lo);
		    }
		    tok = lex.Expect(AEND);
		    tok = lex.Expect(ASGN);
		}
		stree = Const(t@.base);
		if (n == 0 || j < n) && i <= j then	// still room
		{   while i <= j do
		    {   tree = ast.ChildIndexed(tree, i, stree);
		        i += 1;
		    }
		    if i > m then m = i;
		}
		else if !once then
		{   once = true;
		    lex.Error(INITHI);
		}
		tok = Token;
	      exit tok == GEND;
	        tok = lex.Expect(COMMA);
	      exit tok == GEND;
	    }
	    tok = lex.Expect(GEND);
	    if t@.flex then	// flex array becomes a static array
		t = ArrayFixFlex(t, m);
	    // make sure all elements are initialized in gaps
	    i = 0;
	    while i < m do
	    {	if tree@.child[i] == 0 then
		    tree@.child[i] = ast.Const(t@.base, 0);
		i += 1;
	    }
	    // make sure all fields are initialized at end
	    while i < n do
	    {   tree = ast.ChildIndexed(tree, i, ast.Const(t@.base, 0));
		i += 1;
	    }
	    tree@.type = t;
	    if t@.packed then
		tree = ArrayPack(t, tree);
	    else
	    {   if !IsAggregateConst(tree) then
		    lex.Error(BADCONST);
	    }
	}
	else if tok == STR then
	    tree = String();
	else if tok == ID then
	    tree = CompositeNamedConstant(t);
	else lex.ErrorT(EXPECT, GBEG);
	return tree;
    }

    proc RecordPack(t:Type, intree:Ast): Ast
    {   var offs, tsize, fsize: type.BitSize;
	var f: Symb;
	var i: ast.NSubNodes;
	var tree, vpart, node: Ast;
	var cpart, mask: type.Valu;
	var ft: Type;		// field type

	vpart = 0;
	cpart = 0;
	if intree@.op != CLIST then
	{   lex.ErrorS(COMPILER, "No CLIST for packed record");
	    return tree;
	}
	tsize = t@.width;
	f = t@.list;
	if t@.bitorder == MSB then offs = tsize; else offs = 0;
	i = 0;
	while f != 0 do
	{   if f@.type != 0 then
	    {   ft = f@.type;
		fsize = ft@.size;
		mask = ((1 << fsize)-1);
		if t@.bitorder == MSB then offs -= fsize;
		if i >= intree@.num then
		{   lex.ErrorS(COMPILER, "Malformed LIST for packed record");
		    return 0;
		}
		node = intree@.child[i];
		if node@.op == CONST then
		{   ast.CheckConstTruncate(node, fsize);
		    cpart = cpart | ((node@.valu&mask) << offs);
		}
		else
		{   node = ast.Extend(node, tsize, false);
		    node = ast.New2(LSL, ft, node,
				    ast.Const(type.wordtype, offs));
		    if vpart == 0 then
			vpart = node;
		    else
			vpart = ast.New2(OR, ft, vpart, node);
		}
		if t@.bitorder != MSB then offs += fsize;
	    }
	    f = f@.next;
	    i += 1;
	}
	tree = ast.Extend(ast.Const(type.wordtype, cpart), tsize, false);
	if vpart != 0 then
	    tree = ast.New2(OR, type.wordtype, tree, vpart);
	tree@.type = t;
	return tree;
    }

    // Convert flex record to non-flex record
    proc RecordFixFlex(bt: Type, node: Ast): Type
    {   var t: Type;
	var s, ps, bs: Symb;

//err.str("Init flex record\n");
	t = type.Clone(bt);
	// copy all fields because we need the change the final one
	ps = 0;
	bs = bt@.list;
	while bs != 0 do
	{   s = symb.New(FIELD, bs@.ident, PRIVATE);
	    if ps != 0 then ps@.next = s; else t@.list = s;
	    ps = s;
	    s@.type = bs@.type;
	    bs = bs@.next;
	}
	// final field must be the flex, change its type
	ps@.type = node@.child[node@.num-1]@.type;
	t@.base = bt;       // set base type for compatibility test
	// Recalculate size and width
	t@.size = 0;
	t@.width = 0;
	t@.final = false;
	type.Final(t);
	return t;
    }

    proc RecordConst(t: Type): Ast
    {   var tree, stree: Ast;
	var fs, ds: Symb;
	var ft: Type;
	var max: symb.OffsT;
	var tok: TokenT;
	var once: boolean;

	tree = 0;
	tok = Token;
	if tok == GBEG then
	{   tree = ast.New(CLIST, t);
	    strid += 1;
	    tree@.valu = strid;
	    once = false;
	    max = 0;
	    fs = t@.list;
	    loop
	    {   
		tok = Next();
		if tok == DOT then	// designated initializer
		{   tok = Next();
		    if tok == ID then
		    {   ds = symb.FindLocal(t@.list, lex.Ident);
			if ds != 0 then
			    fs = ds;
			else
			    lex.ErrorI(UNDEFID, lex.Ident);
			tok = Next();
		    }
		    else
			lex.Error(EXPECTID);
		    tok = lex.Expect(ASGN);
		}
		else		// sequential initializer
		{   while fs != 0 && fs.ispad do    // skip padding
			fs = fs@.next;
		}
		ft = 0;
		if fs != 0 then ft = fs@.type;
		stree = Const(ft);
		if fs != 0 then
		{   tree = ast.ChildIndexed(tree, fs@.addr, stree);
		    if fs@.addr > max then max = fs@.addr;
		    fs = fs@.next;
		}
		else if !once then
		{   once = true;
		    lex.Error(INITHI);
		}
		tok = Token;
	      exit tok != COMMA;
	    }
	    tok = lex.Expect(GEND);
	    // make sure all fields are initialized in gaps
	    fs = t@.list;
	    while fs != 0 && fs@.addr <= max do
	    {	if tree@.child[fs@.addr] == 0 then
		    tree@.child[fs@.addr] = ast.Const(fs@.type, 0);
		fs = fs@.next;
	    }
	    // make sure all fields are initialized at end
	    while fs != 0 do
	    {   tree = ast.ChildIndexed(tree, fs@.addr, ast.Const(fs@.type, 0));
		fs = fs@.next;
	    }
	    if t@.flex then
		tree@.type = RecordFixFlex(t, tree);
	    if t@.packed then
		tree = RecordPack(t, tree);
	    else
	    {   if !IsAggregateConst(tree) then
		    lex.Error(BADCONST);
	    }
	}
	else if tok == ID then
	    tree = CompositeNamedConstant(t);
	else lex.ErrorT(EXPECT, GBEG);
	return tree;
    }

    proc CompositeValue(t: Type): Ast
    {   var tree: Ast;

	tree = 0;
	if t != 0 then
	{   if t@.kind
	    is RECORD then tree = RecordConst(t);
	    is ARRAY  then tree = ArrayConst(t);
	    is REF then tree = CompositeValue(t@.base);
	    else lex.Error(BADCOMPV);
	}
	else lex.Error(UNDFCOMPV);
	return tree;
    }

    proc CalcAlign(base: _uint, offset: _uint): _uint
    {   var new, tz: _uint;


//err.str("CalcAlign: base="); err.uint(base);
//err.str(" offset="); err.uint(offset);
	if offset == 0 then
	    new = base;
	else
	{   tz = 0;
	    while offset&1 == 0 do	// count trailing zeros
	    {   offset = offset >> 1;
		tz += 1;
	    }
	    new = 1 << tz;
	    new = _min(base, new);      // can't be greater than base
	}
//err.str(" new="); err.uint(new); err.nl();
	return new;
    }

    proc FieldAlign(base: _uint, record: Type, fieldno: _uint): _uint
    {   var offs, i: _uint;
	var s: Symb;

	if record@.kind != RECORD then return 0;	// can't happen?
//err.str("FieldAlign: base="); err.uint(base);
//err.str(" fieldno="); err.uint(fieldno);
	offs = 0;
	i = 0;
	s = record@.list;
	while i < fieldno && s != 0 do
	{   if record@.packed then
		offs += s@.type@.size;
	    else
		offs += s@.type@.width / Target.membits;
	    i += 1;
	    s = s@.next;
	}
//err.str(" offs="); err.uint(offs); err.nl();
	return CalcAlign(base, offs);
    }

    proc GetAlignment(tree:Ast): _uint
    {   var alignment: _uint;

	if tree == 0 then return 0;
//err.str("GetAlignment op="); err.str(ast.OpName[tree@.op]); err.nl();
	if tree@.op
	is VAR then 		// direct variable, use its alignment
	{   if tree@.type != 0 then
		alignment = tree@.type@.base@.align/Target.membits;
	    else
		alignment = 0;
	}
	is LOAD then 		// via a pointer
	{   if tree@.type@.kind == REF && tree@.type != 0 then
		alignment = tree@.type@.base@.align/Target.membits;
	    else
		alignment = 0;
	}
	is REVB, BYREF then
	    alignment = GetAlignment(tree@.child[0]);
	is OFFSET then 		// fixed offset
	{   alignment = GetAlignment(tree@.child[0]);
//err.str("GetAlignment OFFSET initial align="); err.uint(alignment); err.nl();
	    if alignment != 0 then
		alignment = FieldAlign(alignment, 
				       tree@.child[0]@.type@.base, _uint(tree@.valu));
	}
	is INDEX, SLICE then 	// possible variable offset
	{   alignment = GetAlignment(tree@.child[0]);
//err.str("GetAlignment INDEX/SLICE initial align="); err.uint(alignment); err.nl();
	    if alignment != 0 then
	    {   if tree@.child[1]@.op == CONST then
	        {
		    var size: _uint;
		    size = tree@.child[0]@.type@.base@.base@.width/Target.membits;
//err.str("\tsize="); err.uint(size); err.nl();
//err.str("\tindex="); err.uint(_uint(tree@.child[1]@.valu)); err.nl();
		    alignment = CalcAlign(alignment,
			_uint(tree@.child[1]@.valu)*size);
		}
		else
		    alignment = 0;
	    }
	}
	is CLIST, SCON then	// constant aggregate
	    alignment = tree@.type@.align;
	else
	{   lex.ErrorS(NOTIMPL, "GetAlignment: unexpected node");
	    ast.Dump(tree);
	}
//err.str("GetAlignment: final align="); err.uint(alignment); err.nl();
	return alignment;
    }

    proc GetSize(node: Ast): Ast
    {   var size, nsize: Ast;
	var tsize: type.BitSize;

//err.str("GetSize\n"); ast.Dump(node);
	if node@.op
	is VAR then
	{   size = ast.Const(type.wordtype,
			     node@.type@.base@.width/Target.membits);
	}
	is INDEX, OFFSET then
	{   size = ast.Const(type.wordtype,
			     node@.type@.base@.width/Target.membits);
	}
	is SLICE then
	{   size = ast.Const(type.wordtype,
			     node@.type@.base@.base@.width/Target.membits);
	    size = ast.New2(MUL, type.wordtype, node@.child[2], size);        
	}
//err.str("returns\n"); ast.Dump(size);
	return size;
    }

    proc GetOffset(node: Ast): Ast
    {   var tree, ctree: Ast;

	tree = 0;
	if node@.op
	is OFFSET then
	{   var f: Symb;    // field symbol
	    var n, offset: _uint;   // field index
	    ctree = GetOffset(node@.child[0]);
	    // assert node@.child[0]@.type@.base@.kind == RECORD
	    offset = 0;
	    n = 0;
	    f = node@.child[0]@.type@.base@.list;
	    while f != 0 && n < node@.valu do
	    {   offset += f@.type@.width / Target.membits;
		f = f@.next;
		n += 1;
	    }
	    tree = ast.Const(type.wordtype, offset);		
	}   
	is INDEX then
	{
	    ctree = GetOffset(node@.child[0]);
	    // assert node@.child[0]@.type@.base@.kind == ARRAY
	    tree = ast.Const(type.wordtype,
		node@.child[0]@.type@.base@.base@.width / Target.membits);
	    tree = ast.New2(MUL, type.wordtype,
		ast.ExtendT(node@.child[1], type.wordtype), tree); 
	}
	if tree != 0 && ctree != 0 then
	    tree = ast.New2(ADD, type.wordtype, tree, ctree);
//err.str("GetOffset: final="); err.uint(offset); err.nl();
	return tree;
    }

    proc Slice(array: Ast, inx: Ast, len: Ast): Ast
    {   var at, st: Type;
	var tree: Ast;
	var blen, slen: type.BitSize;

//err.str("Slice: array=");  ast.Dump(array);
//err.str("inx="); ast.Dump(inx);
//err.str("len="); ast.Dump(len);
	at = array@.type@.base;
	st = type.New(ARRAY);       // FIXME: use Clone()?
	st@.base = at@.base;
	st@.packed = at@.packed;
	st@.memorder = at@.memorder;
	blen = 0;
	slen = 0;
	if !at@.flex then blen = type.BitSize(at.Span());
	if len != 0 then
	{   if len@.op == CONST then slen = type.BitSize(len@.valu);
	}
	else
	    len = ast.Const(type.wordtype, 0);  // stop error propagation
	if blen == 0 && slen == 0 then
	    st@.flex = true;
	else
	{   if slen == 0 then
	    {	slen = blen;	// worst case
		if inx@.op == CONST then
		    slen = blen - type.BitSize(inx@.valu);
	    }
	    else
	    {   // check slen < blen unless olen == 0
	    }
	    st@.hi = slen - 1;
	}
	st@.size = at@.base@.size * slen;
	st@.width = st@.size;
	if inx != 0 then
	{   if inx@.op == CONST then
	    {   var offs: _uint;
		offs = _uint(inx@.valu) * (at@.base@.width/Target.membits);
		st@.align = CalcAlign(at@.align/Target.membits, offs) *
		    Target.membits;
	    }
	    else    // Just take the alignment of the base type.
		st@.align = at@.base@.align;
	}
	else
	    inx = ast.Const(type.wordtype, 0);  // stop error propagation
	tree = ast.New2(SLICE, type.MakeRef(st), array, inx);
	tree = ast.Child(tree, len);
	return tree;
    }

    proc Load(tree: Ast): Ast
    {   var t: Type;

	if tree == 0 then return tree;
//err.str("Load: "); ast.Print(tree);
	t = tree@.type;
	if t@.kind == REF then
	{   t = t@.base;
	    if t != 0 then
	    {   tree = ast.New1(LOAD, t, tree);
		tree@.width = t@.width;
		if type.NeedSwap(tree@.type, Target.memorder) then
		{   tree = ast.New1(REVB, tree@.type, tree);
		    tree@.type = type.ChangeOrder(tree@.type, Target.memorder);
		}
	    }
	    else lex.Error(BADREF);
	}
	else if tree@.op != FIELD then        
	{   lex.ErrorS(COMPILER, "Load via non-REF");
ast.Dump(tree);
	}
	return tree;
    }

    proc CoerceToRef(tree: Ast): Ast
    {
	if tree@.op == LOAD then
	    tree = tree@.child[0];		// undo the load
	else if tree@.op == REVB && tree@.child[0]@.op == LOAD then
	    tree = tree@.child[0]@.child[0];
	// FIXME: this is very likely wrong
	if tree@.op
	is SCON, CLIST then
	    tree = ast.New1(BYREF, type.MakeRef(tree@.type), tree);
	is VAR then
	    {}
	else
	    tree = ast.New1(BYREF, tree@.type, tree);
	return tree;
    }

    proc CheckRefAttributes(to: Type, fm: Type): boolean
    {
	if to == 0 || fm == 0 then return false;
	// Check endian
	if to@.memorder != fm@.memorder then
	    return false;
	// Check alignment
	if to@.align > fm.align then
	    return false;
	if to@.kind == REF && fm@.kind == REF then
	    return CheckRefAttributes(to@.base, fm@.base);
	return true;
    }

    proc Adjust(tree: Ast, to: Type): Ast
    {   var fm: Type;
	var ok: boolean;

	fm = tree@.type;
	if fm == 0 then		// undefined type
	    return tree;
	ok = true;
	if to@.kind
	is REF then
	{   if to@.base != 0 then
	    {   if fm@.kind == REF && (to@.base == type.memtype || type.Compat(to, fm)) then
		{   if fm != to then
		    {   tree = ast.Cast(tree, to);
			fm = tree@.type;
		    }
		}
		else
		{   tree = CoerceToRef(tree);
		    fm = tree@.type;
		    // Coerce to REF memtype is always OK
		    if to@.base == type.memtype || type.Compat(to, fm) then
		    {   if fm != to then
			{   tree = ast.Cast(tree, to);
			    fm = tree@.type;
			}
		    }
		    else ok = false;
		}
		// Fix types when formal is a flex
		if to@.flex && !fm@.flex then
		    tree = ast.New1(CAST, to, tree);
		// Check attributes
		if !CheckRefAttributes(to, fm) then
		    lex.ErrorS(NOTIMPL, "Ref alignment or endian mismatch\n");
	    }
	}
	is REFPROC then
	{   ok = type.Compat(to, fm);
	}
	is ENUM then
	{   ok = type.Compat(fm, to);
	    if !ok && fm.kind == UINT then ok = true;
	    if to@.width != tree@.width then
		tree = ast.ExtendT(tree, to);
	}
	is UINT then
	{   ok = type.Compat(fm, to);
	    if !ok then
	    {   if fm.kind
		is ENUM then ok = true;
		is SINT then
		{   if feature.trunc then lex.Error(TOUNSIGN);
		    ok = true;
		}
	    }
	    if to@.width != tree@.width then
		tree = ast.ExtendT(tree, to);
	}
	is SINT then
	{   ok = type.Compat(fm, to);
	    if !ok && fm.kind == UINT then
	    {   if feature.trunc then lex.Error(TOSIGNED);
		ok = true;
	    }
	    if to@.width != tree@.width then
		tree = ast.ExtendT(tree, to);
	}
	is FLOAT then
	{
	    if to@.width != tree@.width then
		tree = ast.ExtendT(tree, to);
	}
	is RECORD, ARRAY then
	{   if fm.packed && to.packed then
	    {   ok = type.Compat(fm, to);
	        if ok && to@.width != tree@.width then
		    tree = ast.ExtendT(tree, to);		
	    }
	}
	if !ok then
{
	    lex.Error(TYPEASSIGN);
err.str("fm=\n"); ast.Dump(tree);
err.str("\nto=\n"); type.DumpT(to, false);
err.nl();
}
//	tree = CheckSwap(lhs, tree);    // FIXME - do for parms and retv?
	return tree;
    }

    proc IsSignedBinOp(lhs: Ast, rhs: Ast): boolean
    {
	if lhs@.type@.kind == SINT || rhs@.type@.kind == SINT then
	    return true;
	return false;
    }

    proc FindFlexSize(t: Type): type.BitSize
    {   var size: type.BitSize;
	var bt: Type;

	size = 1;   // some default
	if t != 0 then
	{   if t@.flex then
	    {   if t@.kind
		is ARRAY then
		    bt = t@.base;
		is RECORD then
		{   var f: Symb;
		    bt = 0;
		    f = t@.list;
		    while f != 0 do
		    {   bt = f@.type;
			f = f@.next;
		    }
		}
		if bt != 0 then size = FindFlexSize(bt);
	    }
	    else
		size = t@.width/Target.membits;
	}
	return size;
    }

    proc GetSizeSpec(t: Type): Ast
    {   var size, temp: Ast;
	var tok: TokenT;

        tok = Token;
	size = ast.Const(type.wordtype, t@.width/Target.membits);
	if tok == PBEG then
	{   tok = Next();
	    if !t@.flex then
		lex.Error(NOSIZE);
	    temp = Const(type.wordtype);
	    temp = ast.New2(MUL, type.wordtype, temp,
		ast.Const(type.wordtype, FindFlexSize(t)));
	    size = ast.New2(ADD, type.wordtype, size, temp);
	    tok = lex.Expect(PEND);
	}
	else if t@.flex then
	    lex.Error(NEEDSIZE);
	return size;
    }

    proc GetSpaceSpec(t: Type): Ast
    {   var space: Ast;
	var tok: TokenT;
    
        tok = Token;
	if tok == COMMA then
	{   tok = Next();
	    space = Const(type.wordtype);
	}
	else
	    space = ast.Const(type.wordtype, 0);
	return space;
    }

    proc SizeSpace(t: Type): Ast, Ast
    {   var size, space, temp: Ast;
	var tok: TokenT;

        tok = Token;
	size = ast.Const(type.wordtype, t@.width/Target.membits);
	if tok == PBEG then
	{   tok = Next();
	    if !t@.flex then
		lex.Error(NOSIZE);
	    temp = Const(type.wordtype);
	    temp = ast.New2(MUL, type.wordtype, temp,
		ast.Const(type.wordtype, FindFlexSize(t)));
	    size = ast.New2(ADD, type.wordtype, size, temp);
	    tok = lex.Expect(PEND);
	}
	else if t@.flex then
	    lex.Error(NEEDSIZE);
	if tok == COMMA then
	{   tok = Next();
	    space = Const(type.wordtype);
	}
	else
	    space = ast.Const(type.wordtype, 0);
	return size, space;
    }

    proc New(): Ast
    {   var tree, size: Ast;
	var s: Symb;
	var tok: TokenT;
	var t: Type;

	tree = 0;
	tok = Token;
	if tok == ID then
	{   t = 0;
	    s = symb.FindKind(lex.Ident, TYPE);
	    if s != 0 then
		t = s@.type;
	    tok = Next();
	    if t != 0 then
	    {   size = GetSizeSpec(t);
		tree = ast.New(CALL, 0);
		tree@.symb = symb.libnew;
		tree@.type = type.addrtype;
		tree@.width = Target.ptr.size;
		tree = ast.Child(tree, size);
		tree = ast.Child(tree,
			   ast.Const(type.wordtype, t@.align/Target.membits));
		tree = ast.Child(tree, GetSpaceSpec(t));
		tree = ast.New1(CAST, type.MakeRef(s@.type), tree);
	    }
	}
	else lex.Error(EXPECTID);
	return tree;
    }

    proc Delete(): Ast
    {   var tree, varb, size, temp: Ast;
	var tok: TokenT;
	var t: Type;

	tree = 0;
	varb = GetLHS(0);
	tok = Token;
	if varb != 0 then
	{   varb = Load(varb);
	    t = varb@.type@.base;
	    if t != 0 then
	    {   size = GetSizeSpec(t);
		tree = ast.New(CALL, 0);
		tree@.symb = symb.libdel;
		temp = ast.New1(CAST, type.addrtype, varb);
		tree = ast.Child(tree, temp);
		tree = ast.Child(tree, size);
		tree = ast.Child(tree, GetSpaceSpec(t));
	    }
	}
	else lex.Error(EXPECTID);
	return tree;
    }

    proc Zero(): Ast
    {   var tree, temp, size: Ast;
	var t: Type;
	var align: _uint;
	var tok: TokenT;

	tree = GetLHS(0);
	tok = Token;
	if tree != 0 then
	{
	    if tree@.op
	    is VAR then
	    {   if tree@.type@.kind == REF then
		{   t = tree@.type@.base;
		    if t@.kind == REF then
		    {   // dereference the pointer
			tree = ast.New1(LOAD, t, tree);
			t = t@.base;
		    }
		}
		else
		{   lex.ErrorS(COMPILER, "expr.Zero: VAR not REF");
		    return 0;
		}
		size = ast.Const(type.wordtype, t@.width/Target.membits);
		align = t@.align/Target.membits;
		if tok == PBEG then
		{   tok = Next();
		    if !t@.flex then
			lex.Error(NOSIZE);
		    temp = Const(type.wordtype);
		    temp = ast.New2(MUL, type.wordtype, temp,
			ast.Const(type.wordtype, FindFlexSize(t)));
		    size = ast.New2(ADD, type.wordtype, size, temp);
		    tok = lex.Expect(PEND);
		}
	    }
	    else
	    {   size = GetSize(tree);
		align = GetAlignment(tree);
	    }
	    tree = ast.New3(SET, type.unkntype, tree,
			    ast.Const(type.bytetype, 0), size);
	    tree = ast.Child(tree, ast.Const(type.wordtype, align));
	}
	return tree;
    }

    proc IntrinsicUnary(op: ast.Op): Ast
    {   var tree: Ast;

	tree = Bool(0);
	tree = ast.OpUnary(op, tree);
	return tree;
    }

    proc Rotate(right: boolean): Ast
    {   var tok: TokenT;
        var tree, shft: Ast;
        var op: ast.Op;

	tree = Bool(0);
	if tree@.type@.kind != UINT then
	    lex.Error(OPTYPE);
	if Token == COMMA then
	{   tok = Next();
	    shft = Bool(0);
	}
	else
	    lex.ErrorT(EXPECT, COMMA);
	if right then op = ROR; else op = ROL; 
	tree = ast.New2(op, tree@.type, tree, shft);  
	return tree;
    }

    proc Convert(): Ast
    {   var tok: TokenT;
        var tree: Ast;
        var t: Type;
        var s: Symb;
        var to, fm: TypeT;
        var op: ast.Op;

	tree = 0;
	t = 0;
        tok = Token;
        if tok == ID then
        {   s = symb.Find(lex.Ident);
	    if s != 0 then
	    {   if s@.kind == TYPE then
		    t = s@.type;
		else lex.Error(NOTTYPE);
	    }
	    else lex.ErrorS(UNDEFID, lex.Ident);
	    tok = Next();        
	    if tok == COMMA then
	    {   tok = Next();
		tree = Bool(0);
		if tree != 0 && t != 0 then
		{   to = t@.kind;
		    fm = tree@.type@.kind;
		    // FIXME - much more needed here
		    op = NULL;
		    if to
		    is  FLOAT then
		    {   if fm
			is UINT then op = CVTUF;
			is SINT then op = CVTIF;
		    }
		    is UINT then
		    {   if fm == FLOAT then op = CVTFU;
		    }
		    is SINT then
		    {   if fm == FLOAT then op = CVTFI;
		    }
		    if op != NULL then
		    {   tree = ast.New1(op, t, tree);
			tree@.width = t@.width;
		    }
		}
	    }
        }
        else lex.Error(NOTTYPE);
        return tree;
    }

    proc Intrinsic(ps: Symb): Ast
    {   var tree, lhs, rhs: Ast;
	var tok: TokenT;
	var which: symb.IntrinsicT;
	var op: ast.Op;

	tree = 0;
	tok = Token;
	if tok == PBEG then
	{   tok = Next();
	    which = symb.IntrinsicT(ps@.addr);
	    if which
	    is DEF then
	    {   if tok == ID then
		    tree = ast.Const(type.booltype,
				     _uint(symb.IsDefined(lex.Ident)));
		else lex.Error(EXPECTID);
	    }
	    is ABS then
	    {   tree = IntrinsicUnary(ABS);
		if tree != 0 && tree@.type@.kind == SINT then
		    tree@.type = target.utype(tree@.width);
	    }
	    is MIN, MAX then
	    {   lhs = Bool(0);
		lex.Expect(COMMA);
		rhs = Bool(0);
		if lhs != 0 && rhs != 0 then
		{   if IsSignedBinOp(lhs, rhs) then
			if which == MIN then op = SMIN; else op = SMAX;
		    else
			if which == MIN then op = UMIN; else op = UMAX;
		    tree = ast.OpMinMax(op, lhs, rhs);
		}
	    }
	    is ZLEN then
	    {   var align: _uint;
	        lhs = GetLHS(0);
		if lhs@.op == LOAD && lhs@.type@.kind == ARRAY then	// undo LOAD
		    lhs = lhs@.child[0];
		if lhs@.type@.kind != REF || lhs@.type@.base@.kind != ARRAY ||
		   lhs@.type@.base@.base@.kind != UINT ||
		   lhs@.type@.base@.base@.width != Target.membits then
		    lex.Error(OPTYPE);
	        align = GetAlignment(lhs);
	        tree = ast.New2(ZLEN, type.wordtype, lhs,
				ast.Const(type.wordtype, align));
		tree@.width = type.wordtype@.width;
	    }
	    is CLZ   then tree = IntrinsicUnary(CLZ);
	    is CLZNZ then tree = IntrinsicUnary(CLZNZ);
	    is CTZ   then tree = IntrinsicUnary(CTZ);
	    is CTZNZ then tree = IntrinsicUnary(CTZNZ);
	    is POP   then tree = IntrinsicUnary(POP);
	    is ROL   then tree = Rotate(false);
	    is ROR   then tree = Rotate(true);
	    is CVT   then tree = Convert();
	    is ZERO  then tree = Zero();
	    is NEW   then tree = New();
	    is DEL   then tree = Delete();
	    else
		lex.ErrorS(COMPILER, "Intrinsic unknown");
	    tok = lex.Expect(PEND);
	}
	else lex.ErrorT(EXPECT, PBEG);
	return tree;
    }

    proc Call(ps:Symb, tree: Ast, arg: Ast): Ast
    {   var t: Type;
	var s: Symb;
	var tok: TokenT;

	t = ps@.type;
	if tree == 0 then	// direct call
	    tree = ast.New(CALL, t);
	else			// indirect call
	    tree = ast.New1(CALLI, t, tree);
	tree@.symb = ps;
	if t != 0 then		// has returned value
	    tree@.width = t@.width;
	else
	    tree@.type = type.unkntype;
	s = ps@.parmlist;
	if arg != 0 then	// method call
	{   // assert s != 0
	    arg = Adjust(arg, s@.type);
	    tree = ast.Child(tree, arg);
	    s = s@.next;
	}
	tok = Token;
	if tok == PBEG then
	{   tok = Next();
	    if tok != PEND then
	    {   loop
		{
		  exit s == 0 with
		    {   lex.Error(ARGSHI);
			tok = lex.Skip(skiplist);
		    }
		    arg = Bool(s@.type);
		    if arg != 0 then
			arg = Adjust(arg, s@.type);
		    tree = ast.Child(tree, arg);
		    s = s@.next;
		    tok = Token;
		  exit tok != COMMA;
		    tok = Next();
		}
	    }
	    tok = lex.Expect(PEND);
	}
	else
	    lex.ErrorT(EXPECT, PBEG);
	if s != 0 && s@.linkage == FORMAL then
	    lex.Error(ARGSLO);
	return tree;
    }

    proc RefProc(s: Symb): Ast
    {   var t: Type;
	var tree: Ast;

	// must create a REFPROC type to point at proc symbol
	t = type.New(REFPROC);
	t@.list = s;
	tree = ast.New(VAR, t);
	tree@.symb = s;
	return tree;
    }

    proc BitfieldOffset(t: Type, fno: type.Valu): type.BitSize
    {   var foffs, rsize, fsize: type.BitSize;
	var s: Symb;
	var i: ast.NSubNodes;

        //if t@.kind == REF then t = t@.base;
	// assert t@.kind == RECORD
	rsize = t@.width;
	if t@.bitorder == MSB then foffs = rsize; else foffs = 0;
	s = t@.list;
	i = 0;
	while s != 0 do
	{   fsize = s@.type@.size;
	    if t@.bitorder == MSB then foffs -= fsize;
	  exit i == fno;
	    if t@.bitorder != MSB then foffs += fsize;
	    s = s@.next;
	    i += 1;
	}
	return foffs;
    }

    proc UnLoad(tree:Ast): Ast
    {
	if tree@.op == LOAD then
	    tree = tree@.child[0];
	// FIXME - REVB-LOAD
else
{   lex.ErrorS(COMPILER, "UnLoad error");
    ast.Dump(tree);
}
	return tree;
    }

    proc Suffix(tree: Ast, et: Type): Ast
    {   var t, bt: Type;
	var tok: TokenT;
	var done: boolean;
	var s: Symb;

	tok = Token;
	done = false;
	while !done && tree != 0 && tree@.type != 0 do
	{   t = tree@.type;
//lex.WhereAmI("Suffix TOP");  ast.Dump(tree);
	    if tok
	    is AT then
	    {   tok = Next();
		if t@.kind == REF then
		{
		    tree = Load(tree);
		    // FIXME - endian?
		}
		else if t@.kind == REFPROC then
		{   tree = Call(t@.list, tree, 0);
		    tok = Token;
		}
		else lex.Error(NOTREF);
	    }
	    is DOT then
	    {   tok = Next();
		{   if tok == ID then
		    {   bt = t;
			if t@.kind == REF then bt = t@.base;
			s = 0;
			loop
			{ exit bt == 0;
			    s = symb.FindMethod(bt@.meths, lex.Ident);
			  exit s != 0;
			    bt = bt@.base;
			}
			if s != 0 then		// method call
			{   tok = Next();
//err.str("Method use: ");  err.str(s@.ident); err.nl(); ast.Dump(tree);
			    if tok == PBEG then
			    {   tree = Call(s, 0, tree);
				tok = Token;
			    }
			    else
				tree = RefProc(s);
			}
			else
			{
			    if t@.kind == REF then
			    {   if t@.base != 0 then
				{   // FIXME - optimize Load followed by UnLoad?
				    tree = Load(tree);
				    t = t@.base;
				}
				else
				{   lex.Error(BADREF);
				    tree = 0;	// give up
				}
			    }
			    if t@.kind == RECORD then
			    {   s = symb.FindLocal(t@.list, lex.Ident);
				tok = Next();
				if s != 0 then
				{
				    if t@.packed then
				    {
					tree = ast.New2(FIELD, s@.type, tree,
					    ast.Const(type.wordtype, 
					    BitfieldOffset(t, s@.addr)));
					tree@.valu = s@.type@.size;
					tree@.width = s@.type@.width;
				    }
				    else
				    {   tree = UnLoad(tree);
					tree = ast.New1(OFFSET,
						type.MakeRef(s@.type), tree);
					tree@.valu = s@.addr;
					tree@.width = Target.ptr.size;
					tree = Load(tree);
				    }
				}
			    }
			    else
{
				lex.Error(NOTRECORD);
type.DumpT(t, false); err.nl();
}
			}
		    }
		    else lex.Error(EXPECTID);
		}
	    }
	    is ABEG then
	    {   tok = Next();
		if t@.kind == REF then
		{   if t@.base != 0 then
		    {   // FIXME - optimize Load followed by UnLoad?
			tree = Load(tree);
			t = t@.base;
		    }
		    else
		    {   lex.Error(BADREF);
			tree = 0;	// give up
		    }
		}
		if t@.kind == ARRAY then
		{   var index: Ast;
		    index = Bool(t@.index);
		    if index == 0 then
		    {   lex.Error(BADINXEXP);
			index = ast.Null;
		    }
		    if t@.lo != 0 then
			index = ast.New2(SUB, t@.index, index,
					 ast.Const(t@.index, t@.lo));
		    tok = Token;
		    if tok == COLON then	// array slice
		    {   var len: Ast;
			tok = Next();
			tree = UnLoad(tree);
			len = Bool(t@.index);	// index type?
			tree = Slice(tree, index, len);
			tree = Load(tree);
			done = true;
		    }
		    else			// normal indexed
		    {
			if t@.packed then
			{
			    index = ast.ExtendT(index, type.wordtype);
			    index = ast.New2(MUL, type.wordtype, index,
				    ast.Const(type.wordtype, t@.base@.size));
			    tree = ast.New2(FIELD, t@.base, tree, index);
			    tree@.valu = t@.base@.size;
			    tree@.width = t@.base@.width;
			}
			else
			{
			    tree = UnLoad(tree);
			    tree = ast.New2(INDEX, type.MakeRef(t@.base),
					    tree, index);
			    tree@.width = Target.ptr.size;
			    tree = Load(tree);
			}
		    }
		}
		else        
		    lex.Error(NOTARRAY);
		tok = lex.Expect(AEND);
	    }
	    else done = true;
	}
	return tree;
    }

    proc Primary(s:Symb, et:Type): Ast
    {   var tree: Ast;
	var t: Type;

	tree = 0;
	t = s@.type;
	if s@.kind
	is VAR then
	{   tree = ast.New(VAR, type.MakeRef(t));
	    tree@.symb = s;
	    tree@.width = t@.width;
	    tree = Load(tree);
	}
	is CONSTANT then
	{   if t@.kind <= REF || t@.packed then
		tree = ast.Dup(s@.const);
	    else	// treat like a var
	    {   tree = ast.New(VAR, type.MakeRef(t));
		tree@.symb = s;
		tree@.width = t@.width;
		tree = Load(tree);
	    }
	}
	is PROC then
	{   if s@.addr != 0 then
		tree = Intrinsic(s);
	    else
	    {   if Token == PBEG then
		    tree = Call(s, 0, 0);
		else
		    tree = RefProc(s);
	    }
	}
	else lex.ErrorI(BADID, s@.ident);	// FIXME - need better message
	tree = Suffix(tree, et);
	return tree;
    }

    proc GetLHS(s: Symb): Ast
    {   var tok: TokenT;
	var tree: Ast;

	if s == 0 then
	{   tok = Token;
	    if tok == ID then
	    {   s = symb.Find(lex.Ident);
		tok = Next();
		if s == 0 then
		{   lex.ErrorI(UNDEFID, lex.Ident);
		    return 0;
		}
	    }
	    else
	    {   lex.Error(EXPECTID);
		return 0;
	    }
	}
	tree = Primary(s, 0);
	// undo the load  FIXME - same as UnLoad()?
	if tree@.op == LOAD then
	    tree = tree@.child[0];
	else if tree@.op == REVB && tree@.child[0]@.op == LOAD then
	    tree = tree@.child[0]@.child[0];
	return tree;
    }

    proc Container(tree: Ast, t: Type): Ast
    {   var otree: Ast;

	otree = ast.New(VAR, type.MakeRef(t));
	otree@.symb = 0;
	otree@.width = t@.width;
	otree = Load(otree);
	otree = Suffix(otree, t);
	otree = UnLoad(otree);
	if otree != 0 then
	    otree = GetOffset(otree);
	if otree != 0 then
	{   tree = ast.Cast(tree, type.wordtype);
	    tree = ast.New2(SUB, type.wordtype, tree, otree);
	    tree = ast.Cast(tree, t);
	}
	return tree;                  
    }

    proc Term(et:Type): Ast
    {   var tree: Ast;
	var tok: TokenT;
	var t: Type;
	var s: Symb;

	tree = 0;
	tok = Token;
	if tok
	is ID then
	{   if savedsym == 0 then
		s = symb.Find(lex.Ident);
	    else
	    {   s = savedsym;
		savedsym = 0;
	    }
	    if s != 0 then
	    {   tok = Next();
		if s@.kind == TYPE then
		{   t = s@.type;
		    if tok
		    is DOT then		// possible enum const
		    {   tok = Next();
			if t@.kind == ENUM then
			{   tree = EnumConst(t);
			    tok = Next();
			}
			else
			    lex.ErrorI(BADTYPE, s@.ident);
		    }
		    is QUEST then		// property
		    {   tok = Next();
			tree = TypeProperty(t);
		    }
		    is PBEG then		// cast
		    {   tok = Next();
			tree = Bool(0);	// FIXME: is this right?
			tok = Token;
			if tok == COMMA then
			{   tok = Next();
			    tree = Container(tree, t);
			}
			else    // simple cast
			    tree = ast.Cast(tree, t);
			tok = lex.Expect(PEND);
		    }
		    is GBEG then		// composite
			tree = CompositeValue(t);
		}
		else
		{
		    tree = Primary(s, et);
		    tok = Token;
		    if tok == QUEST then
		    {   tok = Next();
			tree = TypeProperty(tree@.type);
		    }
		}
	    }
	    else    // unknown symbol, perhaps an enum constant
	    {   if et != 0 && et@.kind == ENUM then	// enum context
		    tree = EnumConst(et);
		else lex.ErrorI(UNDEFID, lex.Ident);
		tok = Next();
	    }
	}
	is NUM then
	{   tree = ast.New(CONST, et);
	    tree@.valu = lex.Number;
	    tree@.width = type.bitsize(lex.Number);
	    if et == 0 then
		tree@.type = type.wordtype;	// FIXME: ?
	    else
	    {   if et@.kind == REF then		    // want pointer constant
		{   tree@.type = et;
		    tree@.width = Target.ptr.size;
		}
		else
		{   if et@.size > tree@.width then   // widen
			tree@.width = et@.size;
		}
	    }
	    tok = Next();
	}
	is FNUM then
	{   tree = ast.New(FCON, et);
	    tree@.valu = lex.Number;
	    tree@.width = 64;			// FIXME: ?
	    tree@.scale = lex.Scale;
	    if et == 0 then
		tree@.type = type.floattype;
	    tok = Next();
	}
	is STR then
	    tree = String();
	is PBEG then
	{   tok = Next();
	    tree = Bool(et);
	    tok = Token;
	    lex.Expect(PEND);
	}
	is GBEG then
	    tree = CompositeValue(et);
	return tree;
    }

    proc Unary(t:Type): Ast
    {   var tree: Ast;
	var tl: Type;
	var tok, savetok: TokenT;

	tok = Token;
	savetok = tok;
	if tok
	is MINUS, PLUS, INV, NOT then tok = Next();
	tree = Term(t);
	if tree != 0 then
	{   tl = tree@.type;
	    if savetok
	    is MINUS then
	    {   if tree@.type@.kind == FLOAT then
		    tree = ast.OpUnary(FNEG, tree);
		else
		{
		    tree = ast.OpUnary(NEG, tree);
		    if tree@.type@.kind == UINT then
			tree@.type = target.stype(tree@.width);
		}
	    }
	    is INV then
		tree =ast.OpUnary(NOT, tree);
	    is NOT then
	    {   tree = ast.ForceBoolean(tree);
		tree = ast.OpUnary(BNOT, tree);
	    }
	}
	return tree;
    }

    const mulop: []ast.Op = { MUL, DIV, MOD, LSL, LSR, AND  };
    const fmulop:[]ast.Op = { FMUL,FDIV,FREM,NULL,NULL,NULL };
    proc Mul(t:Type): Ast
    {   var tree, rhs: Ast;
	var op: ast.Op;
	var tok, stok: TokenT;

	tree = Unary(t);
	if tree != 0 then
	{   loop
	    {   tok = Token;
	      exit tok < STAR || tok > AND;
	        stok = tok;
		tok = Next();
		rhs = Unary(tree@.type);
	      exit rhs == 0;
		if tree@.type@.kind == FLOAT then
		    tree = ast.OpFloat(fmulop[stok - STAR], tree, rhs, t);
		else
		{   op = mulop[stok - STAR];
		    if op
		    is AND then tree = ast.OpLogic(op, tree, rhs);
		    is MUL then tree = ast.OpMul(op, tree, rhs, t);
		    is DIV, MOD then tree = ast.OpDiv(op, tree, rhs, t);
		    is LSL then
		    {   if tree@.type@.kind == SINT then op = ASL;
			tree = ast.OpMul(op, tree, rhs, t);
		    }
		    is LSR then
		    {   if tree@.type@.kind == SINT then op = ASR;
			tree = ast.OpDiv(op, tree, rhs, t);
		    }
		}
	    }
	}
	return tree;
    }

    const addop: []ast.Op = { ADD, SUB, OR,  XOR  };
    const faddop:[]ast.Op = { FADD,FSUB,NULL,NULL };
    proc Add(t:Type): Ast
    {   var tree, rhs: Ast;
	var op: ast.Op;
	var tok, stok: TokenT;

	tree = Mul(t);
	if tree != 0 then
	{   loop
	    {   tok = Token;
	      exit tok < PLUS || tok > XOR;
	        stok = tok;
		tok = Next();
		rhs = Mul(tree@.type);
	      exit rhs == 0;
		if tree@.type@.kind == FLOAT then
		    tree = ast.OpFloat(faddop[stok - PLUS], tree, rhs, t);
		else
		{   op = addop[stok - PLUS];
		    if op < OR then
			tree = ast.OpAdd(op, tree, rhs, t);
		    else
			tree = ast.OpLogic(op, tree, rhs);
		}
	    }
	}
	return tree;
    }


    const ucmpop: []ast.Op = { EQ, NE, ULT, UGT, ULE, UGE };
    const scmpop: []ast.Op = { EQ, NE, SLT, SGT, SLE, SGE };
    proc ArrayCompare(op: ast.Op, lhs: Ast, rhs: Ast): Ast
    {   var tree: Ast;
	var lsize, rsize, align: Ast;
	var lalign, ralign: _uint;

	// FIXME: share code with stmt.AssignArray?
	if lhs@.type@.packed then
	{   if !rhs@.type@.packed then
		lex.ErrorS(NOTIMPL, "ArrayCompare: packed and not packed");
//	    lhs@.kind = UINT;   //FIXME
//	    rhs@.kind = UINT;   //FIXME
	    if op == AEQ then op = EQ; else op = NE;
	    tree = ast.New2(op, type.booltype, lhs, rhs);
	    tree@.width = 1;
	    return tree;
	}
	// FIXME the compares on lhs@.op and rhs@.op can be optimized
	if lhs@.op == LOAD && lhs@.type@.kind == ARRAY then	// undo LOAD
	    lhs = lhs@.child[0];
	if rhs@.op == LOAD && rhs@.type@.kind == ARRAY then	// undo LOAD
	    rhs = rhs@.child[0];
	if lhs@.op == CLIST || lhs@.op == SCON then
	    lhs = ast.New1(BYREF, type.MakeRef(lhs@.type), lhs);
	if rhs@.op == CLIST || rhs@.op == SCON then
	    rhs = ast.New1(BYREF, type.MakeRef(rhs@.type), rhs);
	lalign = GetAlignment(lhs);
	ralign = GetAlignment(rhs);
//err.str("ArrayCompare lalign="); err.uint(lalign);
//err.str(" ralign="); err.uint(ralign); err.nl();
	if ralign < lalign then lalign = ralign;
	if lhs@.op == SLICE then
	    lsize = lhs@.child[2];
	else
	    lsize = ast.Const(type.wordtype, lhs@.type@.base@.Span());
	if rhs@.op == SLICE then
	    rsize = rhs@.child[2];
	else
	    rsize = ast.Const(type.wordtype, rhs@.type@.base@.Span());
//err.str("ArrayCompare lsize=\n"); ast.Dump(lsize);
//err.str("rsize=\n"); ast.Dump(rsize);
	tree = ast.New2(op, type.booltype, lhs, rhs);
	tree@.width = 1;
	tree = ast.Child(tree, lsize);
	align = ast.Const(type.wordtype, lalign);
	tree = ast.Child(tree, align);
	return tree;
    }
 
    proc NodeKind(node: Ast): TypeT
    {   var kind: TypeT;

	if node@.op
	is VAR, SLICE, INDEX, OFFSET then
	    kind = node@.type@.base@.kind;
	else
	    kind = node@.type@.kind;
//err.str("NodeKind kind="); err.str(type.KindName[kind]); err.nl();
//ast.Dump(node);
	return kind;
    }

    proc Compare(t:Type): Ast
    {   var tree, rhs: Ast;
	var tok, savetok: TokenT;
	var op: ast.Op;
	var ok: boolean;

	tree = Add(t);
	tok = Token;
	if tok >= EQ && tok <= GE then
	{   savetok = tok;
	    tok = Next();
	    if tree != 0 then
	    {   rhs = Add(tree@.type);
		if rhs != 0 then
		{   ok = type.Compat(tree@.type, rhs@.type);
		    if NodeKind(tree)
		    is ENUM, UINT, SINT then
		    {   if IsSignedBinOp(tree, rhs) then
			    op = scmpop[savetok - EQ];
			else
			    op = ucmpop[savetok - EQ];
			tree = ast.OpCompare(op, tree, rhs);
		    }
		    is REF, REFPROC then
		    {   if savetok
			is EQ then op = EQ;
			is NE then op = NE;
			else ok = false;
			if ok then
			    tree = ast.OpCompare(op, tree, rhs);
		    }
		    is RECORD then
		    {   if NodeKind(rhs) == RECORD &&
			   tree@.type@.packed && rhs@.type@.packed then
			{   if savetok
			    is EQ then op = EQ;
			    is NE then op = NE;
			    else ok = false;
			    if ok then
				tree = ast.OpCompare(op, tree, rhs);
			}
			else ok = false;
		    }
		    is ARRAY then
		    {   if NodeKind(rhs) == ARRAY then
			{   if tree@.type@.packed && rhs@.type@.packed then
			    {   if savetok
				is EQ then op = EQ;
				is NE then op = NE;
				else ok = false;
				if ok then
				    tree = ast.OpCompare(op, tree, rhs);
			    }
			    else
			    {   if savetok
				is EQ then op = AEQ;
				is NE then op = ANE;
				else ok = false;
				if ok then
				    tree = ArrayCompare(op, tree, rhs);
			    }
			}
			else ok = false;
		    }
		    else ok = false;
		    if !ok then
			lex.Error(BADCOMPARE);
		}
	    }
	}
	return tree;
    }

    proc BoolAnd(t:Type): Ast
    {   var tree, rhs: Ast;
	var tok: TokenT;

	tree = Compare(t);
	loop
	{   tok = Token;
	  exit tok != BAND;
	    tok = Next();
	    rhs = Compare(tree@.type);
	    tree = ast.OpBool(BAND, tree, rhs);
	}
	return tree;
    }

    proc Bool(t:Type): Ast
    {   var tree, rhs: Ast;
	var tok: TokenT;

	tree = BoolAnd(t);
	loop
	{   tok = Token;
	  exit tok != BOR;
	    tok = Next();
	    rhs = BoolAnd(tree@.type);
	    tree = ast.OpBool(BOR, tree, rhs);
	}
	return tree;
    }


    proc Const(t: Type): Ast
    {   var tree: Ast;

	if t != 0 then
	{   if t@.kind
	    is REF then
	    {	if Token
		is GBEG, STR then
		{   tree = Const(t@.base);
		    tree = ast.New1(BYREF, t, tree);
		}
		else
		{   tree = Bool(t);
		    if tree != 0 then
		    {   if tree@.op
			is CONST then   // pointer constant
			    tree@.type = t;
			is LOAD then    // reference to stored const
			{
			    tree = tree@.child[0];
			    // assert tree@.op == VAR
			    if t@.base@.flex && !tree@.type@.base@.flex then
				tree = ast.New1(CAST, t, tree);
			}
			else if tree@.type != t then
			{   if type.Compat(tree@.type, t@.base) then
				tree = CoerceToRef(tree);
			    else
				lex.Error(BADCOMPV);
			}
		    }
		}
	    }
	    is RECORD then tree = RecordConst(t);
	    is ARRAY then  tree = ArrayConst(t);
	    is REFPROC then tree = Bool(t);     // FIXME?
	    else
	    {   tree = Bool(t);	    // scalar
		if tree != 0 then
		{   tree = ast.Extend(tree, t@.width, false);   // usually truncates
		    tree@.type = t;
		}
	    }
	}
	else tree = Bool(t);		// unknown type
	return tree;
    }

    proc ConstValue(t: Type): Valu
    {   var tree: Ast;
	var rv: Valu;

	rv = 0;
	tree = Bool(t);
	if tree != 0 then
	{   if tree@.op == CONST then
	    {   // FIXME: should check that types are compatable
		rv = tree@.valu;
		// free(tree)
	    }
	    else if tree@.op == LOAD &&
		    tree@.child[0]@.op == CONST then
	    {
		rv = tree@.child[0]@.valu;
	    }
	}
	else
	    lex.Error(EXPCONST);
	return rv;
    }

    proc ConstString(): Symb
    {   var tree: Ast;

	tree = expr.Bool(0);
	if tree != 0 then
	{   if tree@.op == SCON then
		return tree@.symb;
	    else if tree@.op == LOAD &&
		    tree@.child[0]@.op == VAR &&
		    tree@.child[0]@.symb@.const != 0 &&
		    tree@.child[0]@.symb@.const@.op == SCON then
	    {
		return tree@.child[0]@.symb@.const@.symb;
	    }
	}
	return 0;
    }
}
// vim: ts=8 sw=4 noet nowrap

