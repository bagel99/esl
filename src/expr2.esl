// Copyright (c) 2009-2018, Brian G. Lucas.  See LICENSE file.

package expr
{
    const skiplist:[4]TokenT = { PEND, GEND, SEMI, NONE };

    const proplist:[]TokenT = { KMIN, KMAX, KBITSZ, KMEMSZ, KALIGN, KLEN, NONE };

    proc TypeProperty(t: Type): Ast
    {   var tree: Ast;
	var tok: TokenT;

	tree = 0;
	tok = Token;
	if tok == ID then
	{   tok = lex.Keyword(proplist);
	    if t != 0 then
	    {   if tok
		is KBITSZ then tree = ast.ConstW(t@.size);
		is KMEMSZ then tree = ast.ConstW(t@.width/target.ByteSize);
		is KALIGN then tree = ast.ConstW(t@.align/target.ByteSize);
		is KMIN then
		{   if t@.kind == ARRAY then
		    {   if !t@.flex then
			    tree = ast.Const(t@.base, t.lo);
			else lex.Error(BADLEN);
		    }
		    else
			 tree = ast.Const(t, t@.lo);
		}
		is KMAX then
		{   if t@.kind == ARRAY then
		    {   if !t@.flex then
			    tree = ast.Const(t@.base, t.hi);
			else lex.Error(BADLEN);
		    }
		    else
			tree = ast.Const(t, t@.hi);
		}
		is KLEN then
		{   if t@.kind == ARRAY && !t@.flex then
			tree = ast.ConstW(t.Span());
		    else lex.Error(BADLEN);
		}
		else lex.Error(PROPID);
	    }
	    else
		tree = ast.ConstW(0); // t == 0, return something
	}
	else lex.Error(PROPID);
	tok = Next();
	return tree;
    }

    var strid: Valu = 0;

    proc NewString(s:@[]_byte, n:_uint, nul: boolean): Ast
    {   var tree: Ast;
	var t: Type;

	t = type.New(ARRAY);
	t@.base = type.bytetype;
	t@.index = type.wordtype;
	t@.lo = 0;
	t@.hi = n-1;
	t@.align = t@.base@.align;
	t@.memorder = Target.memorder;
	tree = ast.New(SCON, t);
	tree@.symb = symb.NewString(s, n, !nul);
	strid += 1;
	tree@.valu = strid;
	return tree;
    }

    proc StringCat(tree: Ast): Ast
    {   var t: Type;
	var nl, nr: _uint;

	// modify the ARRAY type
	t = tree@.type;     // assert t@.kind == ARRAY
	nl = t@.hi+1;	    // LHS string length
	if !tree@.symb@.ispad then
	    nl -= 1;	    // don't count terminating nul
	nr = lex.StringLen; // RHS string length
	t@.hi = nl+nr-1;
	tree@.symb = symb.NewString2(tree@.symb@.ident, nl,
			lex.StringBuf, nr, !lex.StringNul);
//symb.DumpS(tree@.symb);
	return tree;
    }

    // Parse string constants, perhaps concatenated
    proc String(): Ast
    {   var tree: Ast;
	var tok: TokenT;

        tree = NewString(lex.StringBuf, lex.StringLen, lex.StringNul);
	loop
	{   tok = Next();
	  exit tok != STR;
	    tree = StringCat(tree);
	}
        return tree;
    }

    proc EnumConst(t: Type): Ast
    {   var s: Symb;
	var tree: Ast;

	// assert t@.kind == ENUM
	s = symb.FindPrivate(t@.list, lex.Ident);
	if s != 0 then
	{   tree = ast.Dup(s@.const);
	    tree@.width = s@.const@.type@.width;
	    return tree;
	}
	lex.ErrorI(UNDEFID, lex.Ident);
	return 0;
    }

    proc IsAggregateConst(node: Ast): boolean
    {   var i: ast.NSubNodes;

//err.str("IsAggregateConst op="); err.str(ast.OpName[node@.op]); err.nl();
	if node@.op
	is SCON, FCON, CONST then return true;
	is VAR then
	{   if node@.type@.kind == REFPROC then
		return node@.symb@.kind == PROC;
	    else
		return node@.symb@.kind == CONSTANT;
	}
	is BYREF, CAST then return IsAggregateConst(node@.child[0]);
	is CLIST then
	{   i = 0;
	    while i < node@.num do
	    {   if !IsAggregateConst(node@.child[i]) then return false;
		i += 1;
	    }
	    return true;
	}
	return false;
    }

    proc CompositeNamedConstant(t: Type): Ast
    {   var cs: Symb;
	var ct: Type;
	var tree: Ast;
	var tok: TokenT;

        tree = 0;
	cs = symb.Find(lex.Ident);
	if cs != 0 then
	{   if cs@.kind == CONSTANT then
	    {   ct = cs@.type;
		if type.Compat(ct, t) then
		{   tree = cs@.const;
		    tree@.type = ct;
		}
		else lex.Error(BADCOMPV);
		tok = Next();
	    }
	    else if cs@.kind == TYPE then   // cast
	    {   tok = Next();
		if tok == PBEG then
		{   tok = Next();
		    tree = Bool(0);
		    lex.Expect(PEND);
		    tree = ast.Cast(tree, cs@.type);
		}
	    }
	    else
	    {   lex.Error(EXPCONST);
		tok = Next();
	    }
	}
	else lex.ErrorI(UNDEFID, lex.Ident);
	return tree;
    }

    proc ArrayPack(t:Type, intree:Ast): Ast
    {   var offs, tsize, fsize: type.BitSize;
	var i: ast.NSubNodes;
	var tree, vpart, node: Ast;
	var cpart, mask: type.Valu;
	var bt: Type;		// base type

	vpart = 0;
	cpart = 0;
	if intree@.op != CLIST then
	{   lex.ErrorS(COMPILER, "No CLIST for packed array");
	    return tree;
	}
	tsize = t@.width;
	bt = t@.base;
	fsize = bt@.size;
	mask = ((1 << fsize)-1);
	if t@.bitorder == MSB then offs = tsize; else offs = 0;
	i = 0;
	while i < intree@.num do
	{
	    if t@.bitorder == MSB then offs -= fsize;
	    node = intree@.child[i];
	    if node@.op == CONST then
	    {   ast.CheckConstTruncate(node, fsize);
		cpart = cpart | ((node@.valu&mask) << offs);
	    }
	    else
	    {   node = ast.Extend(node, tsize, false);
		node = ast.New2(LSL, bt, node, ast.ConstW(offs));
		if vpart == 0 then
		    vpart = node;
		else
		    vpart = ast.New2(OR, bt, vpart, node);
	    }
	    if t@.bitorder != MSB then offs += fsize;
	    i += 1;
	}
	tree = ast.Extend(ast.ConstW(cpart), tsize, false);
	if vpart != 0 then
	    tree = ast.New2(OR, type.wordtype, tree, vpart);
	tree@.type = t;
	return tree;
    }

    proc ArrayFixFlex(bt: Type, len: _uint): Type
    {   var t: Type;

	t = type.Clone(bt);
	t@.flex = false;
        t@.lo = 0;	    // FIXME
	t@.hi = len-1;      // FIXME
	t@.size = 0;
	t@.width = 0;
	t@.index = type.wordtype;
	t@.final = false;
	type.Final(t);
	return t;
    }

    proc ArrayConst(t: Type): Ast
    {   var tree, stree: Ast;
	var i, j, m, n: ast.NSubNodes;	// what type should this be
	var tok: TokenT;
	var once, isnamed: boolean;

	tree = 0;
	isnamed = false;
	tok = Token;
//err.str("ArrayConst t="); type.DumpT(t, true); err.nl();
	if tok == GBEG then
	{   tree = ast.New(CLIST, t);
	    strid += 1;
	    tree@.valu = strid;
	    once = false;
	    if t@.flex then n = 0;
		       else n = ast.NSubNodes(t.Span());
	    i = 0;
	    m = 0;
	    tok = Next();
	    loop
	    {   j = i;  // for non-designated initializer
		if tok == ABEG then	// designated initializer
		{   tok = Next();
//err.str("ArrayConst index="); type.DumpT(t@.index, true); err.nl();
		    i = ast.NSubNodes(ConstValue(t@.index)) -
			ast.NSubNodes(t@.lo);
		    j = i;
		    if Token == RANGE then
		    {   tok = Next();
			j = ast.NSubNodes(ConstValue(t@.index)) -
			    ast.NSubNodes(t@.lo);
		    }
		    tok = lex.Expect(AEND);
		    tok = lex.Expect(ASGN);
		}
		stree = Const(t@.base);
		if (n == 0 || j < n) && i <= j then	// still room
		{   while i <= j do
		    {   tree = ast.ChildIndexed(tree, i, stree);
		        i += 1;
		    }
		    if i > m then m = i;
		}
		else if !once then
		{   once = true;
		    lex.Error(INITHI);
		}
		tok = Token;
	      exit tok == GEND;
	        tok = lex.Expect(COMMA);
	      exit tok == GEND;
	    }
	    tok = lex.Expect(GEND);
	    if t@.flex then	// flex array becomes a static array
		t = ArrayFixFlex(t, m);
	    // make sure all elements are initialized in gaps
	    i = 0;
	    while i < m do
	    {	if tree@.child[i] == 0 then
		    tree@.child[i] = ast.Const(t@.base, 0);
		i += 1;
	    }
	    // make sure all fields are initialized at end
	    while i < n do
	    {   tree = ast.ChildIndexed(tree, i, ast.Const(t@.base, 0));
		i += 1;
	    }
	    tree@.type = t;
	    if t@.packed then
		tree = ArrayPack(t, tree);
	    else
	    {   if !IsAggregateConst(tree) then
		    lex.Error(BADCONST);
	    }
	}
	else if tok == STR then
	    tree = String();
	else if tok == ID then
	{
	    tree = CompositeNamedConstant(t);
	    isnamed = true;
	}
	else lex.ErrorT(EXPECT, GBEG);
	// Fixup any strings, OK to eliminate terminating NUL
	if tree != 0 && tree@.op == SCON && !t@.flex then
	{   if tree@.type@.hi > t@.hi then
		lex.Error(TRUNC);	// more than term NUL trimmed
	    if isnamed then
		tree = ast.Dup(tree);
	    tree@.type = t;
	}
	return tree;
    }

    proc RecordPack(t:Type, intree:Ast): Ast
    {   var offs, tsize, fsize: type.BitSize;
	var f: Symb;
	var i: ast.NSubNodes;
	var tree, vpart, node: Ast;
	var cpart, mask: type.Valu;
	var ft: Type;		// field type

	vpart = 0;
	cpart = 0;
	if intree@.op != CLIST then
	{   lex.ErrorS(COMPILER, "No CLIST for packed record");
	    return tree;
	}
	tsize = t@.width;
	f = t@.list;
	if t@.bitorder == MSB then offs = tsize; else offs = 0;
	i = 0;
	while f != 0 do
	{   if f@.type != 0 then
	    {   ft = f@.type;
		fsize = ft@.size;
		mask = ((1 << fsize)-1);
		if t@.bitorder == MSB then offs -= fsize;
		if i >= intree@.num then
		{   lex.ErrorS(COMPILER, "Malformed LIST for packed record");
		    return 0;
		}
		node = intree@.child[i];
		if node@.op == CONST then
		{   ast.CheckConstTruncate(node, fsize);
		    cpart = cpart | ((node@.valu&mask) << offs);
		}
		else
		{   node = ast.Extend(node, tsize, false);
		    node = ast.New2(LSL, ft, node, ast.ConstW(offs));
		    if vpart == 0 then
			vpart = node;
		    else
			vpart = ast.New2(OR, ft, vpart, node);
		}
		if t@.bitorder != MSB then offs += fsize;
	    }
	    f = f@.next;
	    i += 1;
	}
	tree = ast.Extend(ast.ConstW(cpart), tsize, false);
	if vpart != 0 then
	    tree = ast.New2(OR, type.wordtype, tree, vpart);
	tree@.type = t;
	return tree;
    }

    // Convert flex record to non-flex record
    proc RecordFixFlex(bt: Type, len: _uint): Type
    {   var t: Type;
	var s, ps, bs: Symb;

//err.str("Init flex record\n");
	t = type.Clone(bt);
	// copy all fields because we need the change the final one
	ps = 0;
	bs = bt@.list;
	while bs != 0 do
	{   s = symb.New(FIELD, bs@.ident, PRIVATE);
	    if ps != 0 then ps@.next = s; else t@.list = s;
	    ps = s;
	    s@.type = bs@.type;
	    bs = bs@.next;
	}
	// final field must be the flex
	// assert ps@.type@.kind == ARRAY
	ps@.type = ArrayFixFlex(ps@.type, len);
	t@.flex = false;
	t@.base = bt;       // set base type for compatibility test
	// Recalculate size and width
	t@.size = 0;
	t@.width = 0;
	t@.final = false;
	type.Final(t);
	return t;
    }

    proc RecordConst(t: Type): Ast
    {   var tree, stree: Ast;
	var fs, ds: Symb;
	var ft: Type;
	var max: symb.OffsT;
	var tok: TokenT;
	var once: boolean;

	tree = 0;
	tok = Token;
	if tok == GBEG then
	{   tree = ast.New(CLIST, t);
	    strid += 1;
	    tree@.valu = strid;
	    once = false;
	    max = 0;
	    fs = t@.list;
	    loop
	    {
		tok = Next();
		if tok == DOT then	// designated initializer
		{   tok = Next();
		    if tok == ID then
		    {   ds = symb.FindLocal(t@.list, lex.Ident);
			if ds != 0 then
			    fs = ds;
			else
			    lex.ErrorI(UNDEFID, lex.Ident);
			tok = Next();
		    }
		    else
			lex.Error(EXPECTID);
		    tok = lex.Expect(ASGN);
		}
		else		// sequential initializer
		{   while fs != 0 && fs.ispad do    // skip padding
			fs = fs@.next;
		}
		ft = 0;
		if fs != 0 then ft = fs@.type;
		stree = Const(ft);
		if fs != 0 then
		{   tree = ast.ChildIndexed(tree, fs@.addr, stree);
		    if fs@.addr > max then max = fs@.addr;
		    fs = fs@.next;
		}
		else if !once then
		{   once = true;
		    lex.Error(INITHI);
		}
		tok = Token;
	      exit tok != COMMA;
	    }
	    tok = lex.Expect(GEND);
	    // make sure all fields are initialized in gaps
	    fs = t@.list;
	    while fs != 0 && fs@.addr <= max do
	    {	if tree@.child[fs@.addr] == 0 then
		    tree@.child[fs@.addr] = ast.Const(fs@.type, 0);
		fs = fs@.next;
	    }
	    // make sure all fields are initialized at end
	    while fs != 0 do
	    {   tree = ast.ChildIndexed(tree, fs@.addr, ast.Const(fs@.type, 0));
		fs = fs@.next;
	    }
	    if t@.flex then
	    {   ft = tree@.child[tree@.num-1]@.type;
		tree@.type = RecordFixFlex(t, ft.hi - ft.lo + 1);
	    }
	    if t@.packed then
		tree = RecordPack(t, tree);
	    else
	    {   if !IsAggregateConst(tree) then
		    lex.Error(BADCONST);
	    }
	}
	else if tok == ID then
	    tree = CompositeNamedConstant(t);
	else lex.ErrorT(EXPECT, GBEG);
	return tree;
    }

    proc CompositeValue(t: Type): Ast
    {   var tree: Ast;

	tree = 0;
	if t != 0 then
	{   if t@.kind
	    is RECORD then tree = RecordConst(t);
	    is ARRAY  then tree = ArrayConst(t);
	    is REF then tree = CompositeValue(t@.base);
	    else lex.Error(BADCOMPV);
	}
	else lex.Error(UNDFCOMPV);
	return tree;
    }

    proc CalcAlign(base: _uint, offset: _uint): _uint
    {   var new, tz: _uint;


//err.str("CalcAlign: base="); err.uint(base);
//err.str(" offset="); err.uint(offset);
	if offset == 0 then
	    new = base;
	else
	{   tz = 0;
	    while offset&1 == 0 do	// count trailing zeros
	    {   offset = offset >> 1;
		tz += 1;
	    }
	    new = 1 << tz;
	    new = _min(base, new);      // can't be greater than base
	}
//err.str(" new="); err.uint(new); err.nl();
	return new;
    }

    proc FieldAlign(base: _uint, record: Type, fieldno: _uint): _uint
    {   var offs, i: _uint;
	var s: Symb;

	if record@.kind != RECORD then return 0;	// can't happen?
//err.str("FieldAlign: base="); err.uint(base);
//err.str(" fieldno="); err.uint(fieldno);
	offs = 0;
	i = 0;
	s = record@.list;
	while i < fieldno && s != 0 do
	{   if record@.packed then
		offs += s@.type@.size;
	    else
		offs += s@.type@.width / target.ByteSize;
	    i += 1;
	    s = s@.next;
	}
//err.str(" offs="); err.uint(offs); err.nl();
	return CalcAlign(base, offs);
    }

    proc GetAlignment(tree:Ast): _uint
    {   var alignment: _uint;

	if tree == 0 then return 0;
	alignment = 0;
//err.str("GetAlignment op="); err.str(ast.OpName[tree@.op]); err.nl();
	if tree@.op
	is VAR then 		// direct variable, use its alignment
	{   if tree@.type != 0 then
		alignment = tree@.type@.base@.align/target.ByteSize;
	}
	is LOAD then 		// via a pointer
	{   if tree@.type@.kind == REF && tree@.type != 0 then
		alignment = tree@.type@.base@.align/target.ByteSize;
	}
	is BSWAP, BYREF then
	    alignment = GetAlignment(tree@.child[0]);
	is OFFSET then 		// fixed offset
	{   alignment = GetAlignment(tree@.child[0]);
//err.str("GetAlignment OFFSET initial align="); err.uint(alignment); err.nl();
	    if alignment != 0 then
		alignment = FieldAlign(alignment,
				       tree@.child[0]@.type@.base, _uint(tree@.valu));
	}
	is INDEX, SLICE then 	// possible variable offset
	{   alignment = GetAlignment(tree@.child[0]);
//err.str("GetAlignment INDEX/SLICE initial align="); err.uint(alignment); err.nl();
	    if alignment != 0 then
	    {   if tree@.child[1]@.op == CONST then
	        {
		    var size: _uint;
		    size = tree@.child[0]@.type@.base@.base@.width/target.ByteSize;
//err.str("\tsize="); err.uint(size); err.nl();
//err.str("\tindex="); err.uint(_uint(tree@.child[1]@.valu)); err.nl();
		    alignment = CalcAlign(alignment,
			_uint(tree@.child[1]@.valu)*size);
		}
		else
		{   if tree@.op == SLICE then
			alignment = tree@.type@.base@.base@.align/target.ByteSize;
		    else    // INDEX
			alignment = tree@.type@.base@.align/target.ByteSize;
		}
	    }
	}
	is CLIST, SCON then	// constant aggregate
	    alignment = tree@.type@.align;
	else
	{   lex.ErrorS(NOTIMPL, "GetAlignment: unexpected node");
	    ast.Dump(tree);
	}
//err.str("GetAlignment: final align="); err.uint(alignment); err.nl();
	return alignment;
    }

    proc GetSize(node: Ast): Ast
    {   var size, nsize: Ast;
	var tsize: type.BitSize;

//err.str("GetSize\n"); ast.Dump(node);
	size = 0;
	if node@.op
	is VAR then
	{   size = ast.ConstW(node@.type@.base@.width/target.ByteSize);
	}
	is LOAD then 		// via a pointer
	{   if node@.type@.kind == REF then
		size = ast.ConstW(node@.type@.base@.width/target.ByteSize);
	    else
		lex.ErrorS(COMPILER, "Load via non-REF");
	}
	is INDEX, OFFSET then
	{   size = ast.ConstW(node@.type@.base@.width/target.ByteSize);
	}
	is SLICE then
	{   size = ast.ConstW(node@.type@.base@.base@.width/target.ByteSize);
	    // LLVM wants multiply to be word sized
	    size = ast.OpMul(MUL, ast.ExtendT(node@.child[2], type.wordtype),
			size, type.wordtype);
	}
	else
	{   lex.ErrorS(NOTIMPL, "GetSize: unexpected node");
	    ast.Dump(node);
	}
	if size == 0 then
	    size = ast.ConstW(0);
//err.str("returns\n"); ast.Dump(size);
	return size;
    }

    proc GetOffset(node: Ast): Ast
    {   var tree, ctree: Ast;

	tree = 0;
	if node@.op
	is OFFSET then
	{   var f: Symb;    // field symbol
	    var n, offset: _uint;   // field index
	    ctree = GetOffset(node@.child[0]);
	    // assert node@.child[0]@.type@.base@.kind == RECORD
	    offset = 0;
	    n = 0;
	    f = node@.child[0]@.type@.base@.list;
	    while f != 0 && n < node@.valu do
	    {   offset += f@.type@.width / target.ByteSize;
		f = f@.next;
		n += 1;
	    }
	    tree = ast.ConstW(offset);
	}
	is INDEX then
	{
	    ctree = GetOffset(node@.child[0]);
	    // assert node@.child[0]@.type@.base@.kind == ARRAY
	    tree = ast.ConstW(node@.child[0]@.type@.base@.base@.width / target.ByteSize);
	    tree = ast.OpMul(MUL, ast.ExtendT(node@.child[1], type.wordtype),
			tree, type.wordtype);
	}
	if tree != 0 && ctree != 0 then
	    tree = ast.OpAdd(ADD, tree, ctree, type.wordtype);
//err.str("GetOffset: final="); err.uint(offset); err.nl();
	return tree;
    }

    proc Slice(array: Ast, inx: Ast, len: Ast): Ast
    {   var at, st: Type;
	var tree: Ast;
	var blen, slen: type.BitSize;

//err.str("Slice: array=");  ast.Dump(array);
//err.str("inx="); ast.Dump(inx);
//err.str("len="); ast.Dump(len);
	at = array@.type@.base;
	st = type.New(ARRAY);       // FIXME: use Clone()?
	st@.base = at@.base;
	st@.packed = at@.packed;
	st@.memorder = at@.memorder;
	blen = 0;
	slen = 0;
	if at@.flex then
	    st@.index = type.wordtype;      // must use something
	else
	{   st@.index = at@.index;
	    blen = type.BitSize(at.Span());
	}
	if len != 0 then
	{   if len@.op == CONST then slen = type.BitSize(len@.valu);
	}
	else
	    len = ast.ConstW(0);	// stop error propagation
	if blen == 0 && slen == 0 then
	    st@.flex = true;
	else
	{   if slen == 0 then
	    {	slen = blen;	// worst case
		if inx@.op == CONST then
		    slen = blen - type.BitSize(inx@.valu);
	    }
	    else
	    {   // check slen < blen unless olen == 0
	    }
	    st@.hi = slen - 1;
	}
	st@.size = at@.base@.size * slen;
	st@.width = st@.size;
	if inx != 0 then
	{   if inx@.op == CONST then
	    {   var offs: _uint;
		offs = _uint(inx@.valu) * (at@.base@.width/target.ByteSize);
		st@.align = CalcAlign(at@.align/target.ByteSize, offs) *
		    target.ByteSize;
	    }
	    else    // Just take the alignment of the base type.
		st@.align = at@.base@.align;
	}
	else
	    inx = ast.ConstW(0);  	// stop error propagation
	tree = ast.New3(SLICE, type.MakeRef(st), array, inx, len);
	return tree;
    }

    proc Load(tree: Ast): Ast
    {   var t: Type;

	if tree == 0 then return tree;
//err.str("Load: "); ast.Print(tree);
	t = tree@.type;
	if t@.kind == REF then
	{   t = t@.base;
	    if t != 0 then
	    {   tree = ast.New1(LOAD, t, tree);
		tree@.width = t@.width;
		if type.NeedSwap(tree@.type, Target.memorder) then
		{   tree = ast.New1(BSWAP, tree@.type, tree);
		    tree@.type = type.ChangeOrder(tree@.type, Target.memorder);
		}
	    }
	    else lex.Error(BADREF);
	}
	else if tree@.op != FIELD then
	{   lex.ErrorS(COMPILER, "Load via non-REF");
ast.Dump(tree);
	}
	return tree;
    }

    proc IsSignedBinOp(lhs: Ast, rhs: Ast): boolean
    {
	if lhs@.type@.kind == SINT || rhs@.type@.kind == SINT then
	    return true;
	return false;
    }

    proc IsFloatBinOp(lhs: Ast, rhs: Ast): boolean
    {
	if lhs@.type@.kind == FLOAT || rhs@.type@.kind == FLOAT then
	    return true;
	return false;
    }

    proc FindFlexSize(t: Type): type.BitSize
    {   var size: type.BitSize;
	var bt: Type;

	size = 1;   // some default
	if t != 0 then
	{   if t@.flex then
	    {   if t@.kind
		is ARRAY then
		    bt = t@.base;
		is RECORD then
		{   var f: Symb;
		    bt = 0;
		    f = t@.list;
		    while f != 0 do
		    {   bt = f@.type;
			f = f@.next;
		    }
		}
		if bt != 0 then size = FindFlexSize(bt);
	    }
	    else
		size = t@.width/target.ByteSize;
	}
	return size;
    }

    proc GetSizeSpec(t: Type): Ast
    {   var size, temp: Ast;
	var tok: TokenT;

        tok = Token;
	size = ast.ConstW(t@.width/target.ByteSize);
	if tok == PBEG then
	{   tok = Next();
	    if !t@.flex then
		lex.Error(NOSIZE);
	    temp = Const(type.wordtype);
	    temp = ast.OpMul(MUL, temp,
		ast.ConstW(FindFlexSize(t)), type.wordtype);
	    size = ast.OpAdd(ADD, size, temp, type.wordtype);
	    tok = lex.Expect(PEND);
	}
	else if t@.flex then
	    lex.Error(NEEDSIZE);
	return size;
    }

    proc GetSpaceSpec(t: Type): Ast
    {   var space: Ast;
	var tok: TokenT;

        tok = Token;
	if tok == COMMA then
	{   tok = Next();
	    space = Const(type.wordtype);
	}
	else
	    space = ast.ConstW(0);
	return space;
    }

    proc SizeSpace(t: Type): Ast, Ast
    {   var size, space, temp: Ast;
	var tok: TokenT;

        tok = Token;
	size = ast.ConstW(t@.width/target.ByteSize);
	if tok == PBEG then
	{   tok = Next();
	    if !t@.flex then
		lex.Error(NOSIZE);
	    temp = Const(type.wordtype);
	    temp = ast.OpMul(MUL, temp, ast.ConstW(FindFlexSize(t)),
		type.wordtype);
	    temp = ast.New2(MUL, type.wordtype, temp,
		ast.ConstW(FindFlexSize(t)));
	    size = ast.OpAdd(ADD, size, temp, type.wordtype);
	    tok = lex.Expect(PEND);
	}
	else if t@.flex then
	    lex.Error(NEEDSIZE);
	if tok == COMMA then
	{   tok = Next();
	    space = Const(type.wordtype);
	}
	else
	    space = ast.ConstW(0);
	return size, space;
    }

    proc UnLoad(tree:Ast): Ast
    {
	if tree@.op == LOAD then
	    tree = tree@.child[0];
	// FIXME - BSWAP-LOAD
	else
	{   lex.ErrorS(COMPILER, "UnLoad error");
	    ast.Dump(tree);
	}
	return tree;
    }

    proc New(): Ast
    {   var tree, size: Ast;
	var s: Symb;
	var tok: TokenT;
	var t: Type;

	tree = 0;
	tok = Token;
	if tok == ID then
	{   t = 0;
	    s = symb.FindKind(lex.Ident, TYPE);
	    if s != 0 then
		t = s@.type;
	    tok = Next();
	    if t != 0 then
	    {   size = GetSizeSpec(t);
		tree = ast.New3(CALL, 0, size,
			    ast.ConstW(t@.align/target.ByteSize),
			    GetSpaceSpec(t));
		tree@.symb = symb.libnew;
		tree@.type = type.addrtype;
		tree@.width = Target.ptr.size;
		tree = ast.New1(CAST, type.MakeRef(s@.type), tree);
	    }
	}
	else lex.Error(EXPECTID);
	return tree;
    }

    proc Delete(): Ast
    {   var tree, varb, size: Ast;
	var tok: TokenT;
	var t: Type;

	tree = 0;
	varb = GetLHS(0);
	tok = Token;
	if varb != 0 then
	{   varb = Load(varb);
	    t = varb@.type@.base;
	    if t != 0 then
	    {   size = GetSizeSpec(t);
		tree = ast.New3(CALL, 0,
			    ast.New1(CAST, type.addrtype, varb),
			    size, GetSpaceSpec(t));
		tree@.symb = symb.libdel;
	    }
	}
	else lex.Error(EXPECTID);
	return tree;
    }

    proc Set(withzero: boolean): Ast
    {   var tree, temp, size, from: Ast;
	var t: Type;
	var align: _uint;
	var tok: TokenT;

	tree = GetLHS(0);
	tok = Token;
	if tree != 0 then
	{
	    if tree@.op
	    is VAR then
	    {   if tree@.type@.kind == REF then
		{   t = tree@.type@.base;
		    if t@.kind == REF then
		    {   // dereference the pointer
			tree = ast.New1(LOAD, t, tree);
			t = t@.base;
		    }
		}
		else
		{   lex.ErrorS(COMPILER, "expr.Zero: VAR not REF");
		    return 0;
		}
		size = ast.ConstW(t@.width/target.ByteSize);
		align = t@.align/target.ByteSize;
		if tok == PBEG then
		{   tok = Next();
		    if !t@.flex then
			lex.Error(NOSIZE);
		    temp = Const(type.wordtype);
		    temp = ast.OpMul(MUL, temp,
			ast.ConstW(FindFlexSize(t)), type.wordtype);
		    size = ast.OpAdd(ADD, size, temp, type.wordtype);
		    tok = lex.Expect(PEND);
		}
	    }
	    else
	    {   size = GetSize(tree);
		align = GetAlignment(tree);
	    }
	    if withzero then
		from = ast.Const(type.bytetype, 0);
	    else
	    {	if Token == COMMA then
		{   tok = Next();
		    from = Bool(0);
		    // FIXME - check that type can be cast as i8
		}
		else
		    lex.ErrorT(EXPECT, COMMA);
	    }
	    tree = ast.New4(SET, type.unkntype, tree,
			    from, size, ast.Const(type.bytetype, align));
	}
	return tree;
    }

    proc IntrinsicUnary(op: ast.Op): Ast
    {   var tree: Ast;

	tree = Bool(0);
	tree = ast.OpUnary(op, tree);
	return tree;
    }

    proc Rotate(right: boolean): Ast
    {   var tok: TokenT;
        var tree, shft: Ast;
        var op: ast.Op;

	tree = Bool(0);
	if tree@.type@.kind != UINT then
	    lex.ErrorS(OPTYPE, "_rol or _ror");
	if Token == COMMA then
	{   tok = Next();
	    shft = Bool(0);
	}
	else
	    lex.ErrorT(EXPECT, COMMA);
	if shft.op == CONST then
	{   if shft.valu >= tree@.width then
	    {   lex.Error(RANGEERR);
		return tree;
	    }
	    elif shft.valu == 0 then
		return tree;
	}
	if right then op = ROR; else op = ROL;
	tree = ast.New2(op, tree@.type, tree, shft);
	return tree;
    }

    proc Splice(et: Type): Ast
    {   var tree, lhs, rhs: Ast;
	var dbltype: Type;
	var dblsize, orgsize: type.BitSize;

	tree = 0;
	lhs = Bool(0);
	lex.Expect(COMMA);
	rhs = Bool(0);
	if lhs != 0 && rhs != 0 then
	{   if lhs@.type@.kind == UINT && rhs@.type@.kind == UINT then
	    {	if et != 0 then
		{   dbltype = et;
		    dblsize = et@.size;
		    orgsize = dblsize / 2;
		    // FIXME - check for orgsize too small
		}
		else
		{   if lhs@.op != CONST then
		    {	orgsize = lhs@.type@.size;
			dblsize = orgsize * 2;
		    }
		    elif rhs@.op != CONST then
		    {	orgsize = rhs@.type@.size;
			dblsize = orgsize * 2;
		    }
		    else
		    {	// if both CONSTs, just make CONST size
			dblsize = lhs@.type@.size;
			orgsize = dblsize / 2;
		    }
		    dbltype = target.utype(dblsize);
		    if dbltype == 0 then
		    {	lex.ErrorS(OPTYPE, "_splice");
			return tree;
		    }
		}
		if dbltype@.width > lhs@.width then
		    lhs = ast.New1(ZEXT, dbltype, lhs);
		lhs@.width = dblsize;
		lhs = ast.OpShfL(LSL, lhs, ast.ConstW(orgsize), dbltype);
		if dbltype@.width > rhs@.width then
		    rhs = ast.New1(ZEXT, dbltype, rhs);
		rhs@.width = dblsize;
		tree = ast.OpLogic(OR, lhs, rhs);
	    }
	    else
		lex.ErrorS(OPTYPE, "_splice");
	}
	return tree;
    }

    proc GetArrayArg(): Ast,    // 0 if error
			Type,   // type of scalar just wide enough
			Type    // type of normal scalar wide enough
    {   var arg: Ast;
	var nb, na: _uint;
        var ta, tn: Type;
	var t: Type;

        arg = Bool(0);     // FIXME - something less general?
        if arg == 0 then return 0, 0, 0;
        arg = UnLoad(arg);
        t = arg@.type;
        if !type.Compat(t, type.addrtype) then
        {   lex.Error(PACKARRAY);
	    return 0, 0, 0;
	}
	t = t@.base;
	nb = 0;      // this indicates illegal
	if arg@.op == SLICE then
	{   if arg@.child[2]@.op == CONST then
		nb = arg@.child[2]@.valu;
	}
	else    // assert array
	{   if !t@.flex then
	    nb = t.Span();
	}
	if nb == 0 then
	{   lex.Error(PACKFIXED);
	    return 0, 0, 0;
	}
	na = GetAlignment(arg);
	tn = target.utype(nb*target.ByteSize);
	if tn == 0 then
	{   lex.Error(PACKSIZE);
	    return 0, 0, 0;
	}
	ta = tn;	// assume normal size
	if tn@.size  > nb*target.ByteSize ||     // unusual size
	   tn@.align > na*target.ByteSize then   // or unaligned
	{   ta = type.Clone(ta);
	    ta@.size  = nb*target.ByteSize;
	    ta@.width = nb*target.ByteSize;
	    ta@.align = na*target.ByteSize;
	    ta@.unalgn = true;
	    ta@.reftype = 0;	// FIXME - move to Clone?
	    ta@.final = true;
	}
//err.str("nb="); err.uint(nb);
//err.str(" na="); err.uint(na);
//err.str(" ta=\n"); type.DumpT(ta, true); err.nl();
//err.str("tn=\n"); type.DumpT(tn, true); err.nl();
        return arg, ta, tn;
    }

    proc Pack(endian: type.MemOrderT): Ast
    {   var tree: Ast;
        var rhs: Ast;		// scalar AST
	var arg: Ast;		// array slice AST
        var ta: Type;		// array slice type, next integral size
        var tn: Type;		// normal size covering array
        var shf: _uint;		// shift amount, if any
        var tok: TokenT;

	arg, ta, tn = GetArrayArg();
	if Token != COMMA then
	{   lex.ErrorT(EXPECT, COMMA);
	    return 0;
	}
	tok = Next();
	rhs = Bool(0);      // FIXME - we know the size/type of the uint?
	if arg == 0 || rhs == 0 then
	    return 0;
	if rhs@.type@.kind != UINT then
	{   lex.Error(PACKUINT);
	    return 0;
	}
	shf = tn@.size - ta@.size;
	if endian != Target.memorder then
	{   rhs = ast.ExtendT(rhs, tn);     // extend to natural size
	    rhs = ast.New1(BSWAP, rhs@.type, rhs);
	    if shf != 0 then
		rhs = ast.New2(LSR, rhs@.type, rhs, ast.ConstW(shf));
	}
	rhs = ast.ExtendT(rhs, ta);     // extend (trunc) to expected size
	rhs@.width = ta@.width;
	arg = ast.Cast(arg, type.MakeRef(ta));
	arg@.width = ta@.width;
	tree = ast.New2(STORE, ta, arg, rhs);
	tree@.width = ta@.width;
	tree = ast.New1(NOP, 0, tree);  // force no assignment
	return tree;
    }

    proc Unpk(endian: type.MemOrderT): Ast
    {   var tree: Ast;
	var arg: Ast;		// array slice AST
        var ta: Type;		// array slice type, next integral size
        var tn: Type;		// normal size covering array
        var shf: _uint;		// shift amount, if any

	arg, ta, tn = GetArrayArg();
	if arg == 0 then
	    return 0;
	shf = tn@.size - ta@.size;
	tree = ast.Cast(arg, type.MakeRef(ta));
	tree = Load(tree);
	if endian != Target.memorder then
	{   tree = ast.ExtendT(tree, tn);   // extend to natural size
	    tree = ast.New1(BSWAP, tree@.type, tree);
	    if shf != 0 then
		tree = ast.New2(LSR, tree@.type, tree, ast.ConstW(shf));
	}
	return tree;
    }

    proc Convert(t: Type): Ast
    {   var tree: Ast;
        var to, fm: TypeT;
        var op: ast.Op;
	var ok: boolean;

	tree = Bool(0);
	if tree != 0 && t != 0 then
	{   to = t@.kind;
	    fm = tree@.type@.kind;
	    ok = false;
	    op = NULL;
	    if to
	    is  FLOAT then
	    {   if fm
		is UINT then
		{   if tree.op == CONST then
		    {	tree.op = FCON;
			tree.valu = type.Valu(_float64*(tree.valu));
		    }
		    else op = CVTUF;
		    ok = true;
		}
		is SINT then
		{   if tree.op == CONST then
		    {	tree.op = FCON;
			tree.valu = type.Valu(_float64*(type.Valu(tree.valu)));
		    }
		    else op = CVTIF;
		    ok = true;
		}
		is FLOAT then
		{   tree = ast.ExtendT(tree, t);
		    ok = true;
		}
	    }
	    is UINT then
	    {   if fm == FLOAT then
		{   if tree.op == FCON then
		    {   tree.op = CONST;
			tree.valu = type.Valu*(_float64(tree.valu));
			// FIXME: what if const is negative?
		    }
		    else op = CVTFU;
		    ok = true;
		}
	    }
	    is SINT then
	    {   if fm == FLOAT then
		{   if tree.op == FCON then
		    {   tree.op = CONST;
			tree.valu = type.Valu*(_float64(tree.valu));
		    }
		    else op = CVTFI;
		    ok = true;
		}
	    }
	    if ok then
	    {	if op != NULL then
		    tree = ast.New1(op, t, tree);
		tree@.type = t;
		tree@.width = t@.width;
	    }
	    else
	    {	lex.Error(BADCONV);
	    }
	}
        return tree;
    }

    proc Intrinsic(ps: Symb, et: Type): Ast
    {   var tree, lhs, rhs: Ast;
	var tok: TokenT;
	var which: symb.IntrinsicT;
	var op: ast.Op;

	tree = 0;
	tok = Token;
	if tok == PBEG then
	{   tok = Next();
	    which = symb.IntrinsicT(ps@.addr);
	    if which
	    is DEF then
	    {   if tok == ID then
		    tree = ast.Const(type.booltype,
				     _uint(symb.IsDefined(lex.Ident)));
		else lex.Error(EXPECTID);
	    }
	    is ABS then
	    {   tree = IntrinsicUnary(ABS);
		if tree != 0 && tree@.type@.kind == SINT then
		    tree@.type = target.utype(tree@.width);
	    }
	    is SQRT then
	    {	tree = IntrinsicUnary(SQRT);
		if tree@.type@.kind == SINT then
		    lex.ErrorS(OPTYPE, "_sqrt");
	    }
	    is MIN, MAX then
	    {   lhs = Bool(0);
		lex.Expect(COMMA);
		rhs = Bool(0);
		if lhs != 0 && rhs != 0 then
		{   if IsFloatBinOp(lhs, rhs) then
		    {
			if which == MIN then op = FMIN; else op = FMAX;
			tree = ast.OpFloat(op, lhs, rhs, et);
		    }
		    else
		    {	if IsSignedBinOp(lhs, rhs) then
			    if which == MIN then op = SMIN; else op = SMAX;
			else
			    if which == MIN then op = UMIN; else op = UMAX;
			tree = ast.OpMinMax(op, lhs, rhs);
		    }
		}
	    }
	    is LO, HI then
	    {	var haft: Type;
		var hafsize: type.BitSize;
		tree = Bool(0);
		if tree@.type@.kind == UINT && tree@.type@.size >= 16 then
		{   hafsize = tree@.type@.size/2;
		    if which == HI then
		    {	tree = ast.OpShfR(LSR, tree, ast.ConstW(hafsize),
				    tree@.type);
		    }
		    haft = target.utype(hafsize);
		    tree = ast.New1(TRUNC, haft, tree);
		    tree@.width = hafsize;
		}
		else
		    lex.ErrorS(OPTYPE, "_lo or _hi");
	    }
	    is SPLICE then tree = Splice(et);
	    is ZLEN then
	    {   var align: _uint;
	        lhs = GetLHS(0);
		if lhs != 0 then
		{   if lhs@.op == LOAD && lhs@.type@.kind == ARRAY then	// undo LOAD
			lhs = lhs@.child[0];
		    if lhs@.type@.kind != REF || lhs@.type@.base@.kind != ARRAY ||
		       lhs@.type@.base@.base@.kind != UINT ||
		       lhs@.type@.base@.base@.width != target.ByteSize then
			lex.ErrorS(OPTYPE, "_zlen");
		    align = GetAlignment(lhs);
		    tree = ast.New2(ZLEN, type.wordtype, lhs, ast.ConstW(align));
		    tree@.width = type.wordtype@.width;
		}
	    }
	    is CLZ    then tree = IntrinsicUnary(CLZ);
	    is CLZNZ  then tree = IntrinsicUnary(CLZNZ);
	    is CTZ    then tree = IntrinsicUnary(CTZ);
	    is CTZNZ  then tree = IntrinsicUnary(CTZNZ);
	    is POP    then tree = IntrinsicUnary(POP);
	    is ROL    then tree = Rotate(false);
	    is ROR    then tree = Rotate(true);
	    is BSWAP  then tree = IntrinsicUnary(BSWAP);
	    is BITREV then tree = IntrinsicUnary(BITREV);
	    is PACKLE then tree = Pack(LE);
	    is PACKBE then tree = Pack(BE);
	    is UNPKLE then tree = Unpk(LE);
	    is UNPKBE then tree = Unpk(BE);
	    is ZERO   then tree = Set(true);
	    is SET    then tree = Set(false);
	    is NEW    then tree = New();
	    is DEL    then tree = Delete();
	    else
		lex.ErrorS(COMPILER, "Intrinsic unknown");
	    tok = lex.Expect(PEND);
	}
	else lex.ErrorT(EXPECT, PBEG);
	return tree;
    }

    proc Call(ps:Symb, tree: Ast, arg: Ast): Ast
    {   var t: Type;
	var s: Symb;
	var tok: TokenT;

	t = ps@.type;
	if tree == 0 then	// direct call
	    tree = ast.New(CALL, t);
	else			// indirect call
	    tree = ast.New1(CALLI, t, tree);
	tree@.symb = ps;
	if t != 0 then		// has returned value
	    tree@.width = t@.width;
	else
	    tree@.type = type.unkntype;
	s = ps@.parmlist;
	if arg != 0 then	// method call
	{   // assert s != 0
	    arg = ast.Adjust(arg, s@.type);
	    tree = ast.Child(tree, arg);
	    s = s@.next;
	}
	tok = Token;
	if tok == PBEG then
	{   tok = Next();
	    if tok != PEND then
	    {   loop
		{
		  exit s == 0 with
		    {   lex.Error(ARGSHI);
			tok = lex.Skip(skiplist);
		    }
		    arg = Bool(s@.type);
		    if arg != 0 then
			arg = ast.Adjust(arg, s@.type);
		    tree = ast.Child(tree, arg);
		    s = s@.next;
		    tok = Token;
		  exit tok != COMMA;
		    tok = Next();
		}
	    }
	    tok = lex.Expect(PEND);
	}
	else
	    lex.ErrorT(EXPECT, PBEG);
	if s != 0 && s@.linkage == FORMAL then
	    lex.Error(ARGSLO);
	return tree;
    }

    proc RefProc(s: Symb): Ast
    {   var t: Type;
	var tree: Ast;

	// must create a REFPROC type to point at proc symbol
	t = type.New(REFPROC);
	t@.list = s;
	tree = ast.New(VAR, t);
	tree@.symb = s;
	return tree;
    }

    proc BitfieldOffset(t: Type, fno: type.Valu): type.BitSize
    {   var foffs, rsize, fsize: type.BitSize;
	var s: Symb;
	var i: ast.NSubNodes;

        //if t@.kind == REF then t = t@.base;
	// assert t@.kind == RECORD
	rsize = t@.width;
	if t@.bitorder == MSB then foffs = rsize; else foffs = 0;
	s = t@.list;
	i = 0;
	while s != 0 do
	{   fsize = s@.type@.size;
	    if t@.bitorder == MSB then foffs -= fsize;
	  exit i == fno;
	    if t@.bitorder != MSB then foffs += fsize;
	    s = s@.next;
	    i += 1;
	}
	return foffs;
    }

    proc CheckBoundsError(t: Type, val: Valu): boolean
    {   alias type.SValu as SValu;

	if t@.index@.kind == SINT then	// signed range
	    return SValu(val) > SValu(t@.hi) || SValu(val) < SValu(t.lo);
	else				// unsigned range
	    return val > t@.hi || val < t@.lo;
    }

    proc Suffix(tree: Ast, et: Type): Ast
    {   var t, bt: Type;
	var tok: TokenT;
	var done: boolean;
	var s: Symb;

	tok = Token;
	done = false;
	while !done && tree != 0 && tree@.type != 0 do
	{   t = tree@.type;
//lex.WhereAmI("Suffix TOP");  ast.Dump(tree);
	    if tok
	    is AT then
	    {   tok = Next();
		if t@.kind == REF then
		{
		    tree = Load(tree);
		    // FIXME - endian?
		}
		else if t@.kind == REFPROC then
		{   tree = Call(t@.list, tree, 0);
		    tok = Token;
		}
		else lex.Error(NOTREF);
	    }
	    is DOT then
	    {   tok = Next();
		{   if tok == ID then
		    {   bt = t;
			if t@.kind == REF then bt = t@.base;
			s = 0;
			loop
			{ exit bt == 0;
			    s = symb.FindPrivate(bt@.meths, lex.Ident);
			  exit s != 0;
			    bt = bt@.base;
			}
			if s != 0 then		// method call
			{   tok = Next();
//err.str("Method use: ");  err.str(s@.ident); err.nl(); ast.Dump(tree);
			    if tok == PBEG then
			    {   tree = Call(s, 0, tree);
				tok = Token;
			    }
			    else
				tree = RefProc(s);
			}
			else
			{
			    if t@.kind == REF then
			    {   if t@.base != 0 then
				{   // FIXME - optimize Load followed by UnLoad?
				    tree = Load(tree);
				    t = t@.base;
				}
				else
				{   lex.Error(BADREF);
				    tree = 0;	// give up
				}
			    }
			    if t@.kind == RECORD then
			    {   s = symb.FindLocal(t@.list, lex.Ident);
				if s != 0 then
				{
				    if t@.packed then
				    {
					tree = ast.New2(FIELD, s@.type, tree,
					    ast.ConstW(BitfieldOffset(t, s@.addr)));
					tree@.valu = s@.type@.size;
					tree@.width = s@.type@.width;
				    }
				    else
				    {   tree = UnLoad(tree);
					tree = ast.New1(OFFSET,
						type.MakeRef(s@.type), tree);
					tree@.valu = s@.addr;
					tree@.width = Target.ptr.size;
					tree = Load(tree);
				    }
				}
				else
				    lex.ErrorS(UNDEFFIELD, lex.Ident);
				tok = Next();
			    }
			    else
{
				lex.Error(NOTRECORD);
type.DumpT(t, false); err.nl();
}
			}
		    }
		    else lex.Error(EXPECTID);
		}
	    }
	    is ABEG then
	    {   tok = Next();
		if t@.kind == REF then
		{   if t@.base != 0 then
		    {   // FIXME - optimize Load followed by UnLoad?
			tree = Load(tree);
			t = t@.base;
		    }
		    else
		    {   lex.Error(BADREF);
			tree = 0;	// give up
		    }
		}
		if t@.kind == ARRAY then
		{   var index: Ast;
		    index = Bool(t@.index);
		    if index == 0 then
		    {   lex.Error(BADINXEXP);
			index = ast.Null;
		    }
		    // check for index out of bounds
		    if index@.op == CONST && !t@.flex then
		    {   if CheckBoundsError(t, index@.valu) then
			{   lex.Error(BOUNDSERR);
			    index@.valu = t@.lo;    // avoid additional errors
			}
		    }
		    // make index zero based
		    if t@.lo != 0 then
		    {   if index@.op == CONST then
			    index@.valu -= t@.lo;
			else
			    index = ast.OpAdd(SUB, index,
					ast.ConstW(t@.lo), type.wordtype);
		    }
		    tok = Token;
		    if tok == COLON then	// array slice
		    {   var len: Ast;
			tok = Next();
			tree = UnLoad(tree);
			len = Bool(t@.index);	// index type?
			// check for slice out of bounds
			// index is now zero based, so use hi-lo in check
			if len != 0 && len@.op == CONST &&
				index@.op == CONST  && !t@.flex &&
				len@.valu - 1 > (t@.hi - t@.lo) then
			    lex.Error(BOUNDSERR);
			tree = Slice(tree, index, len);
			tree = Load(tree);
			done = true;
		    }
		    else			// normal indexed
		    {
			if t@.packed then
			{
			    index = ast.ExtendT(index, type.wordtype);
			    index = ast.OpMul(MUL, index,
				    ast.ConstW(t@.base@.size), type.wordtype);
			    tree = ast.New2(FIELD, t@.base, tree, index);
			    tree@.valu = t@.base@.size;
			    tree@.width = t@.base@.width;
			}
			else
			{
			    tree = UnLoad(tree);
			    tree = ast.New2(INDEX, type.MakeRef(t@.base),
					    tree, index);
			    tree@.width = Target.ptr.size;
			    tree = Load(tree);
			}
		    }
		}
		else
		    lex.Error(NOTARRAY);
		tok = lex.Expect(AEND);
	    }
	    is PBEG then
	    {	if t@.kind == REFPROC then
		{   // Implicit deref of REFPROC
		    tree = Call(t@.list, tree, 0);
		    tok = Token;
		}
		else done = true;
	    }
	    else done = true;
	}
	return tree;
    }

    proc Primary(s:Symb, et:Type): Ast
    {   var tree: Ast;
	var t: Type;

	tree = 0;
	t = s@.type;
	if s@.kind
	is VAR then
	{   tree = ast.New(VAR, type.MakeRef(t));
	    tree@.symb = s;
	    tree@.width = t@.width;
	    tree = Load(tree);
	}
	is CONSTANT then
	{   if t@.kind <= REF || t@.packed then
		tree = ast.Dup(s@.const);
	    else	// treat like a var
	    {   tree = ast.New(VAR, type.MakeRef(t));
		tree@.symb = s;
		tree@.width = t@.width;
		tree = Load(tree);
	    }
	}
	is PROC then
	{   if s@.addr != 0 then
		tree = Intrinsic(s, et);
	    else
	    {   if Token == PBEG then
		    tree = Call(s, 0, 0);
		else
		    tree = RefProc(s);
	    }
	}
	else
	{   lex.ErrorI(BADID, s@.ident);	// FIXME - need better message
	    return 0;
	}
	tree = Suffix(tree, et);
	return tree;
    }

    proc GetLHS(s: Symb): Ast
    {   var tok: TokenT;
	var tree: Ast;

	if s == 0 then
	{   tok = Token;
	    if tok == ID then
	    {   s = symb.Find(lex.Ident);
		tok = Next();
		if s == 0 then
		{   lex.ErrorI(UNDEFID, lex.Ident);
		    return 0;
		}
	    }
	    else
	    {   lex.Error(EXPECTID);
		return 0;
	    }
	}
	tree = Primary(s, 0);
	if tree != 0 then
	{   // undo the load  FIXME - same as UnLoad()?
	    if tree@.op == LOAD then
		tree = tree@.child[0];
	    else if tree@.op == BSWAP && tree@.child[0]@.op == LOAD then
		tree = tree@.child[0]@.child[0];
	}
	return tree;
    }

    proc Container(tree: Ast, t: Type): Ast
    {   var otree: Ast;

	otree = ast.New(VAR, type.MakeRef(t));
	otree@.symb = 0;
	otree@.width = t@.width;
	otree = Load(otree);
	otree = Suffix(otree, t);
	otree = UnLoad(otree);
	if otree != 0 then
	    otree = GetOffset(otree);
	if otree != 0 then
	{   tree = ast.Cast(tree, type.wordtype);
	    tree = ast.OpAdd(SUB, tree, otree, type.wordtype);
	    tree = ast.Cast(tree, t);
	}
	return tree;
    }

    proc Term(et:Type): Ast
    {   var tree: Ast;
	var tok: TokenT;
	var t: Type;
	var s: Symb;

	tree = 0;
	tok = Token;
	s = savedsym;
	savedsym = 0;
	if s == 0 && tok == ID then
	{   if et != 0 && et@.kind == ENUM then	// enum context
	    {	s = symb.FindPrivate(et@.list, lex.Ident);
		if s != 0 then
		{   tree = ast.Dup(s@.const);
		    tree@.width = s@.const@.type@.width;
		    tok = Next();
		    return tree;
		}
	    }
	    s = symb.Find(lex.Ident);
	    if s == 0 then
	    {	lex.ErrorI(UNDEFID, lex.Ident);
		tok = Next();
		return tree;
	    }
	    tok = Next();
	}
	if s != 0 then      // we have a symbol
	{
	    if s@.kind == TYPE then
	    {   t = s@.type;
		if tok
		is DOT then		// possible enum const
		{   tok = Next();
		    if t@.kind == ENUM then
		    {   tree = EnumConst(t);
			tok = Next();
		    }
		    else
			lex.ErrorI(BADTYPE, s@.ident);
		}
		is QUEST then		// property
		{   tok = Next();
		    tree = TypeProperty(t);
		}
		is PBEG then		// cast
		{   tok = Next();
		    tree = Bool(0);	// FIXME: is this right?
		    tok = Token;
		    if tok == COMMA then
		    {   tok = Next();
			tree = Container(tree, t);
		    }
		    else    // simple cast
			tree = ast.Cast(tree, t);
		    tok = lex.Expect(PEND);
		}
		is STAR then		// convert
		{   tok = Next();
		    tok = lex.Expect(PBEG);
		    tree = Convert(t);
		    tok = lex.Expect(PEND);
		}
		is GBEG then		// composite
		    tree = CompositeValue(t);
		else
		    lex.ErrorI(BADTYPE, s@.ident);
	    }
	    else
	    {
		tree = Primary(s, et);
		tok = Token;
		if tok == QUEST then
		{   tok = Next();
		    tree = TypeProperty(tree@.type);
		}
	    }
	}
	else	    // we don't have a symbol
	{
	    if tok
	    is NUM then
	    {   tree = ast.New(CONST, et);
		tree@.valu = lex.Number;
		tree@.width = type.bitsize(lex.Number);
		if et == 0 then
		    tree@.type = type.wordtype;	// FIXME: ?
		else
		{   if et@.kind
		    is UINT, SINT then
		    {   if et@.size > tree@.width then   // widen
			    tree@.width = et@.size;
		    }
		    is REF, REFPROC then    // want pointer constant
			tree@.width = Target.ptr.size;
		    else
			tree@.type = type.wordtype; // wrong type for numeric const
		}
		tok = Next();
	    }
	    is FNUM, ENUM then
	    {   tree = ast.New(FCON, type.floattype);
		tree@.width = 64;			// FIXME: ?;
		tree@.valu = _uint64(lex.MakeFloat(tok==ENUM));
		tok = Next();
	    }
	    is STR then
		tree = String();
	    is PBEG then
	    {   tok = Next();
		tree = Bool(et);
		tok = Token;
		lex.Expect(PEND);
	    }
	    is GBEG then
		tree = CompositeValue(et);
	}
	return tree;
    }

    proc Unary(t:Type): Ast
    {   var tree: Ast;
	var tl: Type;
	var tok, savetok: TokenT;

	savetok = NONE;
	if savedsym == 0 then   // no symbol, OK to parse unary
	{   tok = Token;
	    savetok = tok;
	    if tok
	    is MINUS, PLUS, INV, NOT then tok = Next();
	}
	tree = Term(t);
	if tree != 0 then
	{   tl = tree@.type;
	    if savetok
	    is MINUS then
	    {   if tree@.type@.kind == FLOAT then
		    tree = ast.OpUnary(FNEG, tree);
		else
		{
		    tree = ast.OpUnary(NEG, tree);
		    if tree@.type@.kind == UINT then
			tree@.type = target.stype(tree@.width);
		}
	    }
	    is INV then
		tree =ast.OpUnary(NOT, tree);
	    is NOT then
	    {   tree = ast.ForceBoolean(tree);
		tree = ast.OpUnary(BNOT, tree);
	    }
	}
	return tree;
    }

    const mulop: [TokenT.STAR .. TokenT.AND]ast.Op = { MUL, DIV, MOD, LSL, LSR, AND  };
    const fmulop:[TokenT.STAR .. TokenT.AND]ast.Op = { FMUL,FDIV,FREM,NULL,NULL,NULL };
    proc Mul(t:Type): Ast
    {   var tree, rhs: Ast;
	var op: ast.Op;
	var tok, stok: TokenT;

	tree = Unary(t);
	if tree != 0 then
	{   loop
	    {   tok = Token;
	      exit tok < STAR || tok > AND;
	        stok = tok;
		tok = Next();
		if stok >= SHL && stok <= SHR then
		    rhs = Unary(0);	// don't force type on shifts
		else
		    rhs = Unary(tree@.type);
	      exit rhs == 0;
		if tree@.type@.kind == FLOAT then
		    tree = ast.OpFloat(fmulop[stok], tree, rhs, t);
		else
		{   op = mulop[stok];
		    if op
		    is AND then tree = ast.OpLogic(op, tree, rhs);
		    is MUL then tree = ast.OpMul(op, tree, rhs, t);
		    is DIV, MOD then tree = ast.OpDiv(op, tree, rhs, t);
		    is LSL then
		    {   if tree@.type@.kind == SINT then op = ASL;
			tree = ast.OpShfL(op, tree, rhs, t);
		    }
		    is LSR then
		    {   if tree@.type@.kind == SINT then op = ASR;
			tree = ast.OpShfR(op, tree, rhs, t);
		    }
		}
	    }
	}
	return tree;
    }

    const addop: [TokenT.PLUS .. TokenT.XOR]ast.Op = { ADD, SUB, OR,  XOR  };
    const faddop:[TokenT.PLUS .. TokenT.XOR]ast.Op = { FADD,FSUB,NULL,NULL };
    proc Add(t:Type): Ast
    {   var tree, rhs: Ast;
	var op: ast.Op;
	var tok, stok: TokenT;

	tree = Mul(t);
	if tree != 0 then
	{   loop
	    {   tok = Token;
	      exit tok < PLUS || tok > XOR;
	        stok = tok;
		tok = Next();
		rhs = Mul(tree@.type);
	      exit rhs == 0;
		if tree@.type@.kind == FLOAT then
		    tree = ast.OpFloat(faddop[stok], tree, rhs, t);
		elif tree@.type@.kind <= SINT then
		{   op = addop[stok];
		    if stok < OR then
			tree = ast.OpAdd(op, tree, rhs, t);
		    else
			tree = ast.OpLogic(op, tree, rhs);
		}
		else lex.ErrorS(OPTYPE, "add/sub/or/xor");
	    }
	}
	return tree;
    }


    proc ArrayCompare(op: ast.Op, lhs: Ast, rhs: Ast): Ast
    {   var tree: Ast;
	var lsize, rsize, align: Ast;
	var lalign, ralign: _uint;

	// FIXME: share code with stmt.AssignArray?
	if lhs@.type@.packed then
	{   if !rhs@.type@.packed then
		lex.ErrorS(NOTIMPL, "ArrayCompare: packed and not packed");
//	    lhs@.kind = UINT;   //FIXME
//	    rhs@.kind = UINT;   //FIXME
	    if op == AEQ then op = EQ; else op = NE;
	    tree = ast.New2(op, type.booltype, lhs, rhs);
	    tree@.width = 1;
	    return tree;
	}
	// FIXME the compares on lhs@.op and rhs@.op can be optimized
	if lhs@.op == LOAD && lhs@.type@.kind == ARRAY then	// undo LOAD
	    lhs = lhs@.child[0];
	if rhs@.op == LOAD && rhs@.type@.kind == ARRAY then	// undo LOAD
	    rhs = rhs@.child[0];
	if lhs@.op == CLIST || lhs@.op == SCON then
	    lhs = ast.New1(BYREF, type.MakeRef(lhs@.type), lhs);
	if rhs@.op == CLIST || rhs@.op == SCON then
	    rhs = ast.New1(BYREF, type.MakeRef(rhs@.type), rhs);
	lalign = GetAlignment(lhs);
	ralign = GetAlignment(rhs);
//err.str("ArrayCompare lalign="); err.uint(lalign);
//err.str(" ralign="); err.uint(ralign); err.nl();
	if ralign < lalign then lalign = ralign;
	if lhs@.op == SLICE then
	    lsize = lhs@.child[2];
	else
	    lsize = ast.ConstW(lhs@.type@.base@.Span());
	if rhs@.op == SLICE then
	    rsize = rhs@.child[2];
	else
	    rsize = ast.ConstW(rhs@.type@.base@.Span());
//err.str("ArrayCompare lsize=\n"); ast.Dump(lsize);
//err.str("rsize=\n"); ast.Dump(rsize);
	tree = ast.New2(op, type.booltype, lhs, rhs);
	tree@.width = 1;
	tree = ast.Child(tree, lsize);
	align = ast.ConstW(lalign);
	tree = ast.Child(tree, align);
	return tree;
    }

    proc NodeKind(node: Ast): TypeT
    {   var kind: TypeT;
	var t: Type;

//ast.Dump(node);
	t = node@.type;
	if node@.op
	is VAR, SLICE, INDEX, OFFSET then
	{   if t@.kind == REFPROC then
		kind = REFPROC;
	    else	// assume REF
		kind = t@.base@.kind;
	}
	else
	    kind = t@.kind;
//err.str("NodeKind kind="); err.str(type.KindName[kind]); err.nl();
	return kind;
    }

    const ucmpop: [TokenT.EQ .. TokenT.GE]ast.Op = { EQ, NE, ULT, UGT, ULE, UGE };
    const scmpop: [TokenT.EQ .. TokenT.GE]ast.Op = { EQ, NE, SLT, SGT, SLE, SGE };
    const fcmpop: [TokenT.EQ .. TokenT.GE]ast.Op = { FEQ, FNE, FLT, FGT, FLE, FGE };
    const revop:  [TokenT.EQ .. TokenT.GE]TokenT = { EQ, NE, GT, LT, GE, LE };
    proc Compare(t:Type): Ast
    {   var tree, rhs: Ast;
	var tok, savetok: TokenT;
	var op: ast.Op;
	var ok: boolean;

	tree = Add(t);
	tok = Token;
	if tok >= EQ && tok <= GE then
	{   savetok = tok;
	    tok = Next();
	    if tree != 0 then
	    {   rhs = Add(tree@.type);
		if rhs != 0 then
		{   if tree@.op == CONST || tree@.op == FCON then
		    {	tree, rhs = rhs, tree;	// swap LHS RHS
			savetok = revop[savetok];
		    }
		    ok = type.Compat(tree@.type, rhs@.type);
		    if NodeKind(tree)
		    is ENUM, UINT, SINT then
		    {   if IsSignedBinOp(tree, rhs) then
			{   // fix rhs const to be signed
			    if !ok && rhs@.op == CONST then
			    {	rhs@.type = tree@.type;
				ok = true;
			    }
			    op = scmpop[savetok];
			}
			else
			    op = ucmpop[savetok];
			tree = ast.OpCompare(op, tree, rhs);
		    }
		    is FLOAT then
		    {   op = fcmpop[savetok];
		        tree = ast.OpFloat(op, tree, rhs, 0);
			tree@.type = type.booltype;
			tree@.width = 1;
		    }
		    is REF, REFPROC then
		    {   if savetok
			is EQ then op = EQ;
			is NE then op = NE;
			else ok = false;
			if ok then
			{   if rhs@.op == CONST then
				rhs@.width = Target.ptr.size;
			    tree = ast.OpCompare(op, tree, rhs);
			}
		    }
		    is RECORD then
		    {   if NodeKind(rhs) == RECORD &&
			   tree@.type@.packed && rhs@.type@.packed then
			{   if savetok
			    is EQ then op = EQ;
			    is NE then op = NE;
			    else ok = false;
			    if ok then
				tree = ast.OpCompare(op, tree, rhs);
			}
			else ok = false;
		    }
		    is ARRAY then
		    {   if NodeKind(rhs) == ARRAY then
			{   if tree@.type@.packed && rhs@.type@.packed then
			    {   if savetok
				is EQ then op = EQ;
				is NE then op = NE;
				else ok = false;
				if ok then
				    tree = ast.OpCompare(op, tree, rhs);
			    }
			    else
			    {   if savetok
				is EQ then op = AEQ;
				is NE then op = ANE;
				else ok = false;
				if ok then
				    tree = ArrayCompare(op, tree, rhs);
			    }
			}
			else ok = false;
		    }
		    else ok = false;
		    if ok then
		    {   tree@.type = type.booltype;
			tree@.width = 1;
		    }
		    else
			lex.Error(BADCOMPARE);
		}
	    }
	}
	return tree;
    }

    proc BoolAnd(t:Type): Ast
    {   var tree, rhs: Ast;
	var tok: TokenT;

	tree = Compare(t);
	loop
	{   tok = Token;
	  exit tok != BAND;
	    tok = Next();
	    rhs = Compare(type.booltype);
	    if tree != 0 && rhs != 0 then
	    {	if tree@.op == CONST then
		{   if tree@.valu != 0 then     // LHS is true
			tree = rhs;		    // use RHS otherwise LHS
		}
		elif rhs@.op == CONST then
		{   if rhs@.valu == 0 then      // RHS is false
			tree = rhs;		    // use RHS (false) otherwise LHS
		}
		else
		    tree = ast.OpBool(BAND, tree, rhs);
	    }
	}
	return tree;
    }

    proc Bool(t:Type): Ast
    {   var tree, rhs: Ast;
	var tok: TokenT;

	tree = BoolAnd(t);
	loop
	{   tok = Token;
	  exit tok != BOR;
	    tok = Next();
	    rhs = Compare(type.booltype);
	    if tree != 0 && rhs != 0 then
	    {   if tree@.op == CONST then
		{   if tree@.valu == 0 then     // LHS is false
			tree = rhs;		    // use RHS otherwise LHS
		}
		elif rhs@.op == CONST then
		{   if rhs@.valu != 0 then      // RHS is true
			tree = rhs;		    // use RHS (false) otherwise LHS
		}
		else
		    tree = ast.OpBool(BOR, tree, rhs);
	    }
	}
	return tree;
    }

    proc GetRange(): Ast, Ast		// return lo, hi
    {   var lo, hi: Ast;
    	var s: Symb;
    	var t: Type;
    	var tok: TokenT;

	tok = Token;
	if tok == ID then
	{   s = symb.Find(lex.Ident);
	    tok = Next();
	    if s == 0 then
	    {   lex.ErrorI(UNDEFID, lex.Ident);
		return ast.Null, ast.Null;    // something that doesn't propagate errors
	    }
	    if s@.kind == TYPE then
	    {
		if tok == AEND || tok == ID then    // naked type
		{   t = s@.type;
		    hi = ast.Const(t, t@.hi);
		    lo = ast.Const(t, t@.lo);
		    return lo, hi;
		}
	    }
	    /* FIXME.
	     * At this point all the package prefixes have been stripped.
	     * If there were, there is no context to find the name again.
	     * Possible fixes:
	     * 1. create global 'savedsym' which expr.Term checks before call Find.
	     * 2. change all expr stuff to take an extra argument:
	     *    Bool(s, 0);  expr.Term checks before calling Find.
	     * 3. create an alias for current identifier to the symbol we found.
	     *    Perhaps remove it when we are done
	     * 4. Change expr routines to return naked AST "TYPE"
	     */
	    expr.savedsym = s;
	}
	lo = expr.Bool(0);
	if lo == 0 then     // default to something
	    lo = ast.ConstW(0);
	t = lo@.type;
	if Token == RANGE then
	{   tok = Next();
	    hi = expr.Bool(t);
	}
	else
	{   hi = ast.OpAdd(SUB, lo, ast.Const(t, 1), t);
	    lo = ast.Const(t, 0);
	}
	return lo, hi;
    }

    proc Const(t: Type): Ast
    {   var tree: Ast;

	if t != 0 then
	{   if t@.kind
	    is REF then
	    {	if Token
		is GBEG, STR then
		{   tree = Const(t@.base);
		    tree = ast.New1(BYREF, t, tree);
		}
		else
		{   tree = Bool(t);
		    if tree != 0 then
		    {   if tree@.op
			is CONST then   // pointer constant
			    tree@.type = t;
			is LOAD then    // reference to stored const
			{
			    tree = tree@.child[0];
			    // assert tree@.op == VAR
			    if t@.base@.flex && !tree@.type@.base@.flex then
				tree = ast.New1(CAST, t, tree);
			}
			else if tree@.type != t then
			{   if type.Compat(tree@.type, t@.base) then
				tree = ast.CoerceToRef(tree);
			    else
				lex.Error(BADCOMPV);
			}
		    }
		}
	    }
	    is RECORD then tree = RecordConst(t);
	    is ARRAY then  tree = ArrayConst(t);
	    is REFPROC then tree = Bool(t);     // FIXME?
	    else
	    {   tree = Bool(t);	    // scalar
		if tree != 0 then
		{   tree = ast.Extend(tree, t@.width, false);   // usually truncates
		    tree@.type = t;
		}
	    }
	}
	else tree = Bool(t);		// unknown type
	return tree;
    }

    proc ConstValue(t: Type): Valu
    {   var tree: Ast;
	var rv: Valu;

	rv = 0;
	tree = Bool(t);
	if tree != 0 then
	{   if tree@.op == CONST then
	    {   // FIXME: should check that types are compatable
		rv = tree@.valu;
		// free(tree)
	    }
	    else if tree@.op == LOAD &&
		    tree@.child[0]@.op == CONST then
	    {
		rv = tree@.child[0]@.valu;
	    }
	}
	else
	    lex.Error(EXPCONST);
	return rv;
    }

    proc ConstString(): Symb
    {   var tree: Ast;

	tree = expr.Bool(0);
	if tree != 0 then
	{   if tree@.op == SCON then
		return tree@.symb;
	    else if tree@.op == LOAD &&
		    tree@.child[0]@.op == VAR &&
		    tree@.child[0]@.symb@.const != 0 &&
		    tree@.child[0]@.symb@.const@.op == SCON then
	    {
		return tree@.child[0]@.symb@.const@.symb;
	    }
	}
	return 0;
    }
}
// vim: ts=8 sw=4 noet nowrap

