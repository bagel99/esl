// Copyright (c) 2009-2011, Brian G. Lucas.  See LICENSE file.
// $Id$

package expr
{
    const skiplist:[4]TokenT = { PEND, GEND, SEMI, NONE };

    const proplist:[]TokenT = { KMIN, KMAX, KBITSZ, KMEMSZ, KALIGN, KLEN, NONE };

    proc TypeProperty(t: Type): Ast
    {   var tree: Ast;
	var tok: TokenT;

	tree = 0;
	tok = Token;
	if tok == ID then
	{   tok = lex.Keyword(proplist);
	    if t != 0 then
	    {   if tok
		is KMIN then tree = ast.Const(t, t@.lo);
		is KMAX then tree = ast.Const(t, t@.hi);
		is KBITSZ then tree = ast.Const(type.wordtype, t@.size);
		is KMEMSZ then tree = ast.Const(type.wordtype, t@.width/Target.membits);
		is KALIGN then tree = ast.Const(type.wordtype, t@.align/Target.membits);
		is KLEN then
		{   if t@.kind == ARRAY && !t@.flex then
			tree = ast.Const(type.wordtype, t.Span());
		    else lex.Error(BADLEN);
		}
		else lex.Error(PROPID);
	    }
	    else
		tree = ast.Const(type.wordtype, 0); // t == 0, return something
	}
	else lex.Error(PROPID);
	tok = Next();
	return tree;					
    }

    var strid: Valu = 0;

    proc NewString(): Ast
    {   var tree: Ast;
	var t: Type;

	t = type.New(ARRAY);
	t@.base = type.bytetype;
	t@.index = type.wordtype;
	t@.lo = 0;
	t@.hi = lex.StringLen-1;
	t@.align = t@.base@.align;
	t@.memorder = Target.memorder;
	tree = ast.New(SCON, t);
//err.str("NewString \"");  err.str(lex.StringBuf); err.str("\"\n");
	tree@.symb = symb.NewString(lex.StringBuf, lex.StringLen);
//symb.DumpS(tree@.symb);
	strid += 1;
	tree@.valu = strid;
	return tree;
    }

    proc StringCat(tree: Ast): Ast
    {   var t: Type;
	var nl, nr: _uint;

	// modify the ARRAY type
	t = tree@.type;     // assert t@.kind == ARRAY
	nl = t@.hi;	    // LHS string length without nul termination
	nr = lex.StringLen; // RHS string length with nul termination
	t@.hi = nl+nr-1;
	tree@.symb = symb.NewString2(tree@.symb@.ident, nl, lex.StringBuf, nr);
//symb.DumpS(tree@.symb);
	return tree;   
    }

    // Parse string constants, perhaps concatenated
    proc String(): Ast
    {   var tree: Ast;
	var tok: TokenT;

        tree = NewString();
	loop
	{   tok = Next();
	  exit tok != STR;
	    tree = StringCat(tree);
	}
        return tree;
    }

    proc EnumConst(t: Type): Ast
    {   var s: Symb;
	var tree: Ast;

	// assert t@.kind == ENUM
	s = t@.list;
	while s != 0 do
	{   if zstr.eq(s@.ident, lex.Ident, lex.IdentMax) then
	    {   tree = ast.Dup(s@.const);
		tree@.width = s@.const@.type@.width;
		return tree;
	    }
	    s = s@.next;
	}
	lex.ErrorI(UNDEFID, lex.Ident);
	return 0;
    }

    proc IsAggregateConst(node: Ast): boolean
    {   var i: ast.NSubNodes;

//err.str("IsAggregateConst op="); err.str(ast.OpName[node@.op]); err.nl();
	if node@.op
	is SCON, FCON, CONST then return true;
	is VAR then
	{   if node@.type@.kind == REFPROC then
		return node@.symb@.kind == PROC;
	    else
		return node@.symb@.kind == CONSTANT;
	}
	is BYREF, CAST then return IsAggregateConst(node@.child[0]);
	is CLIST then
	{   i = 0;
	    while i < node@.num do
	    {   if !IsAggregateConst(node@.child[i]) then return false;
		i += 1;
	    }
	    return true;
	}
	return false;
    }

    proc CompositeNamedConstant(t: Type): Ast
    {   var cs: Symb;
	var ct: Type;
	var tree: Ast;
	var tok: TokenT;

        tree = 0;
	cs = symb.Find(lex.Ident);
	if cs != 0 then
	{   if cs@.kind == CONSTANT then
	    {   ct = cs@.type;
		if type.Compat(ct, t) then
		{   tree = cs@.const;
		    tree@.type = ct;
		}
		else lex.Error(BADCOMPV);
		tok = Next();
	    }
	    else if cs@.kind == TYPE then   // cast
	    {   tok = Next();
		if tok == PBEG then
		{   tok = Next();
		    tree = Bool(0);
		    lex.Expect(PEND);
		    tree = ast.Cast(tree, cs@.type);
		}
	    }
	    else
	    {   lex.Error(EXPCONST);
		tok = Next();
	    }
	}
	else lex.ErrorI(UNDEFID, lex.Ident);
	return tree;
    }

    proc ArrayPack(t:Type, intree:Ast): Ast
    {   var offs, tsize, fsize: type.BitSize;
	var i: ast.NSubNodes;
	var tree, vpart, node: Ast;
	var cpart, mask: type.Valu;
	var bt: Type;		// base type

	vpart = 0;
	cpart = 0;
	if intree@.op != CLIST then
	{   lex.ErrorS(COMPILER, "No CLIST for packed array");
	    return tree;
	}
	tsize = t@.width;
	bt = t@.base;
	fsize = bt@.size;
	mask = ((1 << fsize)-1);
	if t@.bitorder == MSB then offs = tsize; else offs = 0;
	i = 0;
	while i < intree@.num do
	{
	    if t@.bitorder == MSB then offs -= fsize;
	    node = intree@.child[i];
	    if node@.op == CONST then
	    {   ast.CheckConstTruncate(node, fsize);
		cpart = cpart | ((node@.valu&mask) << offs);
	    }
	    else
	    {   node = ast.Extend(node, tsize, false);
		node = ast.New2(LSL, bt, node,
				ast.Const(type.wordtype, offs));
		if vpart == 0 then
		    vpart = node;
		else
		    vpart = ast.New2(OR, bt, vpart, node);
	    }
	    if t@.bitorder != MSB then offs += fsize;
	    i += 1;
	}
	tree = ast.Extend(ast.Const(type.wordtype, cpart), tsize, false);
	if vpart != 0 then
	    tree = ast.New2(OR, type.wordtype, tree, vpart);
	tree@.type = t;
	return tree;
    }

    proc ArrayFixFlex(bt: Type, len: _uint): Type
    {   var t: Type;

	t = type.Clone(bt);
	t@.flex = false;
        t@.lo = 0;	    // FIXME
	t@.hi = len-1;      // FIXME
	t@.size = 0;
	t@.width = 0;
	t@.final = false;
	type.Final(t);
	return t;
    }

    proc ArrayConst(t: Type): Ast
    {   var tree, stree: Ast;
	var i, j, m, n: ast.NSubNodes;	// what type should this be
	var tok: TokenT;
	var once: boolean;

	tree = 0;
	tok = Token;
	if tok == GBEG then
	{   tree = ast.New(CLIST, t);
	    strid += 1;
	    tree@.valu = strid;
	    once = false;
//err.str("ArrayConst t="); type.DumpT(t, true); err.nl();
	    if t@.flex then n = 0;
		       else n = ast.NSubNodes(t.Span());
	    i = 0;
	    m = 0;
	    tok = Next();
	    loop
	    {   j = i;  // for non-designated initializer
		if tok == ABEG then	// designated initializer
		{   tok = Next();
//err.str("ArrayConst index="); type.DumpT(t@.index, true); err.nl();
		    i = ast.NSubNodes(ConstValue(t@.index)) -
			ast.NSubNodes(t@.lo);
		    j = i;
		    if Token == RANGE then
		    {   tok = Next();
			j = ast.NSubNodes(ConstValue(t@.index)) -
			    ast.NSubNodes(t@.lo);
		    }
		    tok = lex.Expect(AEND);
		    tok = lex.Expect(ASGN);
		}
		stree = Const(t@.base);
		if (n == 0 || j < n) && i <= j then	// still room
		{   while i <= j do
		    {   tree = ast.ChildIndexed(tree, i, stree);
		        i += 1;
		    }
		    if i > m then m = i;
		}
		else if !once then
		{   once = true;
		    lex.Error(INITHI);
		}
		tok = Token;
	      exit tok == GEND;
	        tok = lex.Expect(COMMA);
	      exit tok == GEND;
	    }
	    tok = lex.Expect(GEND);
	    if t@.flex then	// flex array becomes a static array
		t = ArrayFixFlex(t, m);
	    // make sure all elements are initialized in gaps
	    i = 0;
	    while i < m do
	    {	if tree@.child[i] == 0 then
		    tree@.child[i] = ast.Const(t@.base, 0);
		i += 1;
	    }
	    // make sure all fields are initialized at end
	    while i < n do
	    {   tree = ast.ChildIndexed(tree, i, ast.Const(t@.base, 0));
		i += 1;
	    }
	    tree@.type = t;
	    if t@.packed then
		tree = ArrayPack(t, tree);
	    else
	    {   if !IsAggregateConst(tree) then
		    lex.Error(BADCONST);
	    }
	}
	else if tok == STR then
	    tree = String();
	else if tok == ID then
	    tree = CompositeNamedConstant(t);
	else lex.ErrorT(EXPECT, GBEG);
	return tree;
    }

    proc RecordPack(t:Type, intree:Ast): Ast
    {   var offs, tsize, fsize: type.BitSize;
	var f: Symb;
	var i: ast.NSubNodes;
	var tree, vpart, node: Ast;
	var cpart, mask: type.Valu;
	var ft: Type;		// field type

	vpart = 0;
	cpart = 0;
	if intree@.op != CLIST then
	{   lex.ErrorS(COMPILER, "No CLIST for packed record");
	    return tree;
	}
	tsize = t@.width;
	f = t@.list;
	if t@.bitorder == MSB then offs = tsize; else offs = 0;
	i = 0;
	while f != 0 do
	{   if f@.type != 0 then
	    {   ft = f@.type;
		fsize = ft@.size;
		mask = ((1 << fsize)-1);
		if t@.bitorder == MSB then offs -= fsize;
		if i >= intree@.num then
		{   lex.ErrorS(COMPILER, "Malformed LIST for packed record");
		    return 0;
		}
		node = intree@.child[i];
		if node@.op == CONST then
		{   ast.CheckConstTruncate(node, fsize);
		    cpart = cpart | ((node@.valu&mask) << offs);
		}
		else
		{   node = ast.Extend(node, tsize, false);
		    node = ast.New2(LSL, ft, node,
				    ast.Const(type.wordtype, offs));
		    if vpart == 0 then
			vpart = node;
		    else
			vpart = ast.New2(OR, ft, vpart, node);
		}
		if t@.bitorder != MSB then offs += fsize;
	    }
	    f = f@.next;
	    i += 1;
	}
	tree = ast.Extend(ast.Const(type.wordtype, cpart), tsize, false);
	if vpart != 0 then
	    tree = ast.New2(OR, type.wordtype, tree, vpart);
	tree@.type = t;
	return tree;
    }

    // Convert flex record to non-flex record
    proc RecordFixFlex(bt: Type, node: Ast): Type
    {   var t: Type;
	var s, ps, bs: Symb;

//err.str("Init flex record\n");
	t = type.Clone(bt);
	// copy all fields because we need the change the final one
	ps = 0;
	bs = bt@.list;
	while bs != 0 do
	{   s = symb.New(FIELD, bs@.ident, PRIVATE);
	    if ps != 0 then ps@.next = s; else t@.list = s;
	    ps = s;
	    s@.type = bs@.type;
	    bs = bs@.next;
	}
	// final field must be the flex, change its type
	ps@.type = node@.child[node@.num-1]@.type;
	t@.base = bt;       // set base type for compatibility test
	// Recalculate size and width
	t@.size = 0;
	t@.width = 0;
	t@.final = false;
	type.Final(t);
	return t;
    }

    proc RecordConst(t: Type): Ast
    {   var tree, stree: Ast;
	var fs, ds: Symb;
	var ft: Type;
	var max: symb.OffsT;
	var tok: TokenT;
	var once: boolean;

	tree = 0;
	tok = Token;
	if tok == GBEG then
	{   tree = ast.New(CLIST, t);
	    strid += 1;
	    tree@.valu = strid;
	    once = false;
	    max = 0;
	    fs = t@.list;
	    loop
	    {   
		tok = Next();
		if tok == DOT then	// designated initializer
		{   tok = Next();
		    if tok == ID then
		    {   ds = symb.FindLocal(t@.list, lex.Ident);
			if ds != 0 then
			    fs = ds;
			else
			    lex.ErrorI(UNDEFID, lex.Ident);
			tok = Next();
		    }
		    else
			lex.Error(EXPECTID);
		    tok = lex.Expect(ASGN);
		}
		else		// sequential initializer
		{   while fs != 0 && fs.ispad do    // skip padding
			fs = fs@.next;
		}
		ft = 0;
		if fs != 0 then ft = fs@.type;
		stree = Const(ft);
		if fs != 0 then
		{   tree = ast.ChildIndexed(tree, fs@.addr, stree);
		    if fs@.addr > max then max = fs@.addr;
		    fs = fs@.next;
		}
		else if !once then
		{   once = true;
		    lex.Error(INITHI);
		}
		tok = Token;
	      exit tok != COMMA;
	    }
	    tok = lex.Expect(GEND);
	    // make sure all fields are initialized in gaps
	    fs = t@.list;
	    while fs != 0 && fs@.addr <= max do
	    {	if tree@.child[fs@.addr] == 0 then
		    tree@.child[fs@.addr] = ast.Const(fs@.type, 0);
		fs = fs@.next;
	    }
	    // make sure all fields are initialized at end
	    while fs != 0 do
	    {   tree = ast.ChildIndexed(tree, fs@.addr, ast.Const(fs@.type, 0));
		fs = fs@.next;
	    }
	    if t@.flex then
		tree@.type = RecordFixFlex(t, tree);
	    if t@.packed then
		tree = RecordPack(t, tree);
	    else
	    {   if !IsAggregateConst(tree) then
		    lex.Error(BADCONST);
	    }
	}
	else if tok == ID then
	    tree = CompositeNamedConstant(t);
	else lex.ErrorT(EXPECT, GBEG);
	return tree;
    }

    proc CompositeValue(t: Type): Ast
    {   var tree: Ast;

	tree = 0;
	if t != 0 then
	{   if t@.kind
	    is RECORD then tree = RecordConst(t);
	    is ARRAY  then tree = ArrayConst(t);
	    is REF then tree = CompositeValue(t@.base);
	    else lex.Error(BADCOMPV);
	}
	else lex.Error(UNDFCOMPV);
	return tree;
    }

    proc CalcAlign(base: _uint, offset: _uint): _uint
    {   var new, tz: _uint;


//err.str("CalcAlign: base="); err.uint(base);
//err.str(" offset="); err.uint(offset);
	if offset == 0 then
	    new = base;
	else
	{   tz = 0;
	    while offset&1 == 0 do	// count trailing zeros
	    {   offset = offset >> 1;
		tz += 1;
	    }
	    new = 1 << tz;
	    new = _min(base, new);      // can't be greater than base
	}
//err.str(" new="); err.uint(new); err.nl();
	return new;
    }

    proc FieldAlign(base: _uint, record: Type, fieldno: _uint): _uint
    {   var offs, i: _uint;
	var s: Symb;

	if record@.kind != RECORD then return 0;	// can't happen?
//err.str("FieldAlign: base="); err.uint(base);
//err.str(" fieldno="); err.uint(fieldno);
	offs = 0;
	i = 0;
	s = record@.list;
	while i < fieldno && s != 0 do
	{   if record@.packed then
		offs += s@.type@.size;
	    else
		offs += s@.type@.width / Target.membits;
	    i += 1;
	    s = s@.next;
	}
//err.str(" offs="); err.uint(offs); err.nl();
	return CalcAlign(base, offs);
    }

    proc GetAlignment(tree:Ast): _uint
    {   var alignment: _uint;

	if tree == 0 then return 0;
	alignment = 0;
//err.str("GetAlignment op="); err.str(ast.OpName[tree@.op]); err.nl();
	if tree@.op
	is VAR then 		// direct variable, use its alignment
	{   if tree@.type != 0 then
		alignment = tree@.type@.base@.align/Target.membits;
	}
	is LOAD then 		// via a pointer
	{   if tree@.type@.kind == REF && tree@.type != 0 then
		alignment = tree@.type@.base@.align/Target.membits;
	}
	is BSWAP, BYREF then
	    alignment = GetAlignment(tree@.child[0]);
	is OFFSET then 		// fixed offset
	{   alignment = GetAlignment(tree@.child[0]);
//err.str("GetAlignment OFFSET initial align="); err.uint(alignment); err.nl();
	    if alignment != 0 then
		alignment = FieldAlign(alignment, 
				       tree@.child[0]@.type@.base, _uint(tree@.valu));
	}
	is INDEX, SLICE then 	// possible variable offset
	{   alignment = GetAlignment(tree@.child[0]);
//err.str("GetAlignment INDEX/SLICE initial align="); err.uint(alignment); err.nl();
	    if alignment != 0 then
	    {   if tree@.child[1]@.op == CONST then
	        {
		    var size: _uint;
		    size = tree@.child[0]@.type@.base@.base@.width/Target.membits;
//err.str("\tsize="); err.uint(size); err.nl();
//err.str("\tindex="); err.uint(_uint(tree@.child[1]@.valu)); err.nl();
		    alignment = CalcAlign(alignment,
			_uint(tree@.child[1]@.valu)*size);
		}
		else
		    alignment = 0;
	    }
	}
	is CLIST, SCON then	// constant aggregate
	    alignment = tree@.type@.align;
	else
	{   lex.ErrorS(NOTIMPL, "GetAlignment: unexpected node");
	    ast.Dump(tree);
	}
//err.str("GetAlignment: final align="); err.uint(alignment); err.nl();
	return alignment;
    }

    proc GetSize(node: Ast): Ast
    {   var size, nsize: Ast;
	var tsize: type.BitSize;

//err.str("GetSize\n"); ast.Dump(node);
	size = 0;
	if node@.op
	is VAR then
	{   size = ast.Const(type.wordtype,
			     node@.type@.base@.width/Target.membits);
	}
	is LOAD then 		// via a pointer
	{   if node@.type@.kind == REF then
		size = ast.Const(type.wordtype,
				 node@.type@.base@.width/Target.membits);
	    else
		lex.ErrorS(COMPILER, "Load via non-REF");
	}
	is INDEX, OFFSET then
	{   size = ast.Const(type.wordtype,
			     node@.type@.base@.width/Target.membits);
	}
	is SLICE then
	{   size = ast.Const(type.wordtype,
			     node@.type@.base@.base@.width/Target.membits);
	    size = ast.New2(MUL, type.wordtype, node@.child[2], size);        
	}
	else
	{   lex.ErrorS(NOTIMPL, "GetSize: unexpected node");
	    ast.Dump(node);
	}
	if size == 0 then
	    size = ast.Const(type.wordtype, 0);
//err.str("returns\n"); ast.Dump(size);
	return size;
    }

    proc GetOffset(node: Ast): Ast
    {   var tree, ctree: Ast;

	tree = 0;
	if node@.op
	is OFFSET then
	{   var f: Symb;    // field symbol
	    var n, offset: _uint;   // field index
	    ctree = GetOffset(node@.child[0]);
	    // assert node@.child[0]@.type@.base@.kind == RECORD
	    offset = 0;
	    n = 0;
	    f = node@.child[0]@.type@.base@.list;
	    while f != 0 && n < node@.valu do
	    {   offset += f@.type@.width / Target.membits;
		f = f@.next;
		n += 1;
	    }
	    tree = ast.Const(type.wordtype, offset);		
	}   
	is INDEX then
	{
	    ctree = GetOffset(node@.child[0]);
	    // assert node@.child[0]@.type@.base@.kind == ARRAY
	    tree = ast.Const(type.wordtype,
		node@.child[0]@.type@.base@.base@.width / Target.membits);
	    tree = ast.New2(MUL, type.wordtype,
		ast.ExtendT(node@.child[1], type.wordtype), tree); 
	}
	if tree != 0 && ctree != 0 then
	    tree = ast.New2(ADD, type.wordtype, tree, ctree);
//err.str("GetOffset: final="); err.uint(offset); err.nl();
	return tree;
    }

    proc Slice(array: Ast, inx: Ast, len: Ast): Ast
    {   var at, st: Type;
	var tree: Ast;
	var blen, slen: type.BitSize;

//err.str("Slice: array=");  ast.Dump(array);
//err.str("inx="); ast.Dump(inx);
//err.str("len="); ast.Dump(len);
	at = array@.type@.base;
	st = type.New(ARRAY);       // FIXME: use Clone()?
	st@.base = at@.base;
	st@.packed = at@.packed;
	st@.memorder = at@.memorder;
	blen = 0;
	slen = 0;
	if !at@.flex then blen = type.BitSize(at.Span());
	if len != 0 then
	{   if len@.op == CONST then slen = type.BitSize(len@.valu);
	}
	else
	    len = ast.Const(type.wordtype, 0);  // stop error propagation
	if blen == 0 && slen == 0 then
	    st@.flex = true;
	else
	{   if slen == 0 then
	    {	slen = blen;	// worst case
		if inx@.op == CONST then
		    slen = blen - type.BitSize(inx@.valu);
	    }
	    else
	    {   // check slen < blen unless olen == 0
	    }
	    st@.hi = slen - 1;
	}
	st@.size = at@.base@.size * slen;
	st@.width = st@.size;
	if inx != 0 then
	{   if inx@.op == CONST then
	    {   var offs: _uint;
		offs = _uint(inx@.valu) * (at@.base@.width/Target.membits);
		st@.align = CalcAlign(at@.align/Target.membits, offs) *
		    Target.membits;
	    }
	    else    // Just take the alignment of the base type.
		st@.align = at@.base@.align;
	}
	else
	    inx = ast.Const(type.wordtype, 0);  // stop error propagation
	tree = ast.New2(SLICE, type.MakeRef(st), array, inx);
	tree = ast.Child(tree, len);
	return tree;
    }

    proc Load(tree: Ast): Ast
    {   var t: Type;

	if tree == 0 then return tree;
//err.str("Load: "); ast.Print(tree);
	t = tree@.type;
	if t@.kind == REF then
	{   t = t@.base;
	    if t != 0 then
	    {   tree = ast.New1(LOAD, t, tree);
		tree@.width = t@.width;
		if type.NeedSwap(tree@.type, Target.memorder) then
		{   tree = ast.New1(BSWAP, tree@.type, tree);
		    tree@.type = type.ChangeOrder(tree@.type, Target.memorder);
		}
	    }
	    else lex.Error(BADREF);
	}
	else if tree@.op != FIELD then        
	{   lex.ErrorS(COMPILER, "Load via non-REF");
ast.Dump(tree);
	}
	return tree;
    }

    proc CoerceToRef(tree: Ast): Ast
    {
	if tree@.op == LOAD then
	    tree = tree@.child[0];		// undo the load
	else if tree@.op == BSWAP && tree@.child[0]@.op == LOAD then
	    tree = tree@.child[0]@.child[0];
	// FIXME: this is very likely wrong
	if tree@.op
	is SCON, CLIST then
	    tree = ast.New1(BYREF, type.MakeRef(tree@.type), tree);
	is VAR then
	    {}
	else
	    tree = ast.New1(BYREF, tree@.type, tree);
	return tree;
    }

    proc CheckRefAttributes(to: Type, fm: Type): boolean
    {
	if to == 0 || fm == 0 then return false;
	// Check endian
	if to@.memorder != fm@.memorder then
	    return false;
	// Check alignment
	if to@.align > fm.align then
	    return false;
	if to@.kind == REF && fm@.kind == REF then
	    return CheckRefAttributes(to@.base, fm@.base);
	return true;
    }

    proc Adjust(tree: Ast, to: Type): Ast
    {   var fm: Type;
	var ok: boolean;

	fm = tree@.type;
	if fm == 0 then		// undefined type
	    return tree;
	ok = true;
	if to@.kind
	is REF then
	{   if to@.base != 0 then
	    {   if fm@.kind == REF && (to@.base == type.memtype || type.Compat(to, fm)) then
		{   if fm@.base != to@.base then
		    {   tree = ast.Cast(tree, to);
			fm = tree@.type;
		    }
		}
		else
		{   tree = CoerceToRef(tree);
		    fm = tree@.type;
		    // Coerce to REF memtype is always OK
		    if to@.base == type.memtype || type.Compat(to, fm) then
		    {   if fm != to then
			{   tree = ast.Cast(tree, to);
			    fm = tree@.type;
			}
		    }
		    else ok = false;
		}
		// Fix types when formal is a flex
		if to@.flex && !fm@.flex then
		    tree = ast.New1(CAST, to, tree);
		// Check attributes
		if !CheckRefAttributes(to, fm) then
		    lex.ErrorS(NOTIMPL, "Ref alignment or endian mismatch\n");
	    }
	}
	is REFPROC then
	{   ok = type.Compat(to, fm);
	}
	is ENUM then
	{   ok = type.Compat(fm, to);
	    if to@.width != tree@.width then
		tree = ast.ExtendT(tree, to);
	}
	is UINT then
	{   ok = type.Compat(fm, to);
	    if !ok then
	    {   if fm.kind == SINT then
		{   if feature.trunc then lex.Error(TOUNSIGN);
		    ok = true;
		}
	    }
	    if to@.width != tree@.width then
		tree = ast.ExtendT(tree, to);
	}
	is SINT then
	{   ok = type.Compat(fm, to);
	    if !ok && fm.kind == UINT then
	    {   if feature.trunc then lex.Error(TOSIGNED);
		ok = true;
	    }
	    if to@.width != tree@.width then
		tree = ast.ExtendT(tree, to);
	}
	is FLOAT then
	{
	    if to@.width != tree@.width then
		tree = ast.ExtendT(tree, to);
	}
	is RECORD, ARRAY then
	{   if fm.packed && to.packed then
	    {   ok = type.Compat(fm, to);
	        if ok && to@.width != tree@.width then
		    tree = ast.ExtendT(tree, to);		
	    }
	}
	if !ok then
{
	    lex.Error(TYPEASSIGN);
err.str("fm="); type.DumpT(fm, false);
err.str("\nto="); type.DumpT(to, false);
err.nl();
}
//	tree = CheckSwap(lhs, tree);    // FIXME - do for parms and retv?
	return tree;
    }

    proc IsSignedBinOp(lhs: Ast, rhs: Ast): boolean
    {
	if lhs@.type@.kind == SINT || rhs@.type@.kind == SINT then
	    return true;
	return false;
    }

    proc FindFlexSize(t: Type): type.BitSize
    {   var size: type.BitSize;
	var bt: Type;

	size = 1;   // some default
	if t != 0 then
	{   if t@.flex then
	    {   if t@.kind
		is ARRAY then
		    bt = t@.base;
		is RECORD then
		{   var f: Symb;
		    bt = 0;
		    f = t@.list;
		    while f != 0 do
		    {   bt = f@.type;
			f = f@.next;
		    }
		}
		if bt != 0 then size = FindFlexSize(bt);
	    }
	    else
		size = t@.width/Target.membits;
	}
	return size;
    }

    proc GetSizeSpec(t: Type): Ast
    {   var size, temp: Ast;
	var tok: TokenT;

        tok = Token;
	size = ast.Const(type.wordtype, t@.width/Target.membits);
	if tok == PBEG then
	{   tok = Next();
	    if !t@.flex then
		lex.Error(NOSIZE);
	    temp = Const(type.wordtype);
	    temp = ast.New2(MUL, type.wordtype, temp,
		ast.Const(type.wordtype, FindFlexSize(t)));
	    size = ast.New2(ADD, type.wordtype, size, temp);
	    tok = lex.Expect(PEND);
	}
	else if t@.flex then
	    lex.Error(NEEDSIZE);
	return size;
    }

    proc GetSpaceSpec(t: Type): Ast
    {   var space: Ast;
	var tok: TokenT;
    
        tok = Token;
	if tok == COMMA then
	{   tok = Next();
	    space = Const(type.wordtype);
	}
	else
	    space = ast.Const(type.wordtype, 0);
	return space;
    }

    proc SizeSpace(t: Type): Ast, Ast
    {   var size, space, temp: Ast;
	var tok: TokenT;

        tok = Token;
	size = ast.Const(type.wordtype, t@.width/Target.membits);
	if tok == PBEG then
	{   tok = Next();
	    if !t@.flex then
		lex.Error(NOSIZE);
	    temp = Const(type.wordtype);
	    temp = ast.New2(MUL, type.wordtype, temp,
		ast.Const(type.wordtype, FindFlexSize(t)));
	    size = ast.New2(ADD, type.wordtype, size, temp);
	    tok = lex.Expect(PEND);
	}
	else if t@.flex then
	    lex.Error(NEEDSIZE);
	if tok == COMMA then
	{   tok = Next();
	    space = Const(type.wordtype);
	}
	else
	    space = ast.Const(type.wordtype, 0);
	return size, space;
    }

    proc UnLoad(tree:Ast): Ast
    {
	if tree@.op == LOAD then
	    tree = tree@.child[0];
	// FIXME - BSWAP-LOAD
else
{   lex.ErrorS(COMPILER, "UnLoad error");
    ast.Dump(tree);
}
	return tree;
    }

    proc New(): Ast
    {   var tree, size: Ast;
	var s: Symb;
	var tok: TokenT;
	var t: Type;

	tree = 0;
	tok = Token;
	if tok == ID then
	{   t = 0;
	    s = symb.FindKind(lex.Ident, TYPE);
	    if s != 0 then
		t = s@.type;
	    tok = Next();
	    if t != 0 then
	    {   size = GetSizeSpec(t);
		tree = ast.New(CALL, 0);
		tree@.symb = symb.libnew;
		tree@.type = type.addrtype;
		tree@.width = Target.ptr.size;
		tree = ast.Child(tree, size);
		tree = ast.Child(tree,
			   ast.Const(type.wordtype, t@.align/Target.membits));
		tree = ast.Child(tree, GetSpaceSpec(t));
		tree = ast.New1(CAST, type.MakeRef(s@.type), tree);
	    }
	}
	else lex.Error(EXPECTID);
	return tree;
    }

    proc Delete(): Ast
    {   var tree, varb, size, temp: Ast;
	var tok: TokenT;
	var t: Type;

	tree = 0;
	varb = GetLHS(0);
	tok = Token;
	if varb != 0 then
	{   varb = Load(varb);
	    t = varb@.type@.base;
	    if t != 0 then
	    {   size = GetSizeSpec(t);
		tree = ast.New(CALL, 0);
		tree@.symb = symb.libdel;
		temp = ast.New1(CAST, type.addrtype, varb);
		tree = ast.Child(tree, temp);
		tree = ast.Child(tree, size);
		tree = ast.Child(tree, GetSpaceSpec(t));
	    }
	}
	else lex.Error(EXPECTID);
	return tree;
    }

    proc Zero(): Ast
    {   var tree, temp, size: Ast;
	var t: Type;
	var align: _uint;
	var tok: TokenT;

	tree = GetLHS(0);
	tok = Token;
	if tree != 0 then
	{
	    if tree@.op
	    is VAR then
	    {   if tree@.type@.kind == REF then
		{   t = tree@.type@.base;
		    if t@.kind == REF then
		    {   // dereference the pointer
			tree = ast.New1(LOAD, t, tree);
			t = t@.base;
		    }
		}
		else
		{   lex.ErrorS(COMPILER, "expr.Zero: VAR not REF");
		    return 0;
		}
		size = ast.Const(type.wordtype, t@.width/Target.membits);
		align = t@.align/Target.membits;
		if tok == PBEG then
		{   tok = Next();
		    if !t@.flex then
			lex.Error(NOSIZE);
		    temp = Const(type.wordtype);
		    temp = ast.New2(MUL, type.wordtype, temp,
			ast.Const(type.wordtype, FindFlexSize(t)));
		    size = ast.New2(ADD, type.wordtype, size, temp);
		    tok = lex.Expect(PEND);
		}
	    }
	    else
	    {   size = GetSize(tree);
		align = GetAlignment(tree);
	    }
	    tree = ast.New3(SET, type.unkntype, tree,
			    ast.Const(type.bytetype, 0), size);
	    tree = ast.Child(tree, ast.Const(type.wordtype, align));
	}
	return tree;
    }

    proc IntrinsicUnary(op: ast.Op): Ast
    {   var tree: Ast;

	tree = Bool(0);
	tree = ast.OpUnary(op, tree);
	return tree;
    }

    proc Rotate(right: boolean): Ast
    {   var tok: TokenT;
        var tree, shft: Ast;
        var op: ast.Op;

	tree = Bool(0);
	if tree@.type@.kind != UINT then
	    lex.Error(OPTYPE);
	if Token == COMMA then
	{   tok = Next();
	    shft = Bool(0);
	}
	else
	    lex.ErrorT(EXPECT, COMMA);
	if right then op = ROR; else op = ROL; 
	tree = ast.New2(op, tree@.type, tree, shft);  
	return tree;
    }

    proc GetArrayArg(): Ast,    // 0 if error
			Type,   // type of scalar just wide enought
			_uint,  // size in bytes
			boolean // is sufficiently aligned
    {   var arg: Ast;
	var nb, na: _uint;
        var ts: Type;
	var aligned: boolean;
	var t: Type;

        arg = Bool(0);     // FIXME - something less general?
        if arg == 0 then return 0, 0, 0, false;
        arg = UnLoad(arg);
        t = arg@.type;
        if !type.Compat(t, type.addrtype) then
        {
	    err.str("Arg for _packXX/_unpkXX must be array/slice of bytes\n");
	    return 0, 0, 0, false;
	}
	t = t@.base;
	nb = 0;      // this indicates illegal
	if arg@.op == SLICE then
	{   if arg@.child[2]@.op == CONST then
		nb = arg@.child[2]@.valu;
	}
	else    // assert array
	{   if !t@.flex then
	    nb = t.Span();
	}
	if nb == 0 then
	{
	    err.str("Array for _packXX/_unpkXX must have fixed size\n");
	    return 0, 0, 0, false;
	}
	ts = target.utype(nb*Target.membits);
	if ts == 0 then
	{
	    err.str("Array for _packXX/_unpkXX too large for target machine\n");
	    return 0, 0, 0, false;
	}
	if nb*Target.membits < ts@.width then
	    aligned = false;    // not a uint width
	elif !Target.mustalign then
	    aligned = true;     // width good and target accepts unaligned
	else
	{   na = GetAlignment(arg);
//err.str("na="); err.uint(na*Target.membits);
//err.str(" ta="); err.uint(ts@.align); err.nl();
	    aligned = na*Target.membits >= ts@.align;
	}    
        return arg, ts, nb, aligned;
    }


    proc Pack(endian: type.MemOrderT): Ast
    {   var tree: Ast;
	var arg: Ast;		// array slice AST
        var ta: Type;		// array slice type, next integral size
        var rhs: Ast;		// scalar AST
        var ts: Type;		// scalar type
        var n: _uint;		// size of array slice in bytes
        var aligned: boolean;   // aligment OK or not needed
        var tok: TokenT;

	arg, ta, n, aligned = GetArrayArg();
	if tok != COMMA then
	{   lex.ErrorT(EXPECT, COMMA);
	    return 0;
	}
	tok = Next();
	rhs = Bool(0);      // FIXME - we know the size/type of the uint?
	if arg == 0 || rhs == 0 then
	    return 0;
	if rhs@.type@.kind != UINT then
	{
	    err.str("Pack scalar must be unsigned int\n");
	    return 0;
	}
	rhs = ast.ExtendT(rhs, ta);
	ts = rhs@.type;
	if aligned then
	{   if endian != Target.memorder then
		rhs = ast.New1(BSWAP, rhs@.type, rhs);
	    arg = ast.Cast(arg, type.MakeRef(ta));
	    tree = ast.New2(STORE, ts, arg, rhs);
	}
	else
	{   var i, k: _uint;
	    var tmp: Ast;
	    arg@.type = type.MakeRef(arg@.type);
	    tree = ast.New(SEQ, 0);
	    i = 0;
	    loop
	    {   if endian == BE then k = n-i-1; else k = i;
		tmp = ast.New2(STORE, type.bytetype,
			ast.New2(INDEX, type.MakeRef(type.bytetype), arg,
			  ast.Const(type.wordtype, k)),
			    ast.Trunc(rhs, type.bytetype));
		tree = ast.Child(tree, tmp);
		i += 1;
	      exit i == n;
		rhs = ast.New2(LSR, ts, rhs, ast.Const(type.wordtype, 8));
	    }
	}
	tree = ast.New1(NOP, 0, tree);  // force no assignment
	return tree;
    }

    proc UnpkSub(tree: Ast, arg: Ast, ts: Type, i: _uint): Ast
    {   var rhs: Ast;

	rhs = ast.New1(LOAD, type.bytetype,
		ast.New2(INDEX, type.MakeRef(type.bytetype), arg,
		  ast.Const(type.wordtype, i)));
	rhs@.width = type.bytetype@.size;
	rhs = ast.ExtendT(rhs, ts);
	if tree == 0 then
	    tree = rhs;
	else
	    tree = ast.New2(OR, ts, 
		     ast.New2(LSL, ts, tree, ast.Const(type.wordtype, 8)), rhs);
	return tree;
    }

    proc Unpk(endian: type.MemOrderT): Ast
    {   var arg, tree: Ast;
        var ts: Type;
        var n: _uint;
        var aligned: boolean;

	arg, ts, n, aligned = GetArrayArg();
	if arg == 0 then
	    return 0;
	if aligned then
	{
	    tree = ast.Cast(arg, type.MakeRef(ts));
	    tree = Load(tree);
	    if endian != Target.memorder then
		tree = ast.New1(BSWAP, tree@.type, tree);
	}
	else
	{   var i: _uint;
	    arg@.type = type.MakeRef(arg@.type);
	    tree = 0;
	    if endian == BE then
	    {   i = 0;
		do
		{   tree = UnpkSub(tree, arg, ts, i);
		    i += 1;
		} while i < n;
	    }
	    else	// assert LE
	    {   i = n;
		while i > 0 do
		{   i -= 1;
		    tree = UnpkSub(tree, arg, ts, i);
		}
	    }
	}
	return tree;
    }

    proc Convert(): Ast
    {   var tok: TokenT;
        var tree: Ast;
        var t: Type;
        var s: Symb;
        var to, fm: TypeT;
        var op: ast.Op;

	tree = 0;
	t = 0;
        tok = Token;
        if tok == ID then
        {   s = symb.Find(lex.Ident);
	    if s != 0 then
	    {   if s@.kind == TYPE then
		    t = s@.type;
		else lex.Error(NOTTYPE);
	    }
	    else lex.ErrorS(UNDEFID, lex.Ident);
	    tok = Next();        
	    if tok == COMMA then
	    {   tok = Next();
		tree = Bool(0);
		if tree != 0 && t != 0 then
		{   to = t@.kind;
		    fm = tree@.type@.kind;
		    // FIXME - much more needed here
		    op = NULL;
		    if to
		    is  FLOAT then
		    {   if fm
			is UINT then op = CVTUF;
			is SINT then op = CVTIF;
		    }
		    is UINT then
		    {   if fm == FLOAT then op = CVTFU;
		    }
		    is SINT then
		    {   if fm == FLOAT then op = CVTFI;
		    }
		    if op != NULL then
		    {   tree = ast.New1(op, t, tree);
			tree@.width = t@.width;
		    }
		}
	    }
        }
        else lex.Error(NOTTYPE);
        return tree;
    }

    proc Intrinsic(ps: Symb): Ast
    {   var tree, lhs, rhs: Ast;
	var tok: TokenT;
	var which: symb.IntrinsicT;
	var op: ast.Op;

	tree = 0;
	tok = Token;
	if tok == PBEG then
	{   tok = Next();
	    which = symb.IntrinsicT(ps@.addr);
	    if which
	    is DEF then
	    {   if tok == ID then
		    tree = ast.Const(type.booltype,
				     _uint(symb.IsDefined(lex.Ident)));
		else lex.Error(EXPECTID);
	    }
	    is ABS then
	    {   tree = IntrinsicUnary(ABS);
		if tree != 0 && tree@.type@.kind == SINT then
		    tree@.type = target.utype(tree@.width);
	    }
	    is MIN, MAX then
	    {   lhs = Bool(0);
		lex.Expect(COMMA);
		rhs = Bool(0);
		if lhs != 0 && rhs != 0 then
		{   if IsSignedBinOp(lhs, rhs) then
			if which == MIN then op = SMIN; else op = SMAX;
		    else
			if which == MIN then op = UMIN; else op = UMAX;
		    tree = ast.OpMinMax(op, lhs, rhs);
		}
	    }
	    is ZLEN then
	    {   var align: _uint;
	        lhs = GetLHS(0);
		if lhs@.op == LOAD && lhs@.type@.kind == ARRAY then	// undo LOAD
		    lhs = lhs@.child[0];
		if lhs@.type@.kind != REF || lhs@.type@.base@.kind != ARRAY ||
		   lhs@.type@.base@.base@.kind != UINT ||
		   lhs@.type@.base@.base@.width != Target.membits then
		    lex.Error(OPTYPE);
	        align = GetAlignment(lhs);
	        tree = ast.New2(ZLEN, type.wordtype, lhs,
				ast.Const(type.wordtype, align));
		tree@.width = type.wordtype@.width;
	    }
	    is CLZ    then tree = IntrinsicUnary(CLZ);
	    is CLZNZ  then tree = IntrinsicUnary(CLZNZ);
	    is CTZ    then tree = IntrinsicUnary(CTZ);
	    is CTZNZ  then tree = IntrinsicUnary(CTZNZ);
	    is POP    then tree = IntrinsicUnary(POP);
	    is ROL    then tree = Rotate(false);
	    is ROR    then tree = Rotate(true);
	    is BSWAP  then tree = IntrinsicUnary(BSWAP);
	    is PACKLE then tree = Pack(LE);
	    is PACKBE then tree = Pack(BE);
	    is UNPKLE then tree = Unpk(LE);
	    is UNPKBE then tree = Unpk(BE);
	    is CVT    then tree = Convert();
	    is ZERO   then tree = Zero();
	    is NEW    then tree = New();
	    is DEL    then tree = Delete();
	    else
		lex.ErrorS(COMPILER, "Intrinsic unknown");
	    tok = lex.Expect(PEND);
	}
	else lex.ErrorT(EXPECT, PBEG);
	return tree;
    }

    proc Call(ps:Symb, tree: Ast, arg: Ast): Ast
    {   var t: Type;
	var s: Symb;
	var tok: TokenT;

	t = ps@.type;
	if tree == 0 then	// direct call
	    tree = ast.New(CALL, t);
	else			// indirect call
	    tree = ast.New1(CALLI, t, tree);
	tree@.symb = ps;
	if t != 0 then		// has returned value
	    tree@.width = t@.width;
	else
	    tree@.type = type.unkntype;
	s = ps@.parmlist;
	if arg != 0 then	// method call
	{   // assert s != 0
	    arg = Adjust(arg, s@.type);
	    tree = ast.Child(tree, arg);
	    s = s@.next;
	}
	tok = Token;
	if tok == PBEG then
	{   tok = Next();
	    if tok != PEND then
	    {   loop
		{
		  exit s == 0 with
		    {   lex.Error(ARGSHI);
			tok = lex.Skip(skiplist);
		    }
		    arg = Bool(s@.type);
		    if arg != 0 then
			arg = Adjust(arg, s@.type);
		    tree = ast.Child(tree, arg);
		    s = s@.next;
		    tok = Token;
		  exit tok != COMMA;
		    tok = Next();
		}
	    }
	    tok = lex.Expect(PEND);
	}
	else
	    lex.ErrorT(EXPECT, PBEG);
	if s != 0 && s@.linkage == FORMAL then
	    lex.Error(ARGSLO);
	return tree;
    }

    proc RefProc(s: Symb): Ast
    {   var t: Type;
	var tree: Ast;

	// must create a REFPROC type to point at proc symbol
	t = type.New(REFPROC);
	t@.list = s;
	tree = ast.New(VAR, t);
	tree@.symb = s;
	return tree;
    }

    proc BitfieldOffset(t: Type, fno: type.Valu): type.BitSize
    {   var foffs, rsize, fsize: type.BitSize;
	var s: Symb;
	var i: ast.NSubNodes;

        //if t@.kind == REF then t = t@.base;
	// assert t@.kind == RECORD
	rsize = t@.width;
	if t@.bitorder == MSB then foffs = rsize; else foffs = 0;
	s = t@.list;
	i = 0;
	while s != 0 do
	{   fsize = s@.type@.size;
	    if t@.bitorder == MSB then foffs -= fsize;
	  exit i == fno;
	    if t@.bitorder != MSB then foffs += fsize;
	    s = s@.next;
	    i += 1;
	}
	return foffs;
    }

    proc Suffix(tree: Ast, et: Type): Ast
    {   var t, bt: Type;
	var tok: TokenT;
	var done: boolean;
	var s: Symb;

	tok = Token;
	done = false;
	while !done && tree != 0 && tree@.type != 0 do
	{   t = tree@.type;
//lex.WhereAmI("Suffix TOP");  ast.Dump(tree);
	    if tok
	    is AT then
	    {   tok = Next();
		if t@.kind == REF then
		{
		    tree = Load(tree);
		    // FIXME - endian?
		}
		else if t@.kind == REFPROC then
		{   tree = Call(t@.list, tree, 0);
		    tok = Token;
		}
		else lex.Error(NOTREF);
	    }
	    is DOT then
	    {   tok = Next();
		{   if tok == ID then
		    {   bt = t;
			if t@.kind == REF then bt = t@.base;
			s = 0;
			loop
			{ exit bt == 0;
			    s = symb.FindMethod(bt@.meths, lex.Ident);
			  exit s != 0;
			    bt = bt@.base;
			}
			if s != 0 then		// method call
			{   tok = Next();
//err.str("Method use: ");  err.str(s@.ident); err.nl(); ast.Dump(tree);
			    if tok == PBEG then
			    {   tree = Call(s, 0, tree);
				tok = Token;
			    }
			    else
				tree = RefProc(s);
			}
			else
			{
			    if t@.kind == REF then
			    {   if t@.base != 0 then
				{   // FIXME - optimize Load followed by UnLoad?
				    tree = Load(tree);
				    t = t@.base;
				}
				else
				{   lex.Error(BADREF);
				    tree = 0;	// give up
				}
			    }
			    if t@.kind == RECORD then
			    {   s = symb.FindLocal(t@.list, lex.Ident);
				if s != 0 then
				{
				    if t@.packed then
				    {
					tree = ast.New2(FIELD, s@.type, tree,
					    ast.Const(type.wordtype, 
					    BitfieldOffset(t, s@.addr)));
					tree@.valu = s@.type@.size;
					tree@.width = s@.type@.width;
				    }
				    else
				    {   tree = UnLoad(tree);
					tree = ast.New1(OFFSET,
						type.MakeRef(s@.type), tree);
					tree@.valu = s@.addr;
					tree@.width = Target.ptr.size;
					tree = Load(tree);
				    }
				}
				else
				    lex.ErrorS(UNDEFFIELD, lex.Ident);
				tok = Next();
			    }
			    else
{
				lex.Error(NOTRECORD);
type.DumpT(t, false); err.nl();
}
			}
		    }
		    else lex.Error(EXPECTID);
		}
	    }
	    is ABEG then
	    {   tok = Next();
		if t@.kind == REF then
		{   if t@.base != 0 then
		    {   // FIXME - optimize Load followed by UnLoad?
			tree = Load(tree);
			t = t@.base;
		    }
		    else
		    {   lex.Error(BADREF);
			tree = 0;	// give up
		    }
		}
		if t@.kind == ARRAY then
		{   var index: Ast;
		    index = Bool(t@.index);
		    if index == 0 then
		    {   lex.Error(BADINXEXP);
			index = ast.Null;
		    }
		    // check for index out of bounds
		    if index@.op == CONST && !t@.flex &&
			    (index@.valu > t@.hi || index@.valu < t@.lo) then
		    {   lex.Error(BOUNDSERR);
			index@.valu = t@.lo;    // avoid additional errors
		    }
		    // make index zero based
		    if t@.lo != 0 then
		    {   if index@.op == CONST then
			    index@.valu -= t@.lo;
			else
			    index = ast.New2(SUB, t@.index, index,
					 ast.Const(t@.index, t@.lo));
		    }
		    tok = Token;
		    if tok == COLON then	// array slice
		    {   var len: Ast;
			tok = Next();
			tree = UnLoad(tree);
			len = Bool(t@.index);	// index type?
			// check for slice out of bounds
			// index is now zero based, so use hi-lo in check
			if len != 0 && len@.op == CONST &&
				index@.op == CONST  && !t@.flex &&
				index@.valu + len@.valu - 1 > (t@.hi - t@.lo) then
			    lex.Error(BOUNDSERR);
			tree = Slice(tree, index, len);
			tree = Load(tree);
			done = true;
		    }
		    else			// normal indexed
		    {
			if t@.packed then
			{
			    index = ast.ExtendT(index, type.wordtype);
			    index = ast.New2(MUL, type.wordtype, index,
				    ast.Const(type.wordtype, t@.base@.size));
			    tree = ast.New2(FIELD, t@.base, tree, index);
			    tree@.valu = t@.base@.size;
			    tree@.width = t@.base@.width;
			}
			else
			{
			    tree = UnLoad(tree);
			    tree = ast.New2(INDEX, type.MakeRef(t@.base),
					    tree, index);
			    tree@.width = Target.ptr.size;
			    tree = Load(tree);
			}
		    }
		}
		else        
		    lex.Error(NOTARRAY);
		tok = lex.Expect(AEND);
	    }
	    else done = true;
	}
	return tree;
    }

    proc Primary(s:Symb, et:Type): Ast
    {   var tree: Ast;
	var t: Type;

	tree = 0;
	t = s@.type;
	if s@.kind
	is VAR then
	{   tree = ast.New(VAR, type.MakeRef(t));
	    tree@.symb = s;
	    tree@.width = t@.width;
	    tree = Load(tree);
	}
	is CONSTANT then
	{   if t@.kind <= REF || t@.packed then
		tree = ast.Dup(s@.const);
	    else	// treat like a var
	    {   tree = ast.New(VAR, type.MakeRef(t));
		tree@.symb = s;
		tree@.width = t@.width;
		tree = Load(tree);
	    }
	}
	is PROC then
	{   if s@.addr != 0 then
		tree = Intrinsic(s);
	    else
	    {   if Token == PBEG then
		    tree = Call(s, 0, 0);
		else
		    tree = RefProc(s);
	    }
	}
	else lex.ErrorI(BADID, s@.ident);	// FIXME - need better message
	tree = Suffix(tree, et);
	return tree;
    }

    proc GetLHS(s: Symb): Ast
    {   var tok: TokenT;
	var tree: Ast;

	if s == 0 then
	{   tok = Token;
	    if tok == ID then
	    {   s = symb.Find(lex.Ident);
		tok = Next();
		if s == 0 then
		{   lex.ErrorI(UNDEFID, lex.Ident);
		    return 0;
		}
	    }
	    else
	    {   lex.Error(EXPECTID);
		return 0;
	    }
	}
	tree = Primary(s, 0);
	if tree != 0 then
	{   // undo the load  FIXME - same as UnLoad()?
	    if tree@.op == LOAD then
		tree = tree@.child[0];
	    else if tree@.op == BSWAP && tree@.child[0]@.op == LOAD then
		tree = tree@.child[0]@.child[0];
	}
	return tree;
    }

    proc Container(tree: Ast, t: Type): Ast
    {   var otree: Ast;

	otree = ast.New(VAR, type.MakeRef(t));
	otree@.symb = 0;
	otree@.width = t@.width;
	otree = Load(otree);
	otree = Suffix(otree, t);
	otree = UnLoad(otree);
	if otree != 0 then
	    otree = GetOffset(otree);
	if otree != 0 then
	{   tree = ast.Cast(tree, type.wordtype);
	    tree = ast.New2(SUB, type.wordtype, tree, otree);
	    tree = ast.Cast(tree, t);
	}
	return tree;                  
    }

    proc Term(et:Type): Ast
    {   var tree: Ast;
	var tok: TokenT;
	var t: Type;
	var s: Symb;

	tree = 0;
	tok = Token;
	s = savedsym;
	savedsym = 0;
	if s == 0 && tok == ID then    
	{   s = symb.Find(lex.Ident);
	    if s == 0 then
	    {   
		if et != 0 && et@.kind == ENUM then	// enum context
		    tree = EnumConst(et);
		else
		    lex.ErrorI(UNDEFID, lex.Ident);
		tok = Next();
		return tree;
	    }
	    tok = Next();
	}
	if s != 0 then      // we have a symbol
	{
	    if s@.kind == TYPE then
	    {   t = s@.type;
		if tok
		is DOT then		// possible enum const
		{   tok = Next();
		    if t@.kind == ENUM then
		    {   tree = EnumConst(t);
			tok = Next();
		    }
		    else
			lex.ErrorI(BADTYPE, s@.ident);
		}
		is QUEST then		// property
		{   tok = Next();
		    tree = TypeProperty(t);
		}
		is PBEG then		// cast
		{   tok = Next();
		    tree = Bool(0);	// FIXME: is this right?
		    tok = Token;
		    if tok == COMMA then
		    {   tok = Next();
			tree = Container(tree, t);
		    }
		    else    // simple cast
			tree = ast.Cast(tree, t);
		    tok = lex.Expect(PEND);
		}
		is GBEG then		// composite
		    tree = CompositeValue(t);
		else
		    lex.ErrorI(BADTYPE, s@.ident);
	    }
	    else
	    {
		tree = Primary(s, et);
		tok = Token;
		if tok == QUEST then
		{   tok = Next();
		    tree = TypeProperty(tree@.type);
		}
	    }
	}
	else	    // we don't have a symbol
	{
	    if tok
	    is NUM then
	    {   tree = ast.New(CONST, et);
		tree@.valu = lex.Number;
		tree@.width = type.bitsize(lex.Number);
		if et == 0 then
		    tree@.type = type.wordtype;	// FIXME: ?
		else
		{   if et@.kind
		    is UINT, SINT then
		    {   if et@.size > tree@.width then   // widen
			    tree@.width = et@.size;
		    }
		    is REF, REFPROC then    // want pointer constant
			tree@.width = Target.ptr.size;
		    else
			tree@.type = type.wordtype; // wrong type for numeric const
		}
		tok = Next();
	    }
	    is FNUM then
	    {   tree = ast.New(FCON, et);
		tree@.valu = lex.Number;
		tree@.width = 64;			// FIXME: ?
		tree@.scale = lex.Scale;
		if et == 0 then
		    tree@.type = type.floattype;
		tok = Next();
	    }
	    is STR then
		tree = String();
	    is PBEG then
	    {   tok = Next();
		tree = Bool(et);
		tok = Token;
		lex.Expect(PEND);
	    }
	    is GBEG then
		tree = CompositeValue(et);const TEST: boolean = true;

	}
	return tree;
    }

    proc Unary(t:Type): Ast
    {   var tree: Ast;
	var tl: Type;
	var tok, savetok: TokenT;

	savetok = NONE;
	if savedsym == 0 then   // no symbol, OK to parse unary
	{   tok = Token;
	    savetok = tok;
	    if tok
	    is MINUS, PLUS, INV, NOT then tok = Next();
	}
	tree = Term(t);
	if tree != 0 then
	{   tl = tree@.type;
	    if savetok
	    is MINUS then
	    {   if tree@.type@.kind == FLOAT then
		    tree = ast.OpUnary(FNEG, tree);
		else
		{
		    tree = ast.OpUnary(NEG, tree);
		    if tree@.type@.kind == UINT then
			tree@.type = target.stype(tree@.width);
		}
	    }
	    is INV then
		tree =ast.OpUnary(NOT, tree);
	    is NOT then
	    {   tree = ast.ForceBoolean(tree);
		tree = ast.OpUnary(BNOT, tree);
	    }
	}
	return tree;
    }

    const mulop: [TokenT.STAR .. TokenT.AND]ast.Op = { MUL, DIV, MOD, LSL, LSR, AND  };
    const fmulop:[TokenT.STAR .. TokenT.AND]ast.Op = { FMUL,FDIV,FREM,NULL,NULL,NULL };
    proc Mul(t:Type): Ast
    {   var tree, rhs: Ast;
	var op: ast.Op;
	var tok, stok: TokenT;

	tree = Unary(t);
	if tree != 0 then
	{   loop
	    {   tok = Token;
	      exit tok < STAR || tok > AND;
	        stok = tok;
		tok = Next();
		rhs = Unary(tree@.type);
	      exit rhs == 0;
		if tree@.type@.kind == FLOAT then
		    tree = ast.OpFloat(fmulop[stok], tree, rhs, t);
		else
		{   op = mulop[stok];
		    if op
		    is AND then tree = ast.OpLogic(op, tree, rhs);
		    is MUL then tree = ast.OpMul(op, tree, rhs, t);
		    is DIV, MOD then tree = ast.OpDiv(op, tree, rhs, t);
		    is LSL then
		    {   if tree@.type@.kind == SINT then op = ASL;
			tree = ast.OpMul(op, tree, rhs, t);
		    }
		    is LSR then
		    {   if tree@.type@.kind == SINT then op = ASR;
			tree = ast.OpDiv(op, tree, rhs, t);
		    }
		}
	    }
	}
	return tree;
    }

    const addop: [TokenT.PLUS .. TokenT.XOR]ast.Op = { ADD, SUB, OR,  XOR  };
    const faddop:[TokenT.PLUS .. TokenT.XOR]ast.Op = { FADD,FSUB,NULL,NULL };
    proc Add(t:Type): Ast
    {   var tree, rhs: Ast;
	var op: ast.Op;
	var tok, stok: TokenT;

	tree = Mul(t);
	if tree != 0 then
	{   loop
	    {   tok = Token;
	      exit tok < PLUS || tok > XOR;
	        stok = tok;
		tok = Next();
		rhs = Mul(tree@.type);
	      exit rhs == 0;
		if tree@.type@.kind == FLOAT then
		    tree = ast.OpFloat(faddop[stok], tree, rhs, t);
		else
		{   op = addop[stok];
		    if op < OR then
			tree = ast.OpAdd(op, tree, rhs, t);
		    else
			tree = ast.OpLogic(op, tree, rhs);
		}
	    }
	}
	return tree;
    }


    proc ArrayCompare(op: ast.Op, lhs: Ast, rhs: Ast): Ast
    {   var tree: Ast;
	var lsize, rsize, align: Ast;
	var lalign, ralign: _uint;

	// FIXME: share code with stmt.AssignArray?
	if lhs@.type@.packed then
	{   if !rhs@.type@.packed then
		lex.ErrorS(NOTIMPL, "ArrayCompare: packed and not packed");
//	    lhs@.kind = UINT;   //FIXME
//	    rhs@.kind = UINT;   //FIXME
	    if op == AEQ then op = EQ; else op = NE;
	    tree = ast.New2(op, type.booltype, lhs, rhs);
	    tree@.width = 1;
	    return tree;
	}
	// FIXME the compares on lhs@.op and rhs@.op can be optimized
	if lhs@.op == LOAD && lhs@.type@.kind == ARRAY then	// undo LOAD
	    lhs = lhs@.child[0];
	if rhs@.op == LOAD && rhs@.type@.kind == ARRAY then	// undo LOAD
	    rhs = rhs@.child[0];
	if lhs@.op == CLIST || lhs@.op == SCON then
	    lhs = ast.New1(BYREF, type.MakeRef(lhs@.type), lhs);
	if rhs@.op == CLIST || rhs@.op == SCON then
	    rhs = ast.New1(BYREF, type.MakeRef(rhs@.type), rhs);
	lalign = GetAlignment(lhs);
	ralign = GetAlignment(rhs);
//err.str("ArrayCompare lalign="); err.uint(lalign);
//err.str(" ralign="); err.uint(ralign); err.nl();
	if ralign < lalign then lalign = ralign;
	if lhs@.op == SLICE then
	    lsize = lhs@.child[2];
	else
	    lsize = ast.Const(type.wordtype, lhs@.type@.base@.Span());
	if rhs@.op == SLICE then
	    rsize = rhs@.child[2];
	else
	    rsize = ast.Const(type.wordtype, rhs@.type@.base@.Span());
//err.str("ArrayCompare lsize=\n"); ast.Dump(lsize);
//err.str("rsize=\n"); ast.Dump(rsize);
	tree = ast.New2(op, type.booltype, lhs, rhs);
	tree@.width = 1;
	tree = ast.Child(tree, lsize);
	align = ast.Const(type.wordtype, lalign);
	tree = ast.Child(tree, align);
	return tree;
    }
 
    proc NodeKind(node: Ast): TypeT
    {   var kind: TypeT;

	if node@.op
	is VAR, SLICE, INDEX, OFFSET then
	    kind = node@.type@.base@.kind;
	else
	    kind = node@.type@.kind;
//err.str("NodeKind kind="); err.str(type.KindName[kind]); err.nl();
//ast.Dump(node);
	return kind;
    }

    const ucmpop: [TokenT.EQ .. TokenT.GE]ast.Op = { EQ, NE, ULT, UGT, ULE, UGE };
    const scmpop: [TokenT.EQ .. TokenT.GE]ast.Op = { EQ, NE, SLT, SGT, SLE, SGE };
    const fcmpop: [TokenT.EQ .. TokenT.GE]ast.Op = { FEQ, FNE, FLT, FGT, FLE, FGE };
    proc Compare(t:Type): Ast
    {   var tree, rhs: Ast;
	var tok, savetok: TokenT;
	var op: ast.Op;
	var ok: boolean;

	tree = Add(t);
	tok = Token;
	if tok >= EQ && tok <= GE then
	{   savetok = tok;
	    tok = Next();
	    if tree != 0 then
	    {   rhs = Add(tree@.type);
		if rhs != 0 then
		{   ok = type.Compat(tree@.type, rhs@.type);
		    if NodeKind(tree)
		    is ENUM, UINT, SINT then
		    {   if IsSignedBinOp(tree, rhs) then
			    op = scmpop[savetok];
			else
			    op = ucmpop[savetok];
			tree = ast.OpCompare(op, tree, rhs);
		    }
		    is FLOAT then
		    {   op = fcmpop[savetok];
		        tree = ast.OpFloat(op, tree, rhs, 0);
			tree@.type = type.booltype;
			tree@.width = 1;
		    }
		    is REF, REFPROC then
		    {   if savetok
			is EQ then op = EQ;
			is NE then op = NE;
			else ok = false;
			if ok then
			    tree = ast.OpCompare(op, tree, rhs);
		    }
		    is RECORD then
		    {   if NodeKind(rhs) == RECORD &&
			   tree@.type@.packed && rhs@.type@.packed then
			{   if savetok
			    is EQ then op = EQ;
			    is NE then op = NE;
			    else ok = false;
			    if ok then
				tree = ast.OpCompare(op, tree, rhs);
			}
			else ok = false;
		    }
		    is ARRAY then
		    {   if NodeKind(rhs) == ARRAY then
			{   if tree@.type@.packed && rhs@.type@.packed then
			    {   if savetok
				is EQ then op = EQ;
				is NE then op = NE;
				else ok = false;
				if ok then
				    tree = ast.OpCompare(op, tree, rhs);
			    }
			    else
			    {   if savetok
				is EQ then op = AEQ;
				is NE then op = ANE;
				else ok = false;
				if ok then
				    tree = ArrayCompare(op, tree, rhs);
			    }
			}
			else ok = false;
		    }
		    else ok = false;
		    if !ok then
			lex.Error(BADCOMPARE);
		}
	    }
	}
	return tree;
    }

    proc BoolAnd(t:Type): Ast
    {   var tree, rhs: Ast;
	var tok: TokenT;

	tree = Compare(t);
	loop
	{   tok = Token;
	  exit tok != BAND;
	    tok = Next();
	    rhs = Compare(tree@.type);
	    if tree@.op == CONST then
	    {   if tree@.valu != 0 then     // LHS is true
		    tree = rhs;		    // use RHS otherwise LHS
	    }
	    elif rhs@.op == CONST then
	    {   if rhs@.valu == 0 then      // RHS is false
		    tree = rhs;		    // use RHS (false) otherwise LHS
	    }
	    else
		tree = ast.OpBool(BAND, tree, rhs);
	}
	return tree;
    }

    proc Bool(t:Type): Ast
    {   var tree, rhs: Ast;
	var tok: TokenT;

	tree = BoolAnd(t);
	loop
	{   tok = Token;
	  exit tok != BOR;
	    tok = Next();
	    rhs = BoolAnd(tree@.type);
	    if tree@.op == CONST then
	    {   if tree@.valu == 0 then     // LHS is false
		    tree = rhs;		    // use RHS otherwise LHS
	    }
	    elif rhs@.op == CONST then
	    {   if rhs@.valu != 0 then      // RHS is true
		    tree = rhs;		    // use RHS (false) otherwise LHS
	    }
	    else
		tree = ast.OpBool(BOR, tree, rhs);
	}
	return tree;
    }

    proc GetRange(): Ast, Ast		// return lo, hi
    {   var lo, hi: Ast;
    	var s: Symb;
    	var t: Type;
    	var tok: TokenT;

	tok = Token;
	if tok == ID then
	{   s = symb.Find(lex.Ident);
	    tok = Next();
	    if s != 0 && s@.kind == TYPE then
	    {
		if tok == AEND || tok == ID then    // naked type
		{   t = s@.type;
		    hi = ast.Const(t, t@.hi);
		    lo = ast.Const(t, t@.lo);
		    return lo, hi;
		}
	    }
	    /* FIXME.
	     * At this point all the package prefixes have been stripped.
	     * If there were, there is no context to find the name again.
	     * Possible fixes:
	     * 1. create global 'savedsym' which expr.Term checks before call Find.
	     * 2. change all expr stuff to take an extra argument:
	     *    Bool(s, 0);  expr.Term checks before calling Find.
	     * 3. create an alias for current identifier to the symbol we found.
	     *    Perhaps remove it when we are done
	     * 4. Change expr routines to return naked AST "TYPE"
	     */
	    expr.savedsym = s;
	}
	lo = expr.Bool(0);
	if Token == RANGE then
	{   tok = Next();
	    hi = expr.Bool(lo@.type);
	}
	else
	{   hi = ast.OpAdd(SUB, lo, ast.Const(lo@.type, 1), lo@.type);
	    lo = ast.Const(lo@.type, 0);
	}
	return lo, hi;
    }

    proc Const(t: Type): Ast
    {   var tree: Ast;

	if t != 0 then
	{   if t@.kind
	    is REF then
	    {	if Token
		is GBEG, STR then
		{   tree = Const(t@.base);
		    tree = ast.New1(BYREF, t, tree);
		}
		else
		{   tree = Bool(t);
		    if tree != 0 then
		    {   if tree@.op
			is CONST then   // pointer constant
			    tree@.type = t;
			is LOAD then    // reference to stored const
			{
			    tree = tree@.child[0];
			    // assert tree@.op == VAR
			    if t@.base@.flex && !tree@.type@.base@.flex then
				tree = ast.New1(CAST, t, tree);
			}
			else if tree@.type != t then
			{   if type.Compat(tree@.type, t@.base) then
				tree = CoerceToRef(tree);
			    else
				lex.Error(BADCOMPV);
			}
		    }
		}
	    }
	    is RECORD then tree = RecordConst(t);
	    is ARRAY then  tree = ArrayConst(t);
	    is REFPROC then tree = Bool(t);     // FIXME?
	    else
	    {   tree = Bool(t);	    // scalar
		if tree != 0 then
		{   tree = ast.Extend(tree, t@.width, false);   // usually truncates
		    tree@.type = t;
		}
	    }
	}
	else tree = Bool(t);		// unknown type
	return tree;
    }

    proc ConstValue(t: Type): Valu
    {   var tree: Ast;
	var rv: Valu;

	rv = 0;
	tree = Bool(t);
	if tree != 0 then
	{   if tree@.op == CONST then
	    {   // FIXME: should check that types are compatable
		rv = tree@.valu;
		// free(tree)
	    }
	    else if tree@.op == LOAD &&
		    tree@.child[0]@.op == CONST then
	    {
		rv = tree@.child[0]@.valu;
	    }
	}
	else
	    lex.Error(EXPCONST);
	return rv;
    }

    proc ConstString(): Symb
    {   var tree: Ast;

	tree = expr.Bool(0);
	if tree != 0 then
	{   if tree@.op == SCON then
		return tree@.symb;
	    else if tree@.op == LOAD &&
		    tree@.child[0]@.op == VAR &&
		    tree@.child[0]@.symb@.const != 0 &&
		    tree@.child[0]@.symb@.const@.op == SCON then
	    {
		return tree@.child[0]@.symb@.const@.symb;
	    }
	}
	return 0;
    }
}
// vim: ts=8 sw=4 noet nowrap

