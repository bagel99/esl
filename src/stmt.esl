// Copyright (c) 2009-2018, Brian G. Lucas.  See LICENSE file.

package stmt
{
    const isthenlist:[3]TokenT = { KIS, KTHEN, NONE };
    const iselselist:[3]TokenT = { KIS, KELSE, NONE };
    const thenlist:[2]TokenT = { KTHEN, NONE };
    const elselist:[3]TokenT = { KELSE, KELIF, NONE };
    const aslist:[2]TokenT = { KAS, NONE };
    const withlist:[2]TokenT = { KWITH, NONE };
    const fromlist:[3]TokenT = { KFROM, KIN, NONE };
    const tolist: [3]TokenT  = { KTO, KDOWNTO, NONE };
    const bylist:[2]TokenT = { KBY, NONE };
    const skiplist:[3]TokenT = { GEND, SEMI, NONE };
    type NestType: (PROGRAM, PACKAGE, PROCEDURE);
    const LoopMax = 32;
    var   LoopLevel: 0..LoopMax-1;

    proc Program(file:@[]_byte): Ast;	// forward
    proc ProgStmt(): Ast;		// forward
    proc Package(): Ast;		// forward
    proc PkgStmt(): Ast;		// forward
    proc Statement(): Ast;		// forward

    const skipgroup: [2]TokenT = { GEND, NONE };
    const skipstmt: [2]TokenT = { SEMI, NONE };
    const iflist: [2]TokenT = {KIF, NONE };

    proc CCSkip()
    {   var tok: TokenT;

	tok = Token;
//lex.WhereAmI("Beg skip");
	if tok == GBEG then
	{   lex.Skip(skipgroup);
	    lex.Expect(GEND);
	}
	else
	{   // Have to treat if statement differently
	    if tok == ID then
		tok = lex.Keyword(iflist);
	    if tok == KIF then
	    {   tok = lex.Skip(isthenlist);
		if tok
		is KTHEN then
		{   tok = Next();
		    CCSkip();
		    tok = lex.Keyword(elselist);
		}
		is KIS then
		{   loop
		    {   tok = Next();
			tok = lex.Skip(thenlist);
			if tok == KTHEN then
			{   tok = Next();
			    CCSkip();
			}
			tok = lex.Keyword(iselselist);
		      exit tok != KIS;
		   }
		}
		if tok == KELSE then
		{   tok = Next();
		    CCSkip();
		}
		else if tok == KELIF then
		{   Token = KIF;    // fake following if
		    CCSkip();
		}
	    }
	    else
	    {   lex.Skip(skipstmt);
	        lex.Expect(SEMI);
	    }
	}
//lex.WhereAmI("End skip");
    }

    proc CCDo(nest: NestType): Ast
    {   var tree, stree: Ast;
	var tok: TokenT;

//lex.WhereAmI("Beg do");
	tree = 0;
	if Token == GBEG then
	{   tok = Next();
	    tree = ast.New(SEQ, 0);
	    while tok != GEND && tok != ENDF do
	    {   if nest
		is PROGRAM then    stree = ProgStmt();
		is PACKAGE then    stree = PkgStmt();
		is PROCEDURE then  stree = Statement();
		if stree != 0 then
		    tree = ast.Child(tree, stree);
		tok = Token;
	    }
	    lex.Expect(GEND);
	}
	else
	{   if nest
	    is PROGRAM then    tree = ProgStmt();
	    is PACKAGE then    tree = PkgStmt();
	    is PROCEDURE then  tree = Statement();
	}
//lex.WhereAmI("End do");
	return tree;
    }

    proc CCIfStmt(nest: NestType): Ast;     // forward

    proc CCIfTail(ctree: Ast, nest: NestType): Ast
    {   var tree: Ast;
	var tok: TokenT;
	var t: Type;
	var val, vlo, vhi: Valu;
	var doneit, doit: boolean;

	tree = 0;
	t = ctree@.type;
	val = ctree@.valu;
	tok = lex.Keyword(isthenlist);
	if tok
	is KTHEN then
	{   tok = Next();
	    if !type.Compat(t, type.booltype) then
	    {   lex.Error(WANTBOOL);
		ctree@.valu = 0;    // just pick something and continue
	    }
	    doneit = boolean(val);
	    if doneit then
		tree = CCDo(nest);
	    else
		CCSkip();
	}
	is KIS then
	{   doneit = false;
	    loop
	    {   doit = false;
		loop
		{   tok = Next();
		    vlo = expr.ConstValue(t);
		    vhi = vlo;  // assume no range
		    tok = Token;
		    if tok == RANGE then
		    {   tok = Next();
			vhi = expr.ConstValue(t);
		    }
		    if vlo > vhi then
		    {   // FIXME: range error
		    }
		    doit = doit || (vlo <= val && val <= vhi);
		    tok = Token;
		  exit tok != COMMA;
		}
		tok = lex.Keyword(thenlist);
		if tok == KTHEN then
		    tok = Next();
		else lex.ErrorT(EXPECT, KTHEN);
		if doit && doneit then
		{   // FIXME: error message duplicate case
		    doit = false;
		}
		if doit then
		{   tree = CCDo(nest);
		    doneit = true;
		}
		else
		    CCSkip();
		tok = lex.Keyword(isthenlist);
	      exit tok != KIS;
	    }
	}
	else
	    lex.Error(BADIF);
	tok = lex.Keyword(elselist);
	if tok == KELSE then
	{   tok = Next();
	    if !doneit then
		tree = CCDo(nest);
	    else
		CCSkip();
	}
	else if tok == KELIF then
	{   Token = KIF;    // fake a following if
	    if !doneit then
		tree = CCDo(nest);
	    else
		CCSkip();
	}
	return tree;
    }

    proc CCIfStmt(nest: NestType): Ast
    {   var ctree: Ast;

	ctree = expr.Bool(0);
//err.str("CCIf:\n"); ast.Dump(ctree);
	if ctree == 0 || ctree@.op != CONST then
	{   lex.Error(EXPCONST);
	    return 0;
	}
	return CCIfTail(ctree, nest);
    }

    proc TypeDecl(): Ast
    {   var tree: Ast;
	var tok: TokenT;
	var s, bs: Symb;
	var t, bt: Type;

	tree = 0;
	tok = Token;
	if tok == ID then
	{
	    // FIXME: maybe handle package.symbol as type-identifier
	    s = symb.New(TYPE, lex.Ident, DELAYED);
	    bt = 0;	// assume not a derived type
	    tok = Next();
	    if tok == PBEG then
	    {   tok = Next();
		if tok == ID then
		{   bs = symb.Find(lex.Ident);
		    if bs != 0 then
		    {   if bs@.kind == TYPE then
			    bt = bs@.type;
			else
			    lex.Error(NOTTYPE);
		    }
		    else
			lex.ErrorI(UNDEFID, lex.Ident);
		    tok = Next();
		}
		tok = lex.Expect(PEND);
	    }
	    if !s@.forward then symb.MakeVisible(s);
	    if tok == COLON then
	    {   tok = Next();
		t = type.Def(tok, bt);
		if t != 0 then
		{   if t@.name != 0 then    // must clone named type (methods)
		    {   var at: Type;
			at = t;
			t = type.Clone(at);
			t@.atbase = at;
		    }
		    t@.name = s;
		}
		tok = Token;
		if tok == COLON then
		    t = type.TypeAttributes(t);
		s@.type = t;
		if s@.forward then
		    type.FwdFix(s, t);		// fix any forward references
		type.Final(t);
	    }
	    tok = lex.Expect(SEMI);
	}
	else
	    lex.Error(EXPECTID);
	return tree;
    }

    proc VarNew(s: Symb, t: Type, iv: Ast): Ast
    {   var node: Ast;

	s@.type = t;
	symb.MakeVisible(s);
	node = ast.New(DCLVAR, t);
	if iv != 0 then
	{   // Check for valid compile-time constant
	    if s@.linkage != LOCAL &&
		    !(iv@.op == CONST || iv@.op == FCON ||
		      iv@.op == CLIST || iv@.op == VAR) then
		lex.Error(EXPCONST);
	    else
		node = ast.Child(node, iv);
	}
	node@.width = t@.width;
	node@.symb = s;
	return node;
    }

    proc VarDecl(): Ast
    {   var tree, stree, iv: Ast;
	var tok: TokenT;
	var t: Type;
	var s, ss: Symb;

	tree = 0;
	tok = Token;
	if tok == ID then
	{   s = symb.New(VAR, lex.Ident, DELAYED);
	    ss = s;
	    tok = Next();
	    // Warning: this works because the symbols list is singly linked
	    while tok == COMMA do
	    {   tok = Next();
		if tok == ID then
		{   s = symb.New(VAR, lex.Ident, DELAYED);
		    tok = Next();
		}
		else
		    lex.Error(EXPECTID);
	    }
	    if tok == COLON then
	    {   tok = Next();
		t = type.Def(tok, 0);
		tok = Token;
		if tok == COLON then
		    t = type.VarAttributes(s, t);
		type.Final(t);
		tok = Token;
		if tok == PBEG then
		{   var val: Valu;
		    tok = Next();
		    if !t@.flex then
			lex.Error(NOSIZE);
		    val = expr.ConstValue(type.wordtype);
		    if t@.kind
		    is ARRAY then t = expr.ArrayFixFlex(t, _uint(val));
		    is RECORD then t = expr.RecordFixFlex(t, _uint(val));
		    tok = lex.Expect(PEND);
		}
		iv = 0;	// assume no initial value
		if tok == ASGN then
		{   tok = Next();
		    iv = expr.Const(t);
		    if t@.flex then
			t = iv@.type;       // iv may have fixed a flex
		    s@.hasdef = true;
		}
		if t@.flex && s@.linkage < WEAK then
		    lex.Error(FLEXSIZE);
	    }
	    else
	    {   t = type.unkntype;
		lex.ErrorT(EXPECT, COLON);
	    }
	    if ss@.next == 0 then	// just one
		tree = VarNew(ss, t, iv);
	    else
	    {   tree = ast.New(SEQ, 0);
		loop
		{   stree = VarNew(ss, t, iv);
		    tree = ast.Child(tree, stree);
		  exit ss == s || ss@.next == 0;
		    ss = ss@.next;
		}
	    }
	    tok = lex.Expect(SEMI);
	}
	return tree;
    }

    proc ConstDecl(): Ast
    {   var tree: Ast;
	var s: Symb;
	var t: Type;
	var tok: TokenT;

	tree = 0;
	tok = Token;
	if tok == ID then
	{   s = symb.New(CONSTANT, lex.Ident, DELAYED);
	    s@.const = ast.Null;	// in case a legal value is not parsed
	    tok = Next();
	    t = 0;
	    if tok == COLON then	// optional type
	    {   tok = Next();
		t = type.Def(tok, 0);
		tok = Token;
		if tok == COLON then	// optional attributes
		{   t = type.TypeAttributes(t);
		    tok = Token;
		}
		type.Final(t);
	    }
	    if tok == ASGN then
	    {   tok = Next();
		tree = expr.Const(t);
		if tree != 0 then
		{   if t == 0 then
			t = tree@.type;
		    else
		    {   if t@.flex then
			    t = tree@.type;
			else if tree@.op == SCON &&
			        t@.hi == tree@.type@.hi-1 then
			{   // we are allowed to trim the NUL from the string
err.str("Const SCON dup\n");
			    tree = ast.Dup(tree);   // dup in case re-using
			    tree@.type = t;
			}
			else if t != tree@.type then
			{
			    tree = ast.Dup(tree);   // dup in case re-using
			    tree@.type = t;
			}
		    }
		    s@.const = tree;
		    tree = ast.New1(DCLCON, t, tree);
		    tree@.symb = s;
		}
		s@.hasdef = true;
	    }
	    else
		lex.Error(BADCONST);
	    s@.type = t;
	    symb.MakeVisible(s);
	}
	else
	    lex.Error(EXPECTID);
	tok = lex.Expect(SEMI);
	return tree;
    }

    proc EndConstraint(what: @[]_byte, i: 0..lex.StringMax): 0..lex.StringMax
    {
	loop
	{   i += 1;
	  exit what@[i] == '}';
	}
	return i;
    }

    proc Asm(): Ast
    {   var tree, node, temp: Ast;
	var narg, nout: ast.NSubNodes;
	var tok: TokenT;
	var what: @[]_byte;		// constraint list
	var i: 0..lex.StringMax;	// index into constraint string
	const MaxArg = 9;
	type ArgRange: 0..MaxArg;
	var na, no: ArgRange;		// index into constraint array
	type constraintT: (IN=10, OUT);	// 0..9 are indirects
	var constraints: [ArgRange] constraintT;
	var outputs: [ArgRange]Ast;
	var rs, prevs: Symb;

	tree = ast.New(ASM, 0);
	tok = Token;
	// First is string of assembly language pattern
	if tok == STR then
	{   tree = ast.Child(tree, expr.String());
	    tok = Token;
	    if tok == COMMA then
	    {   tok = Next();
		narg = 0;
		nout = 0;
		// Next is string of constraints
		// Must be here if any operands, could be here even if none.
		if tok == STR then
		{   node = expr.String();
		    what = node@.symb@.ident;
		    tree = ast.Child(tree, node);
		    tok = Token;
		    // Parse the constraint string
		    i = 0;
		    while what@[i] != 0 && narg < MaxArg-1 do
		    {   if what@[i]
			is '=' then
			{   i += 1;
			    if what@[i] == '{' then
				i = EndConstraint(what, i);
			    nout += 1;
			    constraints[narg] = OUT;
			    narg += 1;
			}
			is '0'..'9' then
			{   constraints[narg] = constraintT(what@[i]-'0');
			    narg += 1;
			}
			is '~' then	// FIXME: handle this
			{
			    lex.ErrorS(NOTIMPL, "'~' in constraint");
			    if what@[i] == '{' then
				i = EndConstraint(what, i);
			}
			else
			{
			    if what@[i] == '{' then
				i = EndConstraint(what, i);
			    constraints[narg] = IN;
			    narg += 1;
			}
			i += 1;
		      exit what@[i] != ',';
			i += 1;
		    }
		}
		else lex.ErrorT(EXPECT, STR);
		// Now the list of operands
		na = 0;  no = 0;
		while na < narg do
		{
		    if constraints[na] < IN then	// reuse output as input
		    {
//		        node = expr.Load(outputs[ArgRange(constraints[na])]);
			node = expr.Load(outputs[_uint8(constraints[na])]);
			tree = ast.Child(tree, node);
		    }
		    else	// need a new argument
		    {   if tok == COMMA then
			{   tok = Next();
			    if constraints[na] == OUT then
			    {   outputs[no] = expr.GetLHS(0);
				no += 1;
			    }
			    else				// IN
			    {   node = expr.Bool(0);
				tree = ast.Child(tree, node);
			    }
			    tok = Token;
			}
			else lex.ErrorT(EXPECT, COMMA);
		    }
		    na += 1;
		}
		// Set the return value type
		// Returned values are Symb list on Ast symb.
		prevs = 0;
		no = 0;
		while no < nout do
		{   rs = symb.New(VAR, symb.anonid, PRIVATE);
		    rs@.type = outputs[no]@.type@.base;
		    if tree@.symb == 0 then
			tree@.symb = rs;
		    if prevs != 0 then
			prevs@.next = rs;
		    prevs = rs;
		    no += 1;
		}
		// Now store the outputs
		if nout > 0 then
		{   node = tree;
		    tree = ast.New(STORE, 0);
		    // do LHS first
		    no = 0;
		    while no < nout do
		    {   tree = ast.Child(tree, outputs[no]);
			no += 1;
		    }
		    if nout > 1 then
		    {   no = 0;
			while no < nout do
			{   temp = ast.New1(GETRV, outputs[no]@.type@.base, node);
			    temp@.width = temp@.type@.width;
			    temp@.valu = no;
			    tree = ast.Child(tree, temp);
			    no += 1;
			}
		    }
		    else
		    {   node@.type = outputs[0]@.type@.base;
			node@.width = outputs[0]@.type@.base@.width;
			tree = ast.Child(tree, node);
		    }
		}
	    }
	}
	else lex.ErrorT(EXPECT, STR);
	return tree;
    }

    proc CheckSwap(lhs: Ast, rhs: Ast): Ast
    {
	if type.NeedSwap(lhs@.type@.base, Target.memorder) then
	    rhs = ast.New1(BSWAP, rhs@.type, rhs);
	return rhs;
    }

    proc AssignRecord(lhs:Ast): Ast
    {   var tree: Ast;
	var t:Type;

	t = lhs@.type@.base;
	tree = expr.Term(t);
	if tree == 0 then return 0;
	if t@.packed then    // FIXME: not possible?
	{   tree = CheckSwap(lhs, tree);
	    tree = ast.New2(STORE, 0, lhs, tree);
	}
	else
	{   if tree@.op
	    is CLIST then
	    {   tree = ast.New1(BYREF, type.MakeRef(tree@.type), tree);
		tree = ast.New1(LOAD, tree@.type@.base, tree);
		tree = ast.New2(STORE, 0, lhs, tree);
	    }
	    is CALL then
		tree = ast.New2(STORE, 0, lhs, tree);
	    is LOAD then
	    {	tree = expr.UnLoad(tree);
		tree = ast.New4(COPY, 0, lhs, tree,
			expr.GetSize(lhs),
			ast.ConstW(expr.GetAlignment(lhs)));
	    }
	    else
		lex.ErrorS(COMPILER, "Unexpected RHS in AssignRecord");
	}
	return tree;
    }

    proc ArrayFix(tree:Ast): Ast
    {   var at: Type;

	if tree@.op
	is VAR then
	    tree = ast.New1(BYREF, tree@.type, tree);
	is CLIST then
	    {}
	at = tree@.type@.base;  // type of array
	if at@.base != type.bytetype || !at@.flex then
	    tree = ast.New1(CAST, type.MakeRef(type.memtype), tree);
	return tree;
    }

    proc AssignArray(lhs:Ast, rhs:Ast, op:ast.Op): Ast
    {   var tree, lsize, rsize, align: Ast;
	var lalign, ralign, width: _uint;
	var tl, tr:Type;

	if rhs == 0 then return 0;
	if rhs@.type == 0 || rhs@.type@.kind != ARRAY then
	{   lex.Error(NOTARRAY);
	    return 0;
	}
	tl = lhs@.type@.base;
	if tl@.packed then	// FIXME: not possible?
	{
err.str("Assign to packed array\n");
	    if lhs@.op == SLICE then
	    {   lex.ErrorS(NOTIMPL, "packed array slices");
		return 0;
	    }
	    rhs = CheckSwap(lhs, rhs);
	    tree = ast.New2(STORE, 0, lhs, rhs);
	}
	else
	{
	    lalign = expr.GetAlignment(lhs);
	    if lhs@.op == SLICE then
	    {   lsize = lhs@.child[2];
		width = lhs@.child[0]@.type@.base@.base@.width;
	    }
	    else
	    {   lsize = ast.ConstW(lhs@.type@.base@.Span());
		width = lhs@.type@.base@.base@.width;
	    }
	    if rhs@.op
	    is LOAD then
		rhs = expr.UnLoad(rhs);
	    is SCON, CLIST then
		rhs = ast.New1(BYREF, type.MakeRef(rhs@.type), rhs);
	    ralign = expr.GetAlignment(rhs);
	    if ralign < lalign then
		lalign = ralign;
	    if rhs@.op == SLICE then
		rsize = rhs@.child[2];
	    else
		rsize = ast.ConstW(rhs@.type@.base@.Span());
	    if ast.IsConstVal(lsize, 0) then
	    {   if ast.IsConstVal(rsize, 0) then
		    lex.Error(ARRAYCOPY);
		else
		    lsize = rsize;
	    }
	    else
	    {   if rsize@.op != CONST || rsize@.valu != 0 then
		    lsize = ast.OpMinMax(UMIN, lsize, rsize);
	    }
//err.str("width="); err.uint(width); err.nl();
//err.str("lsize="); ast.Dump(lsize);
//err.str("lalign="); err.uint(lalign); err.nl();

	    tree = ast.New4(op, lhs@.type.base,
			ArrayFix(lhs),
			ArrayFix(rhs),
			ast.OpMul(MUL,
			    ast.ExtendT(lsize, type.wordtype),
			    ast.ConstW(width/target.ByteSize),
			    type.wordtype),
			ast.ConstW(lalign));
	}
	return tree;
    }

    const ops: [TokenT.INCR .. TokenT.LETAND] ast.Op =
	{ ADD,  SUB,  OR,   XOR,  AND };
    const fops:[TokenT.INCR .. TokenT.LETAND] ast.Op =
	{ FADD, FSUB, NULL, NULL, NULL };

    proc Assign(lhs: Ast): Ast
    {   var tree, rhs, lrhs: Ast;
	var t: Type;
	var op: ast.Op;
	var tok, optok: TokenT;
	var nl, nr, i: ast.NSubNodes;
	var tl: Symb;

	tree = ast.New1(STORE, 0, lhs);
	nl = 1;
	loop
	{   tok = Token;
	  exit tok != COMMA;
	    tok = Next();
	    if tok == ID && symb.IsAnon(lex.Ident) then
	    {   tok = Next();
		lhs = 0;
	    }
	    else
		lhs = expr.GetLHS(0);
	    tree = ast.Child(tree, lhs);
	    nl += 1;
	}
	if tok >= ASGN && tok <= LETAND then
	{   optok = tok;
	    tok = Next();
	    if nl > 1 && optok != ASGN then
		lex.Error(ILLASSIGN);
	    nr = 0;
	    loop
	    {   lhs = tree@.child[nr];
		t = 0;
//err.str("Assign: lhs=\n");  ast.Dump(lhs);
		if lhs != 0 then
		{   if lhs@.op == FIELD then
			t = lhs@.type;
		    else if lhs@.type@.kind == REF then
			t = lhs@.type@.base;
		    else
		    {   lex.ErrorS(COMPILER, "Assign LHS not REF");
			ast.Dump(lhs);
			return 0;   // FIXME - rude, avoid segfault
		    }
		}
		if t != 0 && t@.kind == RECORD && !t@.packed then
		{   if optok <= ASGNR && nl == 1 then
			tree = AssignRecord(lhs);
		    else
			lex.Error(ILLASSIGN);
		    nr += 1;
		}
		else if t != 0 && t@.kind == ARRAY && !t@.packed then
		{   if optok <= ASGNR && nl == 1 then
		    {	if optok == ASGNR then op = MOVE; else op = COPY;
			rhs = expr.Term(lhs@.type@.base);
			tree = AssignArray(lhs, rhs, op);
		    }
		    else
			lex.Error(ILLASSIGN);
		    nr += 1;
		}
		else
		{   rhs = expr.Bool(t);	// right-hand side
		    if rhs != 0 then
		    {   if (rhs@.op == CALL || rhs@.op == CALLI) &&
			    rhs@.symb@.retvlist != 0 &&
			    rhs@.symb@.retvlist@.next != 0 then
			{   // call that returns multiple values
			    tl = rhs@.symb@.retvlist;
			    i = 0;
			    loop
			    {   lrhs = ast.New1(GETRV, tl@.type, rhs);
				lrhs@.width = tl@.type@.width;
				lrhs@.valu = i;
				if lhs != 0 && lhs@.op != FIELD then
				{   lrhs = ast.Adjust(lrhs, lhs@.type@.base);
				    lrhs = CheckSwap(lhs, lrhs);
				}
				tree = ast.Child(tree, lrhs);
				i += 1;
				tl = tl@.next;
			      exit i >= nl || tl == 0;
				lhs = tree@.child[nr+i];
			    }
			    nr += i;
			}
			else
			{   if rhs@.type != 0 then
			    {   if optok > ASGNR then
				{   lrhs = expr.Load(lhs);
				    if lrhs@.type@.kind == FLOAT then
					rhs = ast.OpFloat(fops[optok],
						lrhs, rhs, lrhs@.type);
				    else
				    {   op = ops[optok];
					if op < OR then
					    rhs = ast.OpAdd(op,
						    lrhs, rhs, 0);
					else
					    rhs = ast.OpLogic(op,
						    lrhs, rhs);
				    }
				}
				if lhs != 0 then
				{   if lhs@.op != FIELD then
				    {   rhs = ast.Adjust(rhs, lhs@.type@.base);
				        rhs = CheckSwap(lhs, rhs);
				    }
				}
			    }
			    else lex.Error(RHSASSIGN);
			    tree = ast.Child(tree, rhs);
			    nr += 1;
			}
		    }
		}
		tok = Token;
	      exit tok != COMMA;
		tok = Next();
	    }
	    if nl != nr then
	    {	if nl < nr then lex.Error(RHSLESS); else lex.Error(RHSMORE);
	    }
	}
	else
	    lex.Error(BADASSIGN);
	return tree;
    }

    proc AssignOrCall(s:Symb): Ast
    {   var tree: Ast;
	var tok: TokenT;

	tree = 0;
	if s@.kind == PACK then
	{   s = symb.FindPackage(s);
	    tok = Next();
	}
	if s != 0 then
	{   tree = expr.GetLHS(s);
	    if tree != 0 then
	    {   if tree@.op
		is CALL, CALLI, ASM, SET, NOP then {}     // no further action
		else tree = Assign(tree);
	    }
	}
	else
	{   lex.ErrorI(UNDEFID, lex.Ident);
	    tok = lex.Skip(skiplist);
	}
	tok = lex.Expect(SEMI);
	return tree;
    }

    proc Return(): Ast
    {   var tree, rval: Ast;
	var t: Type;
	var s: Symb;
	var tok: TokenT;

	tree = 0;
	s = 0;
	if symb.curproc != 0 then
	    s = symb.curproc@.retvlist;
	else
	    lex.Error(NOPROC);
	tree = ast.New(RET, 0);
	tok = Token;
	if !symb.curproc.retv then   // explicit return values
	{
	    loop
	    {
	      exit tok == SEMI;
		if s != 0 then
		    t = s@.type;
		else
		    t = 0;
		rval = expr.Bool(t);
		if rval != 0 then
		{   if s != 0 then
		    {   if t != 0 then
			{   rval = ast.Adjust(rval, t);
			    tree = ast.Child(tree, rval);
			    if t@.kind == REF then
			    {   tree@.type = t@.base;
				tree@.width = Target.ptr.size;
			    }
			    else
				tree@.width = t@.width;
			}
		    }
		    else	    // no RVs left
			lex.Error(RETTOOMANY);
		}
		if s != 0 then s = s@.next;
		tok = Token;

	      exit tok != COMMA;
		tok = Next();
	    }
	    if s != 0 then     // more RVs left
		lex.Error(RETTOOFEW);
	    if tree@.num != 0 then	// FIXME: fix in llvm?
	    {   tree@.type = tree@.child[0]@.type;	// first returned value
		tree@.width = tree@.child[0]@.width;
	    }
	}
	lex.Expect(SEMI);
	return tree;
    }

    proc Assert(): Ast
    {   var tree, ctree: Ast;
	var t: Type;

	ctree = expr.Bool(type.booltype);
	if feature.assert then
	{   ctree = ast.New1(NOT, 0, ctree);
	    tree = expr.NewString(symb.curfile@.ident,
				  zstr.len(symb.curfile@.ident, lex.PathMax),
				  true);
	    tree = ast.New1(BYREF, type.MakeRef(tree@.type), tree);
	    tree = ast.New1(CAST, type.addrtype, tree);
	    tree = ast.New1(ASSERT, 0, tree);
	    tree@.valu = 0;     // FIXME - make an enum
	    tree = ast.New3(IF, 0, ctree, tree, 0);
	    return tree;
	}
	return 0;
    }

    proc If(): Ast
    {   var tree, ctree, stree, vlo, vhi: Ast;
	var t: Type;
	var s: Symb;
	var tok, tok2: TokenT;
	var op: ast.Op;

	tree = 0;
	op = IF;	// arbitrary default
	ctree = expr.Bool(0);
	if ctree != 0 then
	{   if ctree@.op == CONST then
		return CCIfTail(ctree, PROCEDURE);
	    t = ctree@.type;
	    if type.Compat(t, type.booltype) then
		ctree = ast.ForceBoolean(ctree);
	    else
		op = SEL;
	    tree = ast.New(op, 0);
	    tree = ast.Child(tree, ctree);
	}
	tok = lex.Keyword(isthenlist);
	if tok
	is KIS then
	{   loop
	    {   ctree = ast.New(IS, 0);
		loop
		{   tok = Next();
		    vlo = expr.Bool(t);
		    if vlo != 0 && vlo@.op != CONST then
			lex.Error(EXPCONST);
		    tok = Token;
		    if tok == RANGE then
		    {   tok = Next();
			vhi = expr.Bool(t);
			if vhi != 0 then
			{   if vhi@.op != CONST then
				lex.Error(EXPCONST);
			    if vlo != 0 then
				vlo = ast.New2(CRANGE, vlo@.type, vlo, vhi);
			}
		    }
		    ctree = ast.Child(ctree, vlo);
		    tok = Token;
		  exit tok != COMMA;
		}
		lex.Expect(KTHEN);
		stree = Statement();
		ctree = ast.Child(ctree, stree);
		tree = ast.Child(tree, ctree);
		tok = lex.Keyword(isthenlist);
	      exit tok != KIS;
	    }
	}
	is KTHEN then
	{   if op == SEL then lex.Error(WANTBOOL);
	    tok = Next();
	    stree = Statement();
	    tree = ast.Child(tree, stree);
	}
	else
	    lex.Error(BADIF);
	tok = lex.Keyword(elselist);
	if tok == KELSE || tok == KELIF then // abiguous, could be assignment
	{   s = symb.FindTop(lex.Ident);
	    tok2 = Next();
	    if s != 0 then	// else is also a valid symbol, disabiguate
	    {   if tok2
		is ASGN, INCR, DECR, ABEG, DOT, AT, PBEG then
		    tok = ID;	// assignment or procedure call
	    }
	    if tok == ID then
	    {   stree = AssignOrCall(s);
		tree = ast.Child(tree, 0);	// no else
		// Put the current if-tree and the assignment/call tree
		// under a SEQ node and return that.
		if stree != 0 then
		    tree = ast.New2(SEQ, 0, tree, stree);
	    }
	    else	// really the else part
	    {   if tok == KELIF then
		    stree = If();
		else    // ELSE
		    stree = Statement();
		tree = ast.Child(tree, stree);
	    }
	}
	else
	    tree = ast.Child(tree, 0);	// no else
	return tree;
    }

    proc For(): Ast
    {   var tree, exit, init, body, incr, ix, fm, to, by: Ast;
	var t: Type;
	var tok, totok: TokenT;
	var s: Symb;
	var cmpop, incop: ast.Op;

	tree = 0;
	tok = Token;
	if tok == ID then
	{   s = symb.Find(lex.Ident);
	    if s != 0 && s@.kind == VAR then
	    {   t = s@.type;
		if t@.kind == SINT then cmpop = SGT; else cmpop = UGT;
		ix = ast.New(VAR, type.MakeRef(s@.type));
		ix.symb = s;
	    }
	    else
	    {   lex.ErrorI(UNDEFID, lex.Ident);
		t = type.unkntype;
		ix = 0;
	    }
	    incop = ADD;	// unless downto
	    tok = Next();
	    tok = lex.Keyword(fromlist);
	    if tok
	    is KIN then
	    {   tok = Next();
		fm, to = expr.GetRange();
		by = ast.Const(t, 1);
		lex.Expect(KDO);
	    }
	    is KFROM then
	    {   tok = Next();
		fm = expr.Bool(t);
		totok = lex.Keyword(tolist);
		if totok == KDOWNTO then
		{   incop = SUB;
		    cmpop = SLT;	// even for unsigned index
		}
		tok = Next();
		to = expr.Bool(t);
		if to@.op == SUB && ast.IsConstVal(to@.child[1], 1) then
		{   // optimize the n-1 endpoint
		    to = to@.child[0];
		    if cmpop == UGT then cmpop = UGE; else cmpop = SGE;
		}
		tok = lex.Keyword(bylist);
		if tok == KBY then
		{   tok = Next();
		    by = expr.Bool(t);
		}
		else
		    by = ast.Const(t, 1);
		lex.Expect(KDO);
	    }
	    else
	    {   lex.Error(BADFOR);
		tok = Next();       // FIXME skip?
	    }
	    init = 0;
	    exit = 0;
	    incr = 0;
	    if ix != 0 then
	    {   if fm != 0 then
		{   fm = ast.Adjust(fm, ix@.type@.base);
		    init = ast.New2(STORE, t, ix, fm);
		}
		if to != 0 then
		    exit = ast.New1(EXIT, 0,
			     ast.OpCompare(cmpop, expr.Load(ix), to));
		incr = ast.New2(STORE, t, ix,
			 ast.OpAdd(incop, expr.Load(ix), by, t));
	    }
	    body = Statement();
	    body = ast.New3(SEQ, 0, exit, body, incr);
	    body = ast.New1(LOOP, 0, body);
	    tree = ast.New2(SEQ, 0, init, body);
	}
	else lex.ErrorT(EXPECT, ID);
	return tree;
    }

    proc While(): Ast
    {   var tree, ctree: Ast;

	ctree = expr.Bool(type.booltype);
	if ctree != 0 then
	{   if type.Compat(ctree@.type, type.booltype) then
		ctree = ast.ForceBoolean(ctree);
	    else
		lex.Error(WANTBOOL);
	    ctree = ast.New1(BNOT, 0, ctree);
	    ctree = ast.New1(EXIT, 0, ctree);
	}
	LoopLevel += 1;
	lex.Expect(KDO);
	tree = Statement();
	tree = ast.New2(SEQ, 0, ctree, tree);
	tree = ast.New1(LOOP, 0, tree);
	if LoopLevel > 0 then
	    LoopLevel -= 1;
	return tree;
    }

    proc Do(): Ast
    {   var tree, ctree: Ast;

	LoopLevel += 1;
	tree = Statement();
	lex.Expect(KWHILE);
	ctree = expr.Bool(type.booltype);
	if ctree != 0 then
	{   if type.Compat(ctree@.type, type.booltype) then
		ctree = ast.ForceBoolean(ctree);
	    else
		lex.Error(WANTBOOL);
	    ctree = ast.New1(BNOT, 0, ctree);
	    ctree = ast.New1(EXIT, 0, ctree);
	}
	tree = ast.New2(SEQ, 0, tree, ctree);
	tree = ast.New1(LOOP, 0, tree);
	if LoopLevel > 0 then
	    LoopLevel -= 1;
	return tree;
    }

    proc Loop(): Ast
    {   var tree, stree: Ast;
	var tok: TokenT;

	tree = 0;
	tok = Token;
	LoopLevel += 1;
	tree = ast.New(LOOP, 0);
	stree = Statement();
	tree = ast.Child(tree, stree);
	if LoopLevel > 0 then
	    LoopLevel -= 1;
	return tree;
    }

    proc Exit(): Ast
    {   var tree, wtree, ctree: Ast;
	var tok: TokenT;

	tree = 0;
	tok = Token;
	if LoopLevel == 0 then
	    lex.Error(NOLOOP);
	tree = ast.New(EXIT, 0);
	ctree = expr.Bool(type.booltype);
	if ctree != 0 then
	{   if type.Compat(ctree@.type, type.booltype) then
		ctree = ast.ForceBoolean(ctree);
	    else
		lex.Error(WANTBOOL);
	}
	tree = ast.Child(tree, ctree);
	tok = lex.Keyword(withlist);
	if tok == KWITH then
	{   tok = Next();
	    wtree = Statement();
	    ast.Child(tree, wtree);
	}
	else
	    lex.Expect(SEMI);
	return tree;
    }

    proc Alias(): Ast
    {   var s, ns: Symb;
	var tok: TokenT;

	tok = Token;
	loop
	{   if tok == ID then
	    {   s = symb.FindTop(lex.Ident);
		if s != 0 then
		{   loop
		    {   tok = Next();
		      exit s == 0 || tok != DOT || s@.kind != PACK;
			tok = Next();
			if tok == ID then
			{   s = symb.FindLocal(s@.symblist, lex.Ident);
			    if s == 0 then
				lex.ErrorI(UNDEFID, lex.Ident);
			}
			else lex.Error(EXPECTID);
		    }
		}
		else
		{   lex.ErrorI(UNDEFID, lex.Ident);
		    tok = Next();
		}
		tok = lex.Keyword(aslist);
		if tok == KAS then
		{   tok = Next();
		    if tok == ID then
		    {   ns = symb.FindTop(lex.Ident);
			if ns == 0 then		// name unused, normal case
			{   s = symb.Clone(s, lex.Ident);
			    tok = Next();
			}
			else
			{   if ns@.kind == PACK then
			    {   tok = Next();
				if tok == DOT then
				{   tok = Next();
				    if tok == ID then
				    {   ns = symb.FindLocal(ns@.symblist, lex.Ident);
					if ns != 0 then
					{   if s@.kind == TYPE && ns@.kind == TYPE then
						// fix inter-package fwd type
						type.FwdFix(ns, s@.type);
					    elif s@.kind == PROC && ns@.kind == PROC &&
					         ns@.forward then
					    {
err.str("Fix cross package forward proc\n");
symb.DumpS(s);
symb.DumpS(ns);
					    }
					    else lex.Error(NOTTYPE);
					}
					else lex.ErrorI(UNDEFID, lex.Ident);
					tok = Next();
				    }
				    else lex.Error(EXPECTID);
				}
				else lex.ErrorI(DEFID, lex.Ident);
			    }
			    else
			    {   // ident was defined, but not a package
				// if not at this level, we can alias to it
				if symb.FindThisLevel(lex.Ident) == 0 then
				    s = symb.Clone(s, lex.Ident);
				else
				    lex.ErrorI(DEFID, lex.Ident);
				tok = Next();
			    }
			}
		    }
		    else lex.Error(EXPECTID);
		}
		else lex.ErrorT(EXPECT, KAS);
	    }
	    else lex.Error(EXPECTID);
	  exit tok != COMMA;
	    tok = Next();
	}
	tok = lex.Expect(SEMI);
	return 0;
    }

    proc ErrorStmt(): Ast
    {   var tok: TokenT;

	tok = Token;
	if tok == STR then
	{   lex.ErrorS(PROGERROR, lex.StringBuf);
	    tok = Next();
	}
	else lex.ErrorT(EXPECT, STR);
	return 0;
    }

import format;

    proc ParseFormat(bd: Ast): Ast
    {   var tok: TokenT;
	var tree, fmt, rtf, exp: Ast;
	var fmtstr: @[]_byte;
	var fmtlen: _uint;

	lex.Expect(COMMA);
	tok = Token;
	if tok == STR then
	{   fmt = expr.String();
	    fmtstr = fmt@.symb@.ident;
	    fmtlen = fmt@.type.Span();
	}
	else lex.ErrorT(EXPECT, STR);
	tok = Token;
	var i: _uint = 0;	// where we are in the format string
	var n: _uint;		// how much of the format string we just used
	tree = ast.New(SEQ, 0);
	while tok == COMMA do
	{   tok = lex.Next();
	    exp = expr.Bool(0);
	    n, rtf = format.NextFormat(bd, fmtstr, i, exp);
	    i += n;
	    tree = ast.Child(tree, rtf);
	    tok = Token;
	}
	if i < fmtlen then
	{   n, rtf = format.NextFormat(bd, fmtstr, i, 0);
	    tree = ast.Child(tree, rtf);
	}
	return tree;
    }

    proc FormatStmt(): Ast
    {   var tok: TokenT;
	var s: Symb;
	var t, bt: Type;
	var buf, bd, end, start, len, tree: Ast;
	var fmtstr: @[]_byte;
	var fmtlen, buflen: _uint;
	var needload: boolean = false;

//err.str("FormatStmt beg\n");
	buf = expr.GetLHS(0);
//err.str("buf1=\n"); ast.Dump(buf);
	// FIXME - check for array of bytes
	s = buf@.symb;
	t = buf@.type;
	bt = t@.base;
	if bt@.kind == REF then
	{   bt = bt@.base;
	    needload = true;
	}
	if bt@.kind != ARRAY then
	{   lex.Error(OPTYPE);
	    return 0;
	}
	buflen = 0;
	// The following is similar to expr.GetSizeSpec()
	tok = Token;
	if tok == PBEG then
	{   tok = Next();
	    len = expr.Const(type.wordtype);
	    // assert len.op == CONST
	    buflen = len.valu;
//err.str("len=\n"); ast.Dump(len);
	    tok = lex.Expect(PEND);
	}
	if bt@.flex then
	{   if buflen == 0 then
		lex.Error(NEEDSIZE);
	}
	else
	    buflen = bt.Span();
//err.str("buflen="); err.uint(buflen); err.nl();
	t.reftype = 0;		// force REF
	t = type.MakeRef(t);
//err.str("t1="); type.DumpT(t, true); err.nl();
	buf = ast.Var(s, t);
	if needload then
	    buf = expr.Load(buf);
//err.str("buf2=\n"); ast.Dump(buf);
	bd, start = format.Start(buf, buflen);
	if bd == 0 then	// fatal problems
	{   lex.Skip(skipstmt);
	    return 0;
	}
	tree = ParseFormat(bd);
	end = format.End(bd);
	tree = ast.New3(SEQ, 0, start, tree, end);
//err.str("FormatStmt end\n");
//ast.Dump(tree);
	return tree;
    }

    proc PrintStmt(): Ast
    {   var tok: TokenT;
	var bd, fmt, exp, ctr, rtf, tree: Ast;
	var fmtstr: @[]_byte;
	var fmtlen: _uint;

	bd = expr.GetLHS(0);
	tree = ParseFormat(bd);
	return tree;
    }

    const stmtlist:[]TokenT =
    { KTYPE, KVAR, KCONST, KIF, KWHILE, KLOOP, KDO, KFOR, KEXIT, KRET,
      KASM, KALIAS, KERROR, KCALL, KASSERT, KFORMAT, KPRINT, NONE };

    proc Statement(): Ast
    {   var tree, stree: Ast;
	var tok, tok2: TokenT;
	var s: Symb;

	tree = 0;
	tok = Token;
	if tok == GBEG then	// statement group
	{   tok = Next();
	    tree = ast.New(SEQ, 0);
	    while tok != GEND && tok != ENDF do
	    {   stree = Statement();
		if stree != 0 then
		   tree = ast.Child(tree, stree);
//err.str("Stmt:\n");
//ast.Dump(tree);
		tok = Token;
	    }
	    tok = lex.Expect(GEND);
	}
	else
	{   // Here is where no reserved words makes things tough.
	    // Need to distinguish statements starting with keywords
	    // from assignments and procedure calls that start with
	    // the same identifier.
	    tok = lex.Keyword(stmtlist);
	    s = symb.FindTop(lex.Ident);
	    tok2 = Next();
	    if tok > ID && s != 0 then	// both keyword and valid identifer
	    {   // Need to disambiguate
		if tok2
		is ASGN, INCR, DECR, ABEG, DOT, AT, COMMA then
		    tok = ID;	// assignment
		is PBEG then
		{   if s@.kind == PROC && (tok >= KRET && tok <= KWHILE) then
		    {   if feature.ambig then
			    lex.ErrorT(AMBIGUOUS, tok);
		    }
		    else
			tok = ID;   // call
		}
	    }
	    if tok
	    is ID then
	    {   if s != 0 then
		    tree = AssignOrCall(s);
		else if symb.IsAnon(lex.Ident) then
		    tree = Assign(0);
		else
		{   lex.ErrorI(BADSTMTI, lex.Ident);
		    tok = lex.Skip(stmtlist);
		}
	    }
	    is KTYPE then   tree = TypeDecl();
	    is KVAR then    tree = VarDecl();
	    is KCONST then  tree = ConstDecl();
	    is KIF then     tree = If();
	    is KFOR then    tree = For();
	    is KWHILE then  tree = While();
	    is KDO then     tree = Do();
	    is KLOOP then   tree = Loop();
	    is KEXIT then   tree = Exit();
	    is KRET then    tree = Return();
	    is KASM then    tree = Asm();
	    is KALIAS then  tree = Alias();
	    is KERROR then  tree = ErrorStmt();
	    is KCALL then
	    {   s = symb.FindTop(lex.Ident);
		tok2 = Next();
		tree = AssignOrCall(s);
	    }
	    is KASSERT then tree = Assert();
	    is KFORMAT then tree = FormatStmt();
	    is KPRINT  then tree = PrintStmt();
	    is SEMI then    {}		// ignore extra semicolons
	    else lex.ErrorT(BADSTMTT, tok);
	}
	return tree;
    }

    proc Procedure(): Ast
    {   var tree: Ast;
	var tok: TokenT;
	var t, mt: Type;
	var s, ms, fs, es, rs: Symb;
	var ft: Symb;

	tree = 0;
	mt = 0;
	ms = 0;
	tok = Token;
	if tok == PBEG then
	{   // method
	    tok = Next();
	    if tok == ID then
	    {   // method parameter
		ms = symb.New(VAR, lex.Ident, PRIVATE);
		ms@.linkage = FORMAL;
		t = type.unkntype;		// in case all goes wrong
		tok = Next();
		if tok == COLON then
		{   tok = Next();
		    if tok
		    is AT then
		    {   t = type.Ref();
			type.Final(t);
			mt = t@.base;
		    }
		    is ID then
		    {   s = type.Name();
			tok = Next();
			if s != 0 then
			{   t = s@.type;
			    mt = t;
			    if t != 0 && t@.kind == REF then
				mt = t@.base;
			}
			else lex.Error(NOTTYPE);
		    }
		    else lex.ErrorT(EXPECT, ID);
		    if mt != 0 && mt@.name == 0 then
			    lex.Error(BADMETHOD);
		    tok = Token;
		    if tok == COLON then
		    {	type.ParamAttributes(ms, t);
			tok = Token;
		    }
		}
		else lex.ErrorT(EXPECT, COLON);
		ms@.type = t;
	    }
	    else lex.ErrorT(EXPECT, ID);
	    tok = lex.Expect(PEND);
	}
	if tok == ID then
	{
	    if mt != 0 then
	    {   s = symb.FindPrivate(mt@.meths, lex.Ident);
		if s != 0 then
		{   if !s.forward then
			lex.ErrorI(DEFID, lex.Ident);
		}
		else
		{   s = symb.New(PROC, lex.Ident, PRIVATE);
		    s@.bound = true;
		    // Order doesn't matter, just put on top of list
		    s@.next = mt@.meths;
		    mt@.meths = s;
		}
	    }
	    else
	        s = symb.New(PROC, lex.Ident, VISIBLE);
	    tok = Next();
	    // FIXME: should save parmlist of forward proc and check
	    // against changes of types
	    fs = s@.parmlist;
	    ft = s@.retvlist;
	    s@.parmlist = 0;    // FIXME
	    type.DefProc(s, ms);
	    if s@.forward then
	    {   // Was forward proc, should check for parm/retv changes
		if !type.SameTypes(fs, s@.parmlist) then
		    lex.ErrorI(FORWPARM, s@.ident);
		if !type.SameTypes(ft, s@.retvlist) then
		    lex.ErrorI(FORWRETV, s@.ident);
	    }
	    tok = Token;
	    if tok == COLON then
	    {   type.ProcAttributes(s);
		tok = Token;
	    }
	    s@.forward = false;
	    if tok != SEMI then
	    {   symb.curproc = s;
		es = symb.Push(s@.parmlist, 0);	// make parameters visable
		if s@.retv then
		    rs = symb.Append(s@.retvlist);  // make return variables visable
		else
		    rs = 0;
		LoopLevel = 0;
		tree = Statement();
		if debug.symb.proc then
		    symb.Dump(1);
		symb.Pop();			// remove locals+parameters
		if es != 0 then es@.next = 0;   // restore parameter list end
		if rs != 0 then rs@.next = 0;   // same for return variables
		symb.curproc = 0;
	        t = s@.type;
		tree = ast.New1(PROC, t, tree);
		tree@.symb = s;
		if t != 0 && t@.kind == REF then
		{   tree@.type = t@.base;
		    tree@.width = Target.ptr.size;
		}
	    }
	    else
	    {   tok = Next();
		if s@.linkage
		is EXTERN, FIXED then
		{   tree = ast.New1(PROC, s@.type, 0);
		    tree@.symb = s;
		}
		else s@.forward = true;
	    }
	}
	else lex.ErrorT(EXPECT, ID);
	return tree;
    }

    /*
     * Import file handling
     * FIXME - move to a separate file?
     */

    alias lex.PathMax as PathMax;
    type SearchPathEntry:
    {   next:		@SearchPathEntry;
	path:		[]Char;
    };
    type Path: @SearchPathEntry;
    var  pathhead, pathtail:Path;

    proc SearchPathAdd(newpath: @[]Char, prepend: boolean): Path
    {   var np: Path;
	var len: _uint;

	len = zstr.len(newpath, PathMax);
	np = Path(sys.malloc(SearchPathEntry?size + len+1));
	zstr.copy(np@.path, newpath, len+1);
	if pathhead == 0 then
	{   np@.next = 0;
	    pathhead = np;
	    pathtail = np;
	}
	else
	{   if prepend then
	    {   np@.next = pathhead;
		pathhead = np;
	    }
	    else
	    {   np@.next = 0;
		pathtail@.next = np;
		pathtail = np;
	    }
	}
	return np;
    }

    proc SearchPathPrint()
    {   var pp: Path;

	err.str("Search path \"");
	pp = pathhead;
	while (pp != 0) do
	{   err.str(pp@.path);
	    err.chr(':');
	    pp = pp@.next;
	}
	err.str("\"\n");
    }

    proc FileFind(filename: @[]Char, istop: boolean): boolean
    {   var fd: sys.fildes;
	var pp: Path;
	var fp: @[]_byte;
	var i: _uint;
	var pathbuf: [PathMax]Char;

	if !istop then
	{   // search SearchPath trying to open file
	    pp = pathhead;
	    while pp != 0 do
	    {
		zstr.copy(pathbuf, pp@.path, PathMax);
		zstr.cat(pathbuf, "/", PathMax);
		i = zstr.len(pathbuf, PathMax);
		zstr.cat(pathbuf, filename, PathMax);
		fd = sys.open(pathbuf, sys.O_RDONLY, 0);
	      exit fd >= 0;
		pp = pp@.next;
	    }
	}
	else
	{   zstr.copy(pathbuf, filename, PathMax);
	    fd = sys.open(pathbuf, sys.O_RDONLY, 0);
	    i = zstr.rfind(pathbuf, '/', PathMax);
	    if i == PathMax then		// '/' not found
	    {   pp = SearchPathAdd(".", true);
		i = 0;
	    }
	    else
	    {   pathbuf[i] = 0;	// terminate
		pp = SearchPathAdd(pathbuf, true);
		i += 1;
	    }
	}
	if fd < 0 then
	    return false;
	fp = symb.NewImport(pathbuf[i:]);
	if debug.files then
	{   err.str("Open  file \"");
	    err.str(pathbuf);
	    err.str("\"\n");
	}
	if feature.mflag then
	{
	    msg.str(" \\\n ");
	    if pp != 0 && (pp@.path[0] != '.' || pp@.path[1] != 0) then
	    {   msg.str(pp@.path);
		msg.chr('/');
	    }
	    msg.str(pathbuf[i:]);
	}
	lex.FileOpen(fp, pp.path, fd);
	return true;
    }

    // Search to see if we have not imported this yet, if not, open it
    proc ImportCheck(filename: @[]Char): boolean
    {   var fullname: [256]Char;

	zstr.copy(fullname, filename, 256);
	zstr.cat(fullname, ".esl", 256);
	if symb.FindImport(fullname) then
	    return false;	// already imported
	if FileFind(fullname, false) then
	    return true;
	else
	{   lex.ErrorI(BADIMPORT, filename);
	    return false;
	}
    }

    proc ImportSub(filename: @[]Char): Ast
    {   var tree, stree: Ast;
	var tok, savetok: TokenT;
	var fs: Symb;

	tree = 0;
	if ImportCheck(filename) then
	{   savetok = Token;
	    fs = symb.NewFile(lex.f@.filepath, lex.f@.filename);
	    tok = Next();
	    tree = ast.New(SEQ, 0);
	    if symb.curpack != 0 then
	    {   while tok != ENDF do
		{   stree = PkgStmt();
		    if stree != 0 then
			tree = ast.Child(tree, stree);
		    tok = Token;
		}
	    }
	    else
	    {   while tok != ENDF do
		{   stree = ProgStmt();
		    if stree != 0 then
			tree = ast.Child(tree, stree);
		    tok = Token;
		}
	    }
	    tree = ast.New1(FILE, 0, tree);
	    tree@.symb = fs;
	    lex.FileClose();
	    symb.curfile = symb.curfile@.package;
	    Token = savetok;
	}
	return tree;
    }

    proc Import(): Ast
    {   var tree: Ast;
	var tok: TokenT;
	var s: Symb;

	tok = Token;
	tree = 0;
	if tok
	is ID then
	{   s = symb.New(STRING, lex.Ident, PRIVATE);
	    tok = Next();       // flush ID
	}
	is STR then
	{   tree = expr.String();
	    s = tree@.symb;
	}
	is PBEG then
	{   tok = Next();
	    s = expr.ConstString();
	    tok = lex.Expect(PEND);
	}
	if s != 0 then
	    tree = ImportSub(s@.ident);
	tok = lex.Expect(SEMI);
	return tree;
    }

    const packlist:[]TokenT =
    { KTYPE, KVAR, KCONST, KPROC, KALIAS, KPACKAGE, KIMPORT, KIF, KERROR, NONE };

    proc PkgStmt(): Ast
    {   var tree: Ast;
	var tok: TokenT;

	tree = 0;
	tok = lex.Keyword(packlist);
	if tok
	is KALIAS then  { tok = Next();  tree = Alias(); }
	is KTYPE then   { tok = Next();  tree = TypeDecl(); }
	is KVAR then    { tok = Next();  tree = VarDecl(); }
	is KCONST then  { tok = Next();  tree = ConstDecl(); }
	is KPROC then   { tok = Next();  tree = Procedure(); }
	is KPACKAGE then  { tok = Next();  tree = Package(); }
	is KIMPORT then   { tok = Next(); tree = Import(); }
	is KIF then     { tok = Next();  tree = CCIfStmt(PACKAGE); }
	is KERROR then  { tok = Next();  tree = ErrorStmt(); }
	else
	{   if tok == ID then
	    {   lex.Error(NOPACK);
		tok = lex.Skip(skiplist);
	    }
	    else
	    {   if tok != SEMI then
		    lex.ErrorT(BADSTMTT, tok);
		tok = Next();
	    }
	}
	return tree;
    }

    proc Package(): Ast
    {   var tree, stree: Ast;
	var tok: TokenT;
	var s: Symb;
	var pkgsave: Symb;

	tree = 0;
	tok = Token;
	if tok == ID then
	{   s = symb.FindThisLevel(lex.Ident);
	    if s == 0 then
		s = symb.New(PACK, lex.Ident, VISIBLE);
	    else if s@.kind != PACK then
		lex.ErrorI(DEFID, lex.Ident);
//	    s@.forward = true;
	    tok = Next();
	    if tok == GBEG then
	    {   tok = Next();
		pkgsave = symb.curpack;
		symb.curpack = s;
		tree = ast.New(SEQ, 0);
		symb.Push(s@.symblist, s);
		while tok != GEND && tok != ENDF do
		{   stree = PkgStmt();
		    if stree != 0 then
			tree = ast.Child(tree, stree);
		    tok = Token;
		}
		tree = ast.New1(PACKAGE, 0, tree);
		tree@.symb = s;
	    }
	    tok = lex.Expect(GEND);
	    s@.symblist = symb.Save();
	    if debug.symb.pack then
		symb.Dump(1);
	    symb.Pop();
	    symb.curpack = pkgsave;
	}
	return tree;
    }

    const proglist:[]TokenT =
    { KIMPORT, KALIAS, KPACKAGE, KTYPE, KVAR, KCONST, KPROC, KIF, KERROR, NONE };

    proc ProgStmt(): Ast
    {   var tree: ast.Ast;
	var tok: TokenT;

	tree = 0;
	tok = lex.Keyword(proglist);
	if tok
	is KIMPORT then   { tok = Next(); tree = Import(); }
	is KALIAS then    { tok = Next(); tree = Alias(); }
	is KPACKAGE then  { tok = Next(); tree = Package(); }
	is KTYPE then     { tok = Next(); tree = TypeDecl(); }
	is KVAR then      { tok = Next(); tree = VarDecl(); }
	is KCONST then    { tok = Next(); tree = ConstDecl(); }
	is KPROC then     { tok = Next(); tree = Procedure(); }
	is KIF then       { tok = Next(); tree = CCIfStmt(PROGRAM); }
	is KERROR then    { tok = Next(); tree = ErrorStmt(); }
	else
	{   if tok == SEMI then
		tok = Next();
	    else
	    {   if tok == ID then
		    lex.ErrorI(BADSTMTI, lex.Ident);
		else
		    lex.ErrorT(BADSTMTT, tok);
		tok = lex.Skip(skiplist);
	    }
	}
	return tree;
    }

    proc Program(file: @[]_byte): Ast
    {   var tree, stree: ast.Ast;
	var tok: TokenT;
	var s: Symb;

	s = symb.NewFile(lex.f@.filepath, lex.f@.filename);
	symb.curpack = 0;
	tree = ast.New(SEQ, 0);
	tok = Next();
	while tok != ENDF do
	{   stree = ProgStmt();
	    if stree != 0 then
		tree = ast.Child(tree, stree);
	    tok = Token;
	}
	tree = ast.New1(FILE, 0, tree);
	tree@.symb = s;
	return tree;
    }

}
// vim: ts=8 sw=4 noet nowrap

