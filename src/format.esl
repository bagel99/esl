/*
 * Routines to generate ASTs for to call run-time formatting routines.
 */

import fmtdef;	// definitions

package format
{
    const descid = "_desc";
    alias fmt.FmtSpec as FmtSpec;

    proc GetDigits(s: @[]_byte) (n: _uint, valu: _uint)
    {
	valu = 0;
	n = 0;
	while s[n] >= '0' && s[n] <= '9' do
	{   valu = valu * 10 + (s[n] - '0');
	    n += 1;
	}
    }

    proc ParseFmtSpec(s: @[]_byte) (i: _uint, spec: FmtSpec)
    {   var align: _byte = 0;
	var n: _uint;
	var valu: _uint;

	spec = fmt.FmtDefault;
	align = 0;
	if s[0] == '<' || s[0] == '>' || s[0] == '^' then
	{   spec.pad = ' ';
	    align = s[0];
	    i += 1;
	}
	elif s[1] == '<' || s[1] == '>'|| s[1] == '^' then
	{   spec.pad = s[0];
	    align = s[1];
	    i += 2;
	}
	if align
	is '<' then spec.align = LEFT;
	is '>' then spec.align = RIGHT;
	is '^' then spec.align = CENTER;
	else spec.align = NONE;
	if s[i] == '+' then
	{   spec.sign = true;
	    i += 1;
	}
	if s[i] == fmt.FPFX then
	{   spec.prefix = true;
	    i += 1;
	}
	if s[i] == '0' then
	{   spec.zeros = true;
	    i += 1;
	}
	n, valu = GetDigits(s[i:]);
	if n > 0 then
	{   spec.width = valu;
	    i += n;
	}
	if s[i] == '.' then
	{   i += 1;
	    n, valu = GetDigits(s[i:]);
	    if n > 0 then		// FIXME - if no precision digits?
	    {   spec.prec = valu;
		i += n;
	    }
	}
	if s[i]
	is 'd' then spec.ftype = DEC;
	is 'b' then spec.ftype = BIN;
	is 'o' then spec.ftype = OCT;
	is 'x' then spec.ftype = LHEX;
	is 'X' then spec.ftype = UHEX;
	is 'p' then spec.ftype = PTR;
	is 'c' then spec.ftype = CHR;
	is 's' then spec.ftype = STR;
	is 'f' then spec.ftype = FLT;
	is 'e' then spec.ftype = EXP;
	is 't' then spec.ftype = BOOL;
	is '%' then spec.ftype = CUST;
	else        { spec.ftype = NONE; i -= 1; }
	i += 1;
	return;
    }

    proc GetNextFmtSpec(s: @_memory)
	(nout: _uint,		// num of chars to output
	 ntot: _uint,		// num of chars scanned
	 nnam: _uint,		// length of custom name
	 spec: FmtSpec)
    {   var i, j, k, n: _uint;

	i = 0;
	k = 0;
	while s[i] != 0 do
	{   if s[i] == fmt.FBEG then
	    {   i += 1;
		if s[i] != fmt.FBEG then	// single FBEG
		{   n, spec = ParseFmtSpec(s[i:]);
		    i += n;
		    k += n+1;
		    if spec.ftype == CUST then
		    {
			j = i;
			while s[j] != fmt.FEND do
			    j += 1;
			nnam = j - i;
			i = j;
		    }
		    else
			nnam = 0;
		    if s[i] != fmt.FEND then
		    {
			// FIXME - what error message
		    }
		}
		nout = i - k - nnam;		// just output up to here
		ntot = i;
		return;
	    }
	    i += 1;
	}
	nout = i - k;		// just output up to here
	ntot = i;
	return;
    }

    var symblist: Symb = 0;
    var symbdesc: Symb = 0;
    var symbspec: Symb = 0;

    proc FindFormatSymbols(): boolean
    {   var pkg, s: Symb;

	pkg = symb.FindTop("fmt");
	if pkg == 0 || pkg@.kind != PACK then
	{   lex.Error(FMTNOPACK);
	    return false;
	}
	s = symb.FindLocal(pkg@.symblist, "Desc");
	if s == 0 then
	{   lex.ErrorS(COMPILER, "Unable to find 'Desc' in fmt package\n");
	    return false;
	}
	symbdesc = s;
	symblist = s@.type@.meths;
	s = symb.FindLocal(pkg@.symblist, "FmtSpec");
	if s == 0 then
	{   lex.ErrorS(COMPILER, "Unable to find 'FmtSpec' in fmt package\n");
	    return false;
	}
	symbspec = s;
	return true;
    }

    proc GetDescField(bd: Ast, name: @[]_byte) (tree: Ast, t: Type)
    {	var s: Symb;

	s = symb.FindLocal(symbdesc@.type@.list, name);
	t = s@.type;
	tree = expr.Load(bd);
	tree = ast.New1(OFFSET, type.MakeRef(t), tree);
	tree@.valu = s.addr;
    }

    proc Start(buf: Ast, len: _uint) (bd: Ast, tree: Ast)
    {   var s: Symb;
	var td, t: Type;
	var init, desc: Ast;

//err.str("Start len="); err.uint(len); err.nl();
if len <= 1 then len = 256;	// FIXME TEMP
	if !FindFormatSymbols() then return;
	td = symbdesc@.type;			// Desc
	// Generate desc
	s = symb.New(VAR, descid, DELAYED);
	tree = stmt.VarNew(s, td, 0);
	tree = ast.New1(SEQ, 0, tree);
	desc = ast.Var(s, type.MakeRef(td));
//err.str("Start desc=\n"); ast.Dump(desc);
	// Generate bd
	s = symb.New(VAR, "_bd", DELAYED);
	t = type.MakeRef(td);			// @Desc
	init = stmt.VarNew(s, t, 0);
	tree = ast.Child(tree, init);
	bd = ast.New(VAR, type.ForceRef(t));
	bd@.symb = s;
//err.str("Start bd=\n"); ast.Dump(bd);
	init = ast.New2(STORE, t, bd, ast.Adjust(desc, t));
	tree = ast.Child(tree, init);
	// Generate initialization of desc
	init, t = GetDescField(bd, "buf");
	init = ast.New2(STORE, t, init, buf);
	tree = ast.Child(tree, init);
	init, t = GetDescField(bd, "rem");
	init = ast.New2(STORE, t, init, ast.Const(t, len));
	tree = ast.Child(tree, init);
	init, t = GetDescField(bd, "len");
	init = ast.New2(STORE, t, init, ast.Const(t, len));
	tree = ast.Child(tree, init);
//err.str("start=\n"); ast.Dump(tree);
	return;
    }

    proc End(bd: Ast, isprint: boolean): Ast
    {	var tree, desc: Ast;
	var s: Symb;
	var name: @[]_byte;

	if isprint then name = "mayflush"; else name = "nulterm";
	if symblist == 0 && !FindFormatSymbols() then return 0;
	s = symb.FindPrivate(symblist, name);
	if s == 0 then
	{   lex.ErrorS(COMPILER, "No format end routine found\n");
	    return 0;
	}
	desc = expr.Load(bd);
	desc = ast.New1(BYREF, type.MakeRef(desc@.type), desc);
	tree = ast.New1(CALL, 0, desc);
	tree@.symb = s;
//err.str("end=\n"); ast.Dump(tree);
	return tree;
    }

    proc FindFmtRoutine(name: @[]_byte): Symb
    {	var s: Symb;

	if symblist == 0 && !FindFormatSymbols() then return 0;
//err.str("FindFmtRoutine name=\""); err.str(name); err.str("\"\n");
	s = symb.FindPrivate(symblist, name);
	if s == 0 then
	    lex.ErrorS(FMTNOFIND, name);
	return s;
    }

    proc GenCall(bd: Ast, exp: Ast, len: Ast, spec: _uint, fmtproc: Symb): Ast
    {	var desc, tree: Ast;

	desc = expr.Load(bd);
	desc = ast.New1(BYREF, type.MakeRef(desc@.type), desc);
	tree = ast.New3(CALL, 0, desc, exp, ast.ConstW(spec));
	if len != 0 then
	    tree = ast.Child(tree, len);
	tree@.symb = fmtproc;
	return tree;
    }

    proc String(bd: Ast, s: @[]_byte, w: _uint): Ast
    {	var str, tree: Ast;
	var fmtproc: Symb;

	fmtproc = FindFmtRoutine("string");
	if fmtproc == 0 then
	    return 0;
	str = expr.NewString(s, w, false);
	str = ast.New1(BYREF, type.MakeRef(str@.type), str);
	tree = GenCall(bd, str, 0, w, fmtproc);
	return tree;
    }

    proc GenConvert(bd: Ast, exp: Ast, len: Ast, spec: FmtSpec): Ast
    {	var tree: Ast;
	var namefmt: @[]_byte;
	var fmtproc: Symb;
	var fmttype: Type;
	const fmtnames: [fmt.FmtType] @[]_byte =
	{ [NONE] = 0,
	  [CHR]="chrfmt",
	  [STR]="strfmt",
	  [BOOL]="boolfmt",
	  [DEC]="udecfmt",
	  [BIN]="binfmt",
	  [OCT]="octfmt",
	  [LHEX]="hexfmt",
	  [UHEX]="hexfmt",
	  [PTR]="ptrfmt",
	  [FLT]="dfltfmt",
	  [EXP]="dexpfmt"
	};

	namefmt = fmtnames[spec.ftype];
	if spec.ftype == STR && len != 0 then
	    namefmt = "strnfmt";
	elif spec.ftype == DEC && exp@.type@.kind == SINT then
	    namefmt = "sdecfmt";
	fmtproc = FindFmtRoutine(namefmt);
	if fmtproc == 0 then
	    return 0;
	fmttype = fmtproc.parmlist.next.type;	// 2nd arg type
//err.str(namefmt); err.str(" => "); type.DumpT(fmttype, false); err.nl();
	exp = ast.Adjust(exp, fmttype);
	tree = GenCall(bd, exp, len, _uint(spec), fmtproc);
	return tree;
    }

    proc GenCustom(bd: Ast, exp: Ast, len: Ast, spec: FmtSpec,
		   nameptr: @[]_byte, namelen: _uint): Ast
    {	var tree: Ast;
	var fmtproc, s: Symb;
	var t: Type;
	var n: _uint;
	var parm: [3]Symb;
	var name: [32]_byte;

	if namelen > 28 then
	{   lex.Error(IDLONG);
	    return 0;
	}
	name[0:namelen] = nameptr[0:namelen];
	name[namelen:3] = "fmt";
	name[namelen+3] = 0;
	fmtproc = FindFmtRoutine(name);
	if fmtproc == 0 then
	    return 0;
	n = 0;
	s = fmtproc.parmlist;
	while s != 0 && n < 3 do
	{   parm[n] = s;
	    n += 1;
	    s = s@.next;
	}
	if s != 0 || n != 3 then // too many args or too few args
	{   lex.Error(FMTNOARGS);
	    return 0;
	}
	if (parm[0]@.type@.kind != REF &&
	    parm[0]@.type@.base != symbdesc@.type) ||
	    parm[2]@.type != symbspec@.type then
	{   lex.Error(FMTBADARG);
	    return 0;
	}
//err.str(name);  err.str(" => "); type.DumpT(parm[1]@.type, false); err.nl();
	exp = ast.Adjust(exp, parm[1]@.type);
	tree = GenCall(bd, exp, len, _uint(spec), fmtproc);
	return tree;
    }

    proc NextFormat(bd: Ast, fmtstr: @[]_byte, i: _uint, exp: Ast): _uint, Ast
    {	var nout: _uint;	// number of chars to be output
	var ntot: _uint;	// total chars scanned
	var nnam: _uint;	// length of custom format name
	var spec: fmt.FmtSpec;
	var fix, cvt, len: Ast;

	nout, ntot, nnam, spec = format.GetNextFmtSpec(fmtstr[i:]);
//err.str("NextFormat i="); err.uint(i); err.str(" nout="); err.uint(nout);
//err.str(" ntot="); err.uint(ntot); err.str(" nnam="); err.uint(nnam); err.nl();
	fix = 0;
	if nout > 0 then
	{   fix = format.String(bd, fmtstr[i:], nout);
	}
	if ntot > nout then	// there was a spec
	{   if exp != 0 then
	    {	len = 0;
		if spec.ftype == STR && spec.prefix then
		{   len = exp;
		    lex.Expect(COMMA);
		    exp = expr.Bool(0);
		}
		if exp != 0 then
		{
		    if nnam > 0 then
		    {
			cvt = format.GenCustom(bd, exp, len, spec,
					       fmtstr[i+ntot-nnam:], nnam);
		    }
		    else
			cvt = format.GenConvert(bd, exp, len, spec);
		    fix = ast.New2(SEQ, 0, fix, cvt);
		}
	    }
	    else lex.Error(FMTNOEXPR);
	}
	elif exp != 0 then lex.Error(FMTNOSPEC);
	return ntot+1, fix;
    }
}
