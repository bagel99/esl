// Copyright (c) 2009-2018, Brian G. Lucas.  See LICENSE file.

// Convert AST to LLVM assembly
import bout;
package llvm
{
    alias lex.StringRange as StringRange;
    const package_delimiter:Char = '_';
    const anon_prefix: []Char = "A.";
    const scon_prefix: []Char = "S.";
    type file: sys.fildes;
    var  f: bout.pBufIO;
    proc PType(t: Type);					// forward
    proc PName(s: Symb);					// forward
    proc PRetvType(tl: type.TypeList, extend: boolean);		// forward
    proc PParmTypes(s: Symb);					// forward
}

import llvmdb;

package llvm
{
    // These pointer types might be useful to other packages.
    var pbytetype: Type;
    var puinttype: [target.IntSizesMax]Type;
    type seqnoT: 0..0xFFFF;
    var Tseqno: seqnoT;
    var Pseqno: seqnoT = 0;
    var Lseqno: seqnoT = 0;
    var Aseqno: _uint16 = 0;
    var labthis: seqnoT;	// label sequence number of this basic block
    var loopexit: seqnoT;	// label sequence number for this loop exit
    type Intrinsics:
    (   MEMCPY, MEMMOVE, MEMSET, MEMCMP, ZLEN, BSWAP, BITREV,
	CLZ, CTZ, POP, SQRTF, SQRTI,
	ASSERT,   END
    );
    type IntrinsicUse:
    {   next:   @IntrinsicUse;
	type:   Type;
	size:   _uint;
    };
    type pIntrinsicUse: @IntrinsicUse;
    var UsedIntrinsic: [Intrinsics]pIntrinsicUse;

    proc UseIntrinsic(which: Intrinsics, size: _uint, t: Type)
    {   var piu: pIntrinsicUse;

	if size == 0 then size = 1;
//err.str("Use "); err.uint(_uint8(which));
//err.str(" size="); err.uint(size); err.nl();
	piu = UsedIntrinsic[which];
	while piu != 0 && piu@.size != size do
	    piu = piu@.next;
	if piu == 0 then    // new usage
	{   piu = pIntrinsicUse(sys.malloc(IntrinsicUse?size));
	    piu.size = size;
	    piu.type = t;
	    piu.next = UsedIntrinsic[which];
	    UsedIntrinsic[which] = piu;
	}
    }

    proc Print(fmt: @[]Char, anode: Ast);   // forward

    proc DeclareIntrinsics()
    {   var i: Intrinsics;
	var piu: pIntrinsicUse;
	var dummy: ast.AstNode(0);  // just to Print width/align of type

	dummy.type = 0;
	i = MEMCPY;
	while i < END do
	{   if UsedIntrinsic[i] != 0 then
	    {   piu = UsedIntrinsic[i];
		if i
		is MEMCPY then
		    Print("declare void @llvm.memcpy.p0i8.p0i8.%W(i8*, i8*, %W, i32, i1) nounwind\n", dummy);
		is MEMMOVE then
		    Print("declare void @llvm.memmove.p0i8.p0i8.%W(i8*, i8*, %W, i32, i1) nounwind\n", dummy);
		is MEMSET then
		    Print("declare void @llvm.memset.p0i8.%W(i8*, i8, %W, i32, i1) nounwind\n", dummy);
		is BSWAP then
		{   do
		    {   dummy.type = piu@.type;
			Print("declare %K @llvm.bswap.%K(%K)\n", dummy);
			piu = piu@.next;
		    } while piu != 0;
		}
		is BITREV then
		{   do
		    {   dummy.type = piu@.type;
			Print("declare %K @llvm.bitreverse.%K(%K)\n", dummy);
			piu = piu@.next;
		    } while piu != 0;
		}
		is CLZ then
		{   do
		    {   dummy.type = piu@.type;
			Print("declare %K @llvm.ctlz.%K(%K, i1)\n", dummy);
			piu = piu@.next;
		    } while piu != 0;
		}
		is CTZ then
		{   do
		    {   dummy.type = piu@.type;
			Print("declare %K @llvm.cttz.%K(%K, i1)\n", dummy);
			piu = piu@.next;
		    } while piu != 0;
		}
		is POP then
		{   do
		    {   dummy.type = piu@.type;
			Print("declare %K @llvm.ctpop.%K(%K)\n", dummy);
			piu = piu@.next;
		    } while piu != 0;
		}
		is MEMCMP then
		{   do
		    {   dummy.type = piu@.type;
			Print("declare i1 @memcmp%*B(%K, %K, %W)\n", dummy);
			piu = piu@.next;
		    } while piu != 0;
		}
		is ZLEN then
		{   do
		    {   dummy.type = piu@.type;
			Print("declare %W @memlen%*A(%K)\n", dummy);
			piu = piu@.next;
		    } while piu != 0;
		}
		is SQRTF then
		{   do
		    {   dummy.type = piu@.type;
			Print("declare %K @llvm.sqrt.%K(%K)\n", dummy);
			piu = piu@.next;
		    } while piu != 0;
		}
		is SQRTI then
		{   do
		    {   dummy.type = piu@.type;
			Print("declare %K @sqrti%B(%K)\n", dummy);
			piu = piu@.next;
		    } while piu != 0;
		}
		is ASSERT then
		    Print("declare void @_assert(%W, [0 x i8]*, %W) noreturn\n",
			  dummy);
	    }
	    i += 1;
	}
    }

    proc GenSub(node: Ast): boolean;	// forward
    proc ProcParmTypes(s: Symb);	// forward

    proc PEndLine(node: Ast)
    {
	if feature.gflag then llvmdb.PLine(node@.lineno);
	f.nl();
    }

    proc PPkgPfx(s: Symb)
    {   if s@.package != 0 then PPkgPfx(s@.package);    // recursive
	f.str(s@.ident);
	f.chr(package_delimiter);
    }

    proc PTypeName(t: Type)
    {   var s: Symb;

	f.str("%");
	s = t@.name;
	if s != 0 then
	{   if s@.package != 0 then
		PPkgPfx(s@.package);
	    f.str(s@.ident);
	}
	else
	{   f.str(anon_prefix);
	    if t@.antag == 0 then
	    {   Aseqno += 1;
		t@.antag = Aseqno;
	    }
	    f.uint16(t@.antag);
	}
    }

    proc PRecordType(t: Type)
    {   var s: Symb;

	if t@.noepad || t@.nofpad then
	    f.chr('<');
	f.str("{");
	s = t@.list;
	while s != 0 do
	{   PType(s@.type);
	    s = s@.next;
	  exit s == 0;
	    f.str(", ");
	}
	f.str("}");
	if t@.noepad || t@.nofpad then
	    f.chr('>');
    }

    proc PWidth(t: Type)
    {
	if t != 0 then
	    f.uint(t@.width/target.ByteSize);
    }

    proc PAlign(t: Type)
    {
	if t != 0 then
	    f.uint(t@.align/target.ByteSize);
    }

    // FIXME - make a feature switch?
    const usewidth = false;     // use type width otherwise type size
    const usebitsize = false;   // use size as is
    const usebytesize = true;   // use next larger byte size
				// otherwise use next larger natural size
    proc PScalarSize(t: Type)
    {   var size: type.BitSize;

	if usewidth then
	    size = t@.width;
	else
	    size = t@.size;
	if !usebitsize then
	{   if usebytesize then
		size = ((size+7)/8) * 8;
	    else
		size = target.isize(size);
	}
	f.chr('i'); f.uint(size);
    }

    proc PType(t: Type)
    {   var size: type.BitSize;

	if t != 0 then
	{   if t@.kind
	    is ENUM, UINT, SINT then PScalarSize(t);
	    is FLOAT then
	    {
		if t@.size
		is 32 then f.str("float");
		is 64 then f.str("double");
	    }
	    is REF then
	    {   PType(t@.base);
		f.chr('*');
	    }
	    is RECORD then
	    {   // LLVM doesn't do bit pack records, handle as integers
		if t@.packed then PScalarSize(t);
		else
		{   if t@.printed then
			PTypeName(t);
		    else
			PRecordType(t);
		}
	    }
	    is ARRAY then
	    {   // LLVM doesn't do bit pack arrays, handle as integers
		if t@.packed then PScalarSize(t);
		else
		{   f.chr('[');
		    f.uint32(t.Span());
		    f.str(" x ");
		    PType(t@.base);
		    f.chr(']');
		}
	    }
	    is REFPROC then
	    {   PRetvType(t@.list@.retvlist, false);
		f.chr(' ');
		PParmTypes(t@.list@.parmlist);
		f.chr('*');
	    }
	}
    }

    proc PDerefType(t: Type)
    {
	if t != 0 then
	{   if t@.kind
	    is REF then
		PType(t@.base);
	    else
		lex.ErrorS(COMPILER, "Illegal PDerefType");
	}
    }

    proc PExtend(t: Type)
    {
	if t != 0 then
	{   if t@.kind
	    is ENUM, UINT, SINT then
	    {   var size: type.BitSize;
		size = target.isize(t@.size);
		if size < type.wordtype@.size then
		{
		    if t@.kind == SINT then
			f.str(" signext");
		    else
			f.str(" zeroext");
		}
	    }
	}
    }

    proc PRetvType(tl: type.TypeList, extend: boolean)
    {   var t: Type;

	if tl != 0 then
	{   if  tl@.next != 0 then		// has multiple returned values
	    {   f.str(" { ");
		loop
		{   PType(tl@.type);
		    tl = tl@.next;
		  exit tl == 0;
		    f.str(", ");
		}
		f.str(" }");
	    }
	    else				// single returned value
	    {   t = tl@.type;
		if extend then PExtend(t);
		f.chr(' ');
		PType(t);
	    }
	}
	else					// has no returned value
	    f.str(" void");
    }

    proc PParmTypes(s: Symb)
    {
	f.chr('(');
	while s != 0 do
	{   PType(s@.type);
	    s = s@.next;
	  exit s == 0;
	    f.str(", ");
	}
	f.chr(')');
    }

    proc ConstantRef(node: Ast)
    {   var v: type.Valu;

	v = node@.valu;
	if v == 0 then
	    f.str("null");
	else
	{   f.str("inttoptr(");
	    PType(type.wordtype);
	    f.chr(' ');
	    f.uint64(v);
	    f.str(" to ");
	    PType(node@.type);
	    f.chr(')');
	}
    }

    proc NodeType(node: Ast)
    {
	if node@.type@.kind
	is UTYPE then
	    f.str("void");
	is FLOAT, REF, ARRAY, RECORD, REFPROC then
	    PType(node@.type);
	else
	{
//if node@.width != node@.type.width then
//{   err.str("Node width disagreement\n"); ast.Dump(node); }
	    f.str("i"); f.uint(node@.width);
	}
    }

    proc PMethod(s: Symb)
    {   var bs: Symb;
	var bt: Type;

	bt = s@.parmlist@.type;
	if bt@.kind == REF then bt = bt@.base;
	bs = bt@.name;
	if bs@.package != 0 then
	    PPkgPfx(bs@.package);
	f.str(bs@.ident);
	f.chr(package_delimiter);
    }

    proc PName(s: Symb)
    {
	if s@.linkage
	is FORMAL, LOCAL then
	{   f.chr('%');
	    f.str(s@.ident);
	}
	is NORMAL, INLINE then
	{   f.chr('@');
	    if s@.kind == PROC && s@.bound then
		PMethod(s);
	    else
	    {   if s@.package != 0 then
		    PPkgPfx(s@.package);
	    }
	    f.str(s@.ident);
	}
	is GLOBAL, WEAK, EXTERN then
	{   f.chr('@');
            if s@.altsymb != 0 then
                f.str(s@.altsymb@.ident);
	    else
	    {   if s@.kind == PROC && s@.bound then
		    PMethod(s);
		f.str(s@.ident);
	    }
	}
	is FIXED then
	{   f.str("inttoptr(");
	    PType(type.wordtype);
	    f.chr(' ');
	    f.uint64(s@.xaddr);
	    f.str(" to ");
	    if s@.kind == PROC then
	    {   PRetvType(s@.retvlist, true);
		PParmTypes(s@.parmlist);
	    }
	    else
		PType(s@.type);
	    f.str("*)");
	}
    }

    proc PTempName(n: seqnoT)
    {
	f.chr('%');
	f.uint(n-1);
    }

    proc NodeName(node: Ast)
    {   var s: Symb;

	s = node@.symb;
	if s != 0 then
	    PName(s);
	else
	    f.str("__NoName__");
    }

    proc PFloat(node: Ast)
    {   var tmp, ten: _float64;
	var scl: _int;
	var hex: _uint64;

	tmp = _float64*(_int64(node@.valu));
	scl = node@.fscale;
	if scl > 0 then
	{   ten = 1.0;
	    do
	    {   ten = ten * 10.0;
		scl -= 1;
	    } while scl != 0;
	    tmp = tmp / ten;
	}
	elif scl < 0 then
	{   do
	    {   tmp = tmp * 10.0;
		scl += 1;
	    } while scl != 0;
	}
	hex = _uint64(tmp);
	if node@.type@.size == 32 then
	{   if hex & 0x1000_0000 != 0 then
		hex += 0x2000_0000;
	    hex = hex & 0xFFFF_FFFF_E000_0000;
	}
        f.str("0x");
        f.hex64(hex);
    }

    proc NodeDst(node: Ast)
    {
	if node@.op
	is CONST then
	{   if node@.type@.kind != REF then
	        lex.ErrorS(COMPILER, "Assignment to constant");
	    ConstantRef(node);
	}
	is VAR, DCLVAR then NodeName(node);
	else PTempName(node@.seqno);
    }

    proc NodeSrc(node: Ast)
    {
	if node@.op
	is CONST then
	{   if node@.type@.kind
	    is ENUM, UINT then f.uint64(node@.valu);
	    is SINT then       f.int64(_int64(node@.valu));
	    is REF, REFPROC then ConstantRef(node);
	    is ARRAY, RECORD then f.uint64(node@.valu);	    // packed?
	}
	is FCON then PFloat(node);
	is SCON, CLIST then
	{   f.chr('@');
	    f.str(scon_prefix);
	    f.uint32(_uint32(node@.valu));
	}
	is VAR then NodeName(node);
	else        PTempName(node@.seqno);
    }

    proc Print(fmt: @[]Char, anode: Ast)
    {   var i: _uint;
	var c: Char;
	var n: ast.NSubNodes;
	var node: Ast;
	var t: Type;

	i = 0;
	loop
	{   c = fmt[i];
	  exit c == 0;
	    if c == '%' then
	    {   i += 1;  c = fmt[i];
		node = anode;
		if c
		is '0'..'9' then
		{   n = 0;
		    loop
		    {   n = (n * 10) + (c - '0');
			i += 1;  c = fmt[i];
		      exit c < '0' || c > '9';
		    }
		    node = anode@.child[n];
		}
		t = node@.type;
		while c == '*' do
		{   if t != 0 then t = t@.base;
		    i += 1;  c = fmt[i];
		}
		if c
		is 'K' then PType(t);
		is 'A' then PAlign(t);
		is 'B' then PWidth(t);
		is 'R' then PDerefType(t);
		is 'T' then NodeType(node);
		is 'I' then NodeName(node);
		is 'N' then NodeSrc(node);
		is 'D' then NodeDst(node);
		is 'W' then PType(type.wordtype);	// target word type
		is 'S' then // string name
		{   f.chr('@');
		    f.str(scon_prefix);
		    f.uint32(_uint32(node@.valu));
		}
		is '%' then f.chr(c);
	    }
	    else
		f.chr(c);
	    i += 1;
	}
    }

    proc PRetValName(n: ast.NSubNodes)
    {
	f.str("%rv.");
	f.uint(n);
    }

    proc Alignment(t: Type)
    {   var n: type.BitSize;

	n = t@.align;
	if n >= target.ByteSize then
	{   f.str(", align ");
	    f.uint(n / target.ByteSize);
	}
    }

    proc Section(s: Symb, comma: boolean)
    {
	if s != 0 then
	{
	    if comma then
	    {
		f.str(",");
	    }
	    f.str(" section \"");
	    f.str(s@.ident);
	    f.str("\"");
	}
    }

    proc DclType(t: Type)
    {   var s: Symb;
	var size: type.BitSize;

	if t != 0 && !t@.printed then
	{   if t@.kind
	    is REF, ARRAY then DclType(t@.base);
	    is REFPROC then
	    {   // make sure formals are all recursively defined
		s = t@.list@.parmlist;
		while s != 0 do
		{   DclType(s@.type);
		    s = s@.next;
		}
	    }
	    is RECORD then
	    {   t@.printed = true;
		// make sure all types are recursively defined
		s = t@.list;
		while s != 0 do
		{   DclType(s@.type);
		    s = s@.next;
		}
		// now deal with the record
		PTypeName(t);
		f.str(" = type ");
		if t@.packed then
		{   // LLVM doesn't do bit pack records, handle as integers
		    size = target.isize(t@.size);
		    f.str("i"); f.uint(size);
		}
		else
		    PRecordType(t);
		f.nl();
	    }
	}
    }

    proc DclProc(node: Ast, isdefine: boolean)
    {   var s, ps: Symb;

	ps = node@.symb;
	if isdefine then f.str("define"); else f.str("declare");
	if ps@.linkage
	is NORMAL, INLINE then f.str(" internal");
	is WEAK then f.str(" weak");
	is EXTERN then f.str(" external");
	PRetvType(ps@.retvlist, true);
	Print(" %I(", node);
	s = ps@.parmlist;
	while s != 0 do
	{   PType(s@.type);
	    PExtend(s@.type);
	    if isdefine then
	    {   f.str(" %");
		f.str(s@.ident);
		f.chr('$');
	    }
	    s = s@.next;
	  exit s == 0;
	    f.str(", ");
	}
	f.str(")");
    }

    proc PString(s:@[]_byte, n:0..lex.StringMax, prefix: boolean)
    {   var i: 0..lex.StringMax;
	var c: Char;

	if prefix then f.chr('c');
	f.chr('"');
	i = 0;
	while i < n do
	{   c = s[i];
	    if c < ' ' || c >= 0x7F || c == '"' || c == '\\' then
	    {   f.chr('\\');
		f.hex8(c);
	    }
	    else
		f.chr(c);
	    i += 1;
	}
	f.chr('"');
    }

    proc DefaultInitializer(t: Type)
    {
	if t@.kind
	is ENUM, UINT, SINT then
	    f.uint(0);
	is FLOAT then
	    f.str("0.0");
	is REF then
	    f.str("zeroinitializer");   // FIXME: "null" ?
	is ARRAY, RECORD then
	    f.str("zeroinitializer");
	is REFPROC then
	    f.str("null");
    }

    proc Constant(node: Ast)
    {   var i: ast.NSubNodes;
	var t: Type;
	var n: StringRange;

	t = node@.type;
	if t != 0 then
	{   if node.op
	    is CONST then
	    {   if t@.kind
		is REF, REFPROC then ConstantRef(node);
		is SINT then f.int64(_int64(node@.valu));
		is ARRAY, RECORD then
		{   if t.packed then
			f.uint64(node@.valu);
		    else
			f.str("zeroinitializer");
		}
		else         f.uint64(node@.valu);
	    }
	    is FCON then PFloat(node);
	    is SCON then
	    {   if t@.flex then
		    n = StringRange(node@.type.Span());
		else
		    n = StringRange(t.Span());
		PString(node@.symb@.ident, n, true);
	    }
	    is CLIST then
	    {   if t@.kind
		is RECORD then
		{   if t@.noepad || t@.nofpad then
			f.chr('<');
		    f.str("{ ");
		    i = 0;
		    loop
		    {
		        PType(node@.child[i]@.type);
			f.str(" ");
			Constant(node@.child[i]);
			i += 1;
		      exit i >= node@.num;
			f.str(", ");
		    }
		    f.str(" }");
		    if t@.noepad || t@.nofpad then
			f.chr('>');
		}
		is ARRAY then
		{   f.str("[ ");
		    i = 0;
		    loop
		    {
		        PType(node@.child[i]@.type);
			f.str(" ");
			Constant(node@.child[i]);
			i += 1;
		      exit i >= node@.num;
			f.str(", ");
		    }
		    f.str(" ]");
		}
	    }
	    is BYREF then
	    {   if t@.base@.flex then
		    Print("bitcast( %T* ", node@.child[0]);
		if feature.syntax37 then
		    Print("getelementptr( %T, %T* %N ) ", node@.child[0]);
		else
		    Print("getelementptr( %T* %N ) ", node@.child[0]);
		if t@.base@.flex then
		    Print(" to %T )", node);
	    }
	    is CAST then
	    {   if t@.base@.flex then
		    Print("bitcast( %T ", node@.child[0]);
		if feature.syntax37 then
		    Print("getelementptr( %R, %T %N ) ", node@.child[0]);
		else
		    Print("getelementptr( %T %N ) ", node@.child[0]);
		if t@.base@.flex then
		    Print(" to %T )", node);
	    }
	    is VAR then    // reference another const by name
	    {   if t@.kind == REFPROC then
		{
		    PName(node@.symb);
		}
		else
		{   if t@.base@.flex then
			Print("bitcast( %T ", node);
		    if feature.syntax37 then
			Print("getelementptr( %R, %T %N ) ", node);
		    else
			Print("getelementptr( %T %N ) ", node);
		    if t@.base@.flex then
			Print(" to %T )", node);
		}
	    }
	}
    }

    proc DclVar(node: Ast)
    {   var s: Symb;
        var rhs: Ast;

	s = node@.symb;
	rhs = node@.child[0];
	if s != 0 then
	{   DclType(s@.type);
	    if s@.linkage
	    is LOCAL then
	    {   Print("\t%I = alloca %K", node);
		if node@.type@.kind <= REF then // scalar
		{   if rhs == 0 && feature.zerol then
			rhs = ast.Const(node@.type, 0);
		    if rhs != 0 then     // initialized local
		    {   f.nl();
			// FIXME: Print("store %T %N", rhs);
			GenSub(rhs);
			f.str("\tstore ");
			NodeType(rhs); f.chr(' ');
			NodeSrc(rhs);
			Print(", %K* %D", node);
		    }
		}
		elif rhs != 0 then
		    lex.ErrorS(NOTIMPL, "initialized local composites");
	    }
	    is NORMAL then
	    {   Print("%I = internal global %K ", node);
		if rhs != 0 then
		    Constant(rhs);
		else
		    DefaultInitializer(node@.type);
		Alignment(s@.type);
		Section(s@.section, true);
	    }
	    is GLOBAL then
	    {   Print("%I = global %K ", node);
		if rhs != 0 then
		    Constant(rhs);
		else
		    DefaultInitializer(node@.type);
		Alignment(s@.type);
		Section(s@.section, true);
	    }
	    is WEAK then
	    {   Print("%I = weak global %K ", node);
		if rhs != 0 then
		    Constant(rhs);
		else
		    DefaultInitializer(node@.type);
		Alignment(s@.type);
		Section(s@.section, true);
	    }
	    is EXTERN then
		Print("%I = external global %K", node);
	    if feature.gflag then
		llvmdb.DefVar(s);
	    else
		f.nl();
	}
    }

    proc ConstScan(node: Ast);		// forward

    proc DclString(node: Ast)
    {   var n: StringRange;

	if node@.seqno != 0 then return;   // already declared
	node@.seqno = 1;    // mark declared
	Print("%S = private unnamed_addr constant %K ", node);
	if node@.type != 0 then
	    n = StringRange(node@.type.Span());
	else    // no type
	{
	    n = zstr.len(node@.symb@.ident, lex.StringMax);
	}
	PString(node@.symb@.ident, n, true);
	f.nl();
    }

    proc DclAggregate(node: Ast)
    {
	ConstScan(node);
	Print("%S = internal constant %K ", node);
	Constant(node);
	// FIXME: Alignment(node@.type)?
	f.nl();
    }

    proc ConstByRef(node: Ast): boolean
    {
	if node@.op
	is SCON then
	{   DclString(node);
	    return true;
	}
	is CLIST then
	{   DclAggregate(node);
	    return true;
	}
	return false;
    }

    // Look at nodes under a constant to see if there are any
    // string constants by reference.  If so, declare the string.
    proc ConstScan(node: Ast)
    {   var i: ast.NSubNodes;

	if node@.op == BYREF && ConstByRef(node@.child[0]) then
	    return;
	else
	{   i = 0;
	    while i < node@.num do
	    {   ConstScan(node@.child[i]);
		i += 1;
	    }
	}
    }

    proc DclCon(node: Ast)
    {   var s: Symb;

	s = node@.symb;
	if s != 0 then
	{   DclType(s@.type);
	    ConstScan(node);
	    if s@.linkage
	    is NORMAL then Print("%I = internal constant %K ", node);
	    is GLOBAL then Print("%I = constant %K ", node);
	    Constant(node@.child[0]);
	    Alignment(s@.type);
	    Section(s@.section, true);
	}
	f.nl();
    }

    proc PLabel(n: seqnoT)
    {
	f.str("L.");
	f.uint(n);
    }

    proc Label(n: seqnoT)
    {
	PLabel(n);
	f.str(":\n");
	labthis = n;
    }

    proc RefLabel(n: seqnoT)
    {
	f.str("label %");
	PLabel(n);
    }

    proc Branch(n: seqnoT)
    {
	f.str("\tbr ");
	RefLabel(n);
	f.nl();
    }

    proc BranchConditional(node: Ast, ntrue: seqnoT, nfalse: seqnoT)
    {
	f.str("\tbr i1 ");
	NodeSrc(node);
	f.str(", ");
	RefLabel(ntrue);
	f.str(", ");
	RefLabel(nfalse);
	PEndLine(node);
    }

    proc Assert(node: Ast)
    {
	GenSub(node@.child[0]);
	Print("\tcall void @_assert(%W ", node);
	f.uint64(node@.valu);
	Print(", [0 x i8]* %N, %W ", node@.child[0]);
	f.str("");
	f.uint16(node@.lineno);
	f.str(")\n");
	UseIntrinsic(ASSERT, 0, 0);
    }

    proc If(node: Ast): boolean
    {   var labend, labtrue, labfalse: seqnoT;
	var term: boolean;

	GenSub(node@.child[0]);
	labend = Lseqno;  Lseqno += 1;
	labtrue = Lseqno;  Lseqno += 1;
	if node@.child[2] != 0 then
	{   labfalse = Lseqno;  Lseqno += 1;
	}
	else
	    labfalse = labend;
	BranchConditional(node@.child[0], labtrue, labfalse);
	Label(labtrue);
	term = GenSub(node@.child[1]);
	if !term then Branch(labend);
	if node@.child[2] != 0 then
	{   Label(labfalse);
	    term = GenSub(node@.child[2]);
	    if !term then Branch(labend);
	}
	Label(labend);
	return false;
    }

    proc Select(node: Ast): boolean
    {	var i, j: ast.NSubNodes;
	var isnode, selnode: Ast;
	var labend, labelse: seqnoT;
	var lo, hi: Valu;

	// LLVM wants selector to be register width
	node@.child[0] = ast.ExtendT(node@.child[0], type.wordtype);
	GenSub(node@.child[0]);		// the selector value
	labelse = Lseqno;  Lseqno += 1;
	labend = Lseqno;  Lseqno += 1;
	Print("\tswitch %T %N, ", node@.child[0]);
	RefLabel(labelse);
	f.str(" [\n");
	// first pass through all the "is" nodes to generate labels
	i = 1;
	while i < node@.num -1 do
	{   isnode = node@.child[i];
	    if isnode@.op == IS then
	    {   isnode@.seqno = Lseqno;  Lseqno += 1;
		j = 0;
		while j < isnode@.num -1 do
		{   selnode = isnode@.child[j];
		    lo = 0; hi = 0;	// in case of internal error
		    if selnode@.op
		    is CONST then { lo = selnode@.valu; hi = lo; }
		    is CRANGE then
		    {   if selnode@.child[0]@.op == CONST &&
			   selnode@.child[1]@.op == CONST then
			{   lo = selnode@.child[0]@.valu;
			    hi = selnode@.child[1]@.valu;
			}
		    }
		    while lo <= hi do
		    {   Print("\t\t%0T ", node);
			f.uint32(_uint32(lo));
			f.str(", ");
			RefLabel(isnode@.seqno);
			f.nl();
			lo += 1;
		    }
		    j += 1;
		}
	    }
	    i += 1;
	}
	f.str("\t]\n");
	// second pass through all the "is" nodes to generate the code
	i = 1;
	while i < node@.num -1 do
	{   isnode = node@.child[i];
	    Label(isnode@.seqno);
	    if !GenSub(isnode@.child[isnode@.num-1]) then
		Branch(labend);
	    i += 1;
	}
	Label(labelse);
	// now the else node
	if !GenSub(node@.child[node@.num-1]) then
	    Branch(labend);
	Label(labend);
	return false;
    }

    proc Loop(node: Ast): boolean
    {   var loopcont, saveexit: seqnoT;

	saveexit = loopexit;
	loopcont = Lseqno;  Lseqno += 1;
	loopexit = Lseqno;  Lseqno += 1;
	Branch(loopcont);		// start a new basic block
	Label(loopcont);
	GenSub(node@.child[0]);
	Branch(loopcont);		// end of loop, continue
	Label(loopexit);		// loop exit
	loopexit = saveexit;
	return false;
    }

    proc Exit(node: Ast): boolean
    {   var labtrue, labfalse: seqnoT;
	var term: boolean;

	labfalse = Lseqno;  Lseqno += 1;
	GenSub(node@.child[0]);
	if (node@.child[1] != 0) then	// has "with" clause
	{   labtrue = Lseqno;  Lseqno += 1;
	    BranchConditional(node@.child[0], labtrue, labfalse);
	    Label(labtrue);		// exit with ...
	    term = GenSub(node@.child[1]);
	    if !term then
		Branch(loopexit);	// exit loop
	}
	else				// no "with" clause
	    BranchConditional(node@.child[0], loopexit, labfalse);
	Label(labfalse);		// come here if continuing
	return false;
    }

    proc Conditional(node: Ast, isand: boolean): boolean
    {   var lablhs, labrhs, labend: seqnoT;

	labrhs = Lseqno;  Lseqno += 1;
	labend = Lseqno;  Lseqno += 1;
	GenSub(node@.child[0]);
	if isand then
	    BranchConditional(node@.child[0], labrhs, labend);
	else
	    BranchConditional(node@.child[0], labend, labrhs);
	lablhs = labthis;	// left hand side final basic block
	Label(labrhs);
	GenSub(node@.child[1]);
	labrhs = labthis;	// right hand side final basic block
	Branch(labend);
	Label(labend);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = phi i1 [ ", node);
	if isand then f.str("false"); else f.str("true");
	f.str(", %");
	PLabel(lablhs);
	f.str(" ], [ ");
	PTempName(node@.child[1]@.seqno);
	f.str(", %");
	PLabel(labrhs);
	f.str(" ]\n");
	return false;
    }

    proc Copy(node: Ast, ismove: boolean)
    {
	// LLVM wants i8* types
	node@.child[0] = ast.Cast(node@.child[0], pbytetype);
	node@.child[1] = ast.Cast(node@.child[1], pbytetype);
	GenSub(node@.child[0]);
	GenSub(node@.child[1]);
	// LLVM wants count to be register width
	node@.child[2] = ast.ExtendT(node@.child[2], type.wordtype);
	GenSub(node@.child[2]);
	// FIXME: need to check for potential overlap and use memmove if necessary
	// FIXME: find alignment, here or during parsing?
	if ismove then
	{   Print(
	    "\tcall void @llvm.memmove.p0i8.p0i8.%2T(i8* %0N, i8* %1N, %2T %2N, i32 %3N, i1 0)\n", node);
	    UseIntrinsic(MEMMOVE, 1, 0);     // FIXME - alignment
	}
	else
	{   Print(
	    "\tcall void @llvm.memcpy.p0i8.p0i8.%2T(i8* %0N, i8* %1N, %2T %2N, i32 %3N, i1 0)\n", node);
	    UseIntrinsic(MEMCPY, 1, 0);     // FIXME - alignment
	}
    }

    proc Set(node: Ast)
    {
	// LLVM wants i8* type
	node@.child[0] = ast.Cast(node@.child[0], pbytetype);
	GenSub(node@.child[0]);
	GenSub(node@.child[1]);
	// LLVM wants count to be register width
	node@.child[2] = ast.ExtendT(node@.child[2], type.wordtype);
	GenSub(node@.child[2]);
	Print(
	   "\tcall void @llvm.memset.p0i8.%W(i8* %0N, %1T %1N, %2T %2N, i32 %3N, i1 0)\n", node);
	UseIntrinsic(MEMSET, 1, 0);     // FIXME - alignment
    }

    // Array compares can be done in "chunks".
    // If the total size is known then
    //   The total size must be evenly divided by the chunk size
    // else
    //   The chunk size must be evenly divided by the element size.
    // If the alignment is known then
    //   The chunk size must not be larger than the alignment.
    proc GetChunkSize(totsize: _uint, elsize: _uint, align: _uint):
		      0..target.IntSizesMax
    {   var is, ia: 0..target.IntSizesMax;

	ia = 0;
	if align > 0 then
	    ia = target.iindex(align);
	is = 0;
	if totsize > 0 then
	{   is = target.iindex(totsize);
	    // make sure chunk size evenly divides total size
	    while is > 0 &&
		  totsize % (Target.isizes[is].size/target.ByteSize) != 0 do
		is -= 1;
	}
	else
	{   is = target.iindex(elsize);
	    // make sure element size evenly divides chunk size
	    while is > 0 &&
		  (Target.isizes[is].size/target.ByteSize) % elsize != 0 do
		is -= 1;
	}
	return _min(ia, is);
    }

    // This horrible mess would be straighforward if only LLVM would support
    // an instrinsic llvm.memcmp().
    proc ArrayCompare(node: Ast): boolean
    {   var length: _uint;      // number of elements, 0 => variable
        var align: _uint;       // alignment in bytes
        var elsize: _uint;      // size of element in bytes
        var size: _uint;	//
	var i: 0..target.IntSizesMax;

	elsize = node@.child[0]@.type@.base@.base@.width/target.ByteSize;
	align = _uint(node@.child[3]@.valu);
	length = 0;	// 0 means variable
	if node@.child[2]@.op == CONST then
	    length = _uint(node@.child[2]@.valu) * elsize;
	// find the largest target chunk we can use
	i = GetChunkSize(length, elsize, align);
// err.str("elsize="); err.uint(elsize); err.str(" length="); err.uint(length);
// err.str(" align="); err.uint(align); err.str(" chunk="); err.uint(i);
	size = Target.isizes[i].size/target.ByteSize;
	align = Target.isizes[i].align/target.ByteSize;
//err.str(" size="); err.uint(size); err.str(" align="); err.uint(align); err.nl();
	if length != 0 && length <= size then	// can do with one load
	{
	    node@.child[0] = ast.Cast(node@.child[0], puinttype[i]);
	    node@.child[0]@.width = puinttype[i]@.base@.width;
	    node@.child[0] = ast.New1(LOAD, puinttype[i]@.base, node@.child[0]);
	    node@.child[1] = ast.Cast(node@.child[1], puinttype[i]);
	    node@.child[1]@.width = puinttype[i]@.base@.width;
	    node@.child[1] = ast.New1(LOAD, puinttype[i]@.base, node@.child[1]);
	    if length < size then
	    {   var mask: _uint64;
		// Assert size <= 64;
		if Target.memorder == BE then
		    mask = ~((1 << ((size-length)*8)) -1);
		else	// assume LE
		    mask = (1 << (length*8)) - 1;
		node@.child[0] = ast.New2(XOR, puinttype[i]@.base,
					  node@.child[0], node.child[1]);
		node@.child[0] = ast.New2(AND, puinttype[i]@.base,
					  node@.child[0],
					  ast.Const(puinttype[i]@.base, mask));
		node@.child[1] = ast.Const(puinttype[i]@.base, 0);
	    }
	    GenSub(node@.child[0]);
	    GenSub(node@.child[1]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    node@.width = 1;
	    if node@.op == AEQ then
		Print("\t%N = icmp eq %0T %0N, %1N\n", node);
	    else
		Print("\t%N = icmp ne %0T %0N, %1N\n", node);
	    return true;
	}
	else
	{
	    node@.child[0] = ast.Cast(node@.child[0], puinttype[i]);
	    node@.child[0]@.width = puinttype[i]@.base@.width;
	    node@.child[1] = ast.Cast(node@.child[1], puinttype[i]);
	    node@.child[1]@.width = puinttype[i]@.base@.width;
	    GenSub(node@.child[0]);
	    GenSub(node@.child[1]);
	    // calculate the number of chunks to be compared
	    node@.child[2] = ast.New2(DIV, type.wordtype,
			       ast.New2(MUL, type.wordtype, node@.child[2],
				 ast.Const(type.wordtype, elsize)),
			       ast.Const(type.wordtype, size));
	    // LLVM wants count to be register width
	    node@.child[2] = ast.ExtendT(node@.child[2], type.wordtype);
	    GenSub(node@.child[2]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    node@.width = 1;
//ast.Dump(node);
	    Print("\t%N = call i1 @memcmp%0*B(%0T %0N, %1T %1N, %2T %2N)\n", node);
	    UseIntrinsic(MEMCMP, size, puinttype[i]);
	    if node@.op == ANE then     // ugly invert in place
	    {   node@.child[0].seqno = node@.seqno;
		node@.seqno = Tseqno;  Tseqno += 1;
		Print("\t%N = xor i1 %0N, true\n", node);
	    }
	}
	return false;
    }

    proc Abs(node: Ast)
    {   var rhs, lhs: Ast;

	rhs = node@.child[0];
	lhs = ast.New1(NEG, rhs@.type, rhs);
	node@.child[0] = ast.New2(SLT, type.booltype, rhs,
				       ast.Const(rhs@.type, 0));
	node = ast.Child(node, lhs);    // must return same node
	node = ast.Child(node, rhs);    // must return same node
	node@.op = IFEXPR;
	GenSub(node);
    }

    proc MinMax(node: Ast)
    {   var rhs, lhs: Ast;
	var op: ast.Op;

	lhs = node@.child[0];
	rhs = node@.child[1];
	if node@.op
	is SMIN then op = SLT;
	is SMAX then op = SGT;
	is UMIN then op = ULT;
	is UMAX then op = UGT;
	node@.child[0] = ast.New2(op, type.booltype, lhs, rhs);
	node@.child[1] = lhs;
	node = ast.Child(node, rhs);    // must return same node
	node@.op = IFEXPR;
	GenSub(node);
    }

    /*
     * Replace rotate operations by idioms that the LLVM backend recognizes:
     * (x << n) | (x >> (32 - n))
     * (x >> n) | (x << (32 - n))
     * n == 0 gives undefined behavior, but the idiom generates good code.
     */
    proc Rotate(node: Ast)
    {   var new, lhs, rhs, nlhs, nrhs: Ast;
	var lop, rop: ast.Op;
	var t: Type;

	if node@.op == ROL then { lop = LSL; rop = LSR; }
	                   else { lop = LSR; rop = LSL; }
	lhs = node@.child[0];
	rhs = node@.child[1];
	// Get the type of thing to be rotated (lhs).  LLVM wants the
	// shift count (rhs) to be the same type.
	t = lhs@.type;
	rhs = ast.ExtendT(rhs, t);
	nlhs = ast.New2(lop, t, lhs, rhs);
	nrhs = ast.New2(rop, t, lhs,
	    ast.New2(SUB, t,
	                  ast.Const(t, lhs@.type@.size), rhs));
	node@.op = OR;
	node@.child[0] = nlhs;
	node@.child[1] = nrhs;
//err.str("new:\n"); ast.Dump(node);
	GenSub(node);
    }

    proc ZLen(node: Ast)
    {   var align: _uint;
	var t, at, bt: Type;

//err.str("ZLen:\n");
//ast.Dump(node);
	at = node@.child[0]@.type@.base;    // assert at@.kind == ARRAY
	bt = at@.base;			    // base type of array
	t = type.Clone(bt);
	t@.align = at@.align;
	t = type.MakeRef(t);
//err.str("at="); type.DumpT(at, true);  err.nl();
//err.str("bt="); type.DumpT(bt, true);  err.nl();
//err.str("t="); type.DumpT(t, true);  err.nl();
	node@.child[0]= ast.Cast(node@.child[0], t);
	GenSub(node@.child[0]);
	node@.child[0]@.type = t;
	align = _uint(node@.child[1]@.valu);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = call %T @memlen%0*A(%0T %0N)\n", node);
	UseIntrinsic(ZLEN, align, t);
    }

    proc UnaryOp(node: Ast): boolean
    {
	GenSub(node@.child[0]);
	node@.seqno = Tseqno;  Tseqno += 1;
	if node@.op
	is NOT then
	    Print("\t%N = xor %0T %0N, -1", node);
	is NEG then
	    Print("\t%N = sub %0T 0, %0N", node);
	is FNEG then
	    Print("\t%N = fsub %0T 0.0, %0N", node);
	is FCVTL then
	    Print("\t%N = fpext %0T %0N to %T", node);
	is FCVTS then
	    Print("\t%N = fptrunc %0T %0N to %T", node);
	is CVTUF then
	    Print("\t%N = uitofp %0T %0N to %T", node);
	is CVTIF then
	    Print("\t%N = sitofp %0T %0N to %T", node);
	is CVTFU then
	    Print("\t%N = fptoui %0T %0N to %T", node);
	is CVTFI then
	    Print("\t%N = fptosi %0T %0N to %T", node);
	is BSWAP then
	{   Print("\t%N = call %T @llvm.bswap.%T(%T %0N)", node);
	    UseIntrinsic(BSWAP, node@.width/target.ByteSize, node@.type);
	}
	is BITREV then
	{   Print("\t%N = call %T @llvm.bitreverse.%T(%T %0N)", node);
	    UseIntrinsic(BITREV, node@.width/target.ByteSize, node@.type);
	}
	is CLZ then
	{   Print("\t%N = call %T @llvm.ctlz.%T(%0T %0N, i1 false)", node);
	    UseIntrinsic(CLZ, node@.width/target.ByteSize, node@.type);
	}
	is CLZNZ then
	{   Print("\t%N = call %T @llvm.ctlz.%T(%0T %0N, i1 true)", node);
	    UseIntrinsic(CLZ, node@.width/target.ByteSize, node@.type);
	}
	is CTZ then
	{   Print("\t%N = call %T @llvm.cttz.%T(%0T %0N, i1 false)", node);
	    UseIntrinsic(CTZ, node@.width/target.ByteSize, node@.type);
	}
	is CTZNZ then
	{   Print("\t%N = call %T @llvm.cttz.%T(%0T %0N, i1 true)", node);
	    UseIntrinsic(CTZ, node@.width/target.ByteSize, node@.type);
	}
	is POP then
	{   Print("\t%N = call %T @llvm.ctpop.%T(%0T %0N)", node);
	    UseIntrinsic(POP, node@.width/target.ByteSize, node@.type);
	}
	is SQRT then
	{   if node@.type@.kind == FLOAT then
	    {   Print("\t%N = call %T @llvm.sqrt.%T(%0T %0N)", node);
		UseIntrinsic(SQRTF, node@.width/target.ByteSize, node@.type);
	    }
	    else
	    {   Print("\t%N = call %T @sqrti%B(%0T %0N)", node);
		UseIntrinsic(SQRTI, node@.width/target.ByteSize, node@.type);
	    }
	}
	PEndLine(node);
	return false;

    }

    proc PStringCon(node: Ast)
    {   var n: StringRange;

	if node == 0 then
	    f.str("\"\"");
	else
	{   n = StringRange(zstr.len(node@.symb@.ident, lex.StringMax));
	    PString(node@.symb@.ident, n, false);
	}
    }

    proc GetRV(node: Ast)
    {   var tl: type.TypeList;
	var ps: Symb;

	if node@.valu == 0 then
	    GenSub(node@.child[0]);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = extractvalue ", node);
	ps = node@.child[0]@.symb;
	if ps != 0 then
	    tl = ps@.retvlist;
	else
	    tl = type.TypeList(node@.child[0]@.type);	// hack
	PRetvType(tl, false);
	Print(" %0N, ", node);
	f.uint32(_uint32(node@.valu));
	f.nl();
    }

    // FIXME: re-factor to merge stuff with Call()
    proc Asm(node: Ast)
    {	var i: ast.NSubNodes;

	i = 2;
	while i < node@.num do
	{   GenSub(node@.child[i]);
	    i += 1;
	}
	f.chr('\t');
	if node@.type != 0 then		// has return value
	{   node@.seqno = Tseqno;  Tseqno += 1;
	    Print("%N = ", node);
	}
	f.str("call");
	PRetvType(type.TypeList(node@.type), false);
	f.str(" asm sideeffect ");
	PStringCon(node@.child[0]);
	f.str(", ");
	PStringCon(node@.child[1]);
	f.str(" (");
	i = 2;
	if node@.num > i then
	{   loop
	    {
		Print("%T %N", node@.child[i]);
		i += 1;
	      exit i >= node@.num;
		f.str(", ");
	    }
	}
	f.str(")\n");
    }

    // Declare parameter types and return value types
    proc DclParmRetv(ps: Symb)
    {   var tl: type.TypeList;
        var s: Symb;

	s = ps@.parmlist;
	while s != 0 do
	{   DclType(s@.type);
	    s = s@.next;
	}
	tl = ps@.retvlist;
	while tl != 0 do
	{   DclType(tl@.type);
	    tl = tl@.next;
	}
    }

    proc Call(node: Ast, indirect:boolean)
    {	var i: ast.NSubNodes;

	i = 0;
	while i < node@.num do
	{   GenSub(node@.child[i]);
	    i += 1;
	}
	f.chr('\t');
	if node@.type != 0 && node@.type@.kind != UTYPE then // has return value
	{   node@.seqno = Tseqno;  Tseqno += 1;
	    Print("%N = ", node);
	}
	if feature.tcall then f.str("tail ");
	f.str("call");
	PRetvType(node@.symb@.retvlist, false);
	if indirect then
	{   Print(" %0N(", node);
	    i = 1;	// actuals start here
	}
	else
	{   Print(" %I(", node);
	    i = 0;	// all children are actuals
	}
	if node@.num > i then
	{   loop
	    {
		Print("%T %N", node@.child[i]);
		i += 1;
	      exit i >= node@.num;
		f.str(", ");
	    }
	}
	f.str(")\n");
	if node@.symb@.forward then
	    lex.ErrorI(FORWPROC, node@.symb@.ident);
    }

    // Search AST of a procedure for
    // 1. DCLVAR so types can be pre-declared and externs/globals declared
    // 2. DCLCON so they can be declared
    // 3. SCON,CLIST so they can be declared
    // 4. CALL of external so parm and retv types can be pre-declared
    // 5. Operators that must be expanded because of lack of LLVM support.
    proc DclProcSearch(node: Ast)
    {   var i: ast.NSubNodes;
	var lhs, rhs: Ast;
	var s: Symb;
	var op: ast.Op;

	if node != 0 then
	{   if node@.op
	    is DCLVAR then
	    {   s = node@.symb;
	        DclType(s@.type);
		if s@.linkage != LOCAL then
		{   DclVar(node);
		    node@.op = NULL;
		}
		return;
	    }
	    is DCLCON then
	    {   s = node@.symb;
		if s != 0 then
		{   s@.linkage = NORMAL;	// promote linkage
		    DclCon(node);
		}
		node@.op = NULL;		// ignore for code generation
		return;
	    }
	    is SCON then
	    {   DclString(node);
		return;
	    }
	    is CLIST then
	    {   DclAggregate(node);
		return;
	    }
	    is CALL then
	    {   var ps: Symb;
		ps = node@.symb;
		if ps@.linkage == EXTERN && !ps@.declared then
		{   DclParmRetv(ps);
		    DclProc(node, false);
		    f.chr('\n');
		    ps@.declared = true;
		}
	    }
	    is ASM then return;     // ignore SCONs under an ASM
	    i = 0;
	    while i < node@.num do
	    {   DclProcSearch(node@.child[i]);
		i += 1;
	    }
	}
    }

    proc Procedure(node: Ast)
    {   var s, ps: Symb;
	var tl: type.TypeList;
	var i: ast.NSubNodes;

	ps = node@.symb;
	if ps != 0 then
	{   DclParmRetv(ps);    // declare parameter and retv types
	    // Make sure any local variables have type declared
	    // and DCLCONs are moved outside
	    DclProcSearch(node@.child[0]);
	    // Now declare the procedure with its parameters
	    DclProc(node, true);
	    if ps@.linkage
	    is INLINE then f.str(" alwaysinline");
	    is NOINLINE then f.str(" noinline");
	    if feature.size != NO then
	    {   if feature.size == MIN then
		    f.str(" minsize");
		f.str(" optsize");
	    }
	    f.str(" nounwind");
	    Section(ps@.section, false);
	    f.str(" {\n");
	    Pseqno += 1;
	    Tseqno = 1;
	    Lseqno = 0;
	    Label(Lseqno);  Lseqno += 1;
	    // allocate returned values
	    tl = ps@.retvlist;
	    i = 0;
	    while tl != 0 do
	    {   f.chr('\t');
		PRetValName(i);
		f.str(" = alloca ");
		PType(tl@.type);
		f.nl();
		i += 1;
		tl = tl@.next;
	    }
	    // allocate parameters
	    s = ps@.parmlist;
	    while s != 0 do
	    {   f.str("\t%"); f.str(s@.ident);
		f.str(" = alloca ");
		PType(s@.type);
		f.nl();
		s = s@.next;
	    }
	    s = ps@.parmlist;
	    while s != 0 do
	    {
		f.str("\tstore ");
		PType(s@.type);
		f.str(" %");
		f.str(s@.ident);
		f.str("$, ");
		PType(s@.type);
		f.str("* %");
		f.str(s@.ident);
		f.nl();
		if feature.gflag then llvmdb.DefVar(s);
		s = s@.next;
	    }
	    if !GenSub(node@.child[0]) then
	    {   f.str("\tbr label %return");
		PEndLine(node);
	    }
	    f.str("return:\n");
	    tl = ps@.retvlist;
	    if tl != 0 then
	    {   // load up returned values
		i = 0;
		while tl != 0 do
		{   f.chr('\t');
		    PTempName(Tseqno+i);
		    f.str(" = load ");
		    if feature.syntax37 then
		    {   PType(tl@.type);
		        f.str(", ");
		    }
		    PType(tl@.type);
		    f.str("* ");
		    PRetValName(i);
//		    PEndLine(node);	//FIXME: wrong line number
		    f.nl();
		    i += 1;
		    tl = tl@.next;
		}
		tl = ps@.retvlist;
		i = 0;
		if tl@.next != 0 then   // multiple returned values
		{   // first, must insert each value into aggregate
		    loop
		    {   f.str("\t%mrv"); f.uint(i);
			f.str(" = insertvalue");
			PRetvType(ps@.retvlist, false);
			if i == 0 then
			    f.str(" undef");
			else
			{   f.str(" %mrv"); f.uint(i-1);
			}
			f.chr(',');
			PType(tl@.type);
			f.chr(' ');
			PTempName(Tseqno+i);
			f.chr(',');
			f.uint(i);
			f.nl();
			i += 1;
			tl = tl@.next;
		      exit tl == 0;
		    }
		    // finally return the aggregate
		    f.str("\tret ");
		    PRetvType(ps@.retvlist, false);
		    f.str(" %mrv"); f.uint(i-1);
		}
		else		    // only one returned value
		{   f.str("\tret ");
		    PType(tl@.type);
		    f.chr(' ');
		    PTempName(Tseqno+i);
		}
	    }
	    else
		f.str("\tret void");
	    PEndLine(node);
	    f.str("}\n");
	}
    }

    proc BinaryOp(node: Ast, op: @[]Char): boolean
    {

	GenSub(node@.child[0]);
	GenSub(node@.child[1]);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = ", node);
	f.str(op);
	Print(" %T %0N, %1N", node);
	PEndLine(node);
	return false;
    }

    proc SignedBinaryOp(node: Ast, uop: @[]Char, sop: @[]Char): boolean
    {
        if node@.type@.kind == SINT then
	    return BinaryOp(node, sop);
	else
	    return BinaryOp(node, uop);
    }

    proc CompareOp(node: Ast, op: @[]Char): boolean
    {

	GenSub(node@.child[0]);
	GenSub(node@.child[1]);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = ", node);
	f.str(op);
	Print(" %0T %0N, %1N", node);
	PEndLine(node);
	return true;
    }

    proc ChangeSize(node: Ast, op: @[]Char)
    {
	GenSub(node@.child[0]);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = ", node);
	f.str(op);
	Print(" %0T %0N to %T", node);
	PEndLine(node);
    }

    proc FieldExtract(node: Ast)
    {   var tree, mask, shft: Ast;

	mask = ast.Const(type.wordtype, (1<<_uint(node.valu))-1);
	shft = 0;
	tree = node;
	while tree@.op == FIELD do
	{   if shft == 0 then
		shft = tree@.child[1];
	    else
		shft = ast.New2(ADD, type.wordtype, shft, tree@.child[1]);
	    tree = tree@.child[0];
	}
	// extract works at wordtype, force it
	tree = ast.ExtendT(tree, type.wordtype);
	if shft@.op != CONST || shft@.valu != 0 then    // FIXME - necessary?
	    tree = ast.New2(LSR, type.wordtype, tree, shft);
	tree = ast.New2(AND, type.wordtype, tree, mask);
	// now narrow to extracted type size
	tree = ast.Extend(tree, node@.type@.width, true);
	GenSub(tree);
	node@.child[0] = tree;
	node@.seqno = tree@.seqno;
    }

    proc FieldInsert(lhs: Ast, rhs: Ast): Ast, Ast
    {   var temp, mask, shft: Ast;

	mask = ast.Const(type.wordtype, (1<<_uint(lhs.valu))-1);
	shft = 0;
	while lhs@.op == FIELD do
	{   if shft == 0 then
		shft = lhs@.child[1];
	    else
		shft = ast.New2(ADD, type.wordtype, shft, lhs@.child[1]);
	    lhs = lhs@.child[0];
	}
	// insert works at wordtype, force it
	temp = ast.ExtendT(lhs, type.wordtype);
	temp = ast.New2(AND, type.wordtype, temp,
		    ast.New1(NOT, type.wordtype,
			ast.New2(LSL, type.wordtype, mask, shft)));
	// extract works at wordtype, force it
	rhs = ast.ExtendT(rhs, type.wordtype);
	// make sure its not wider than the target field
	// FIXME - uncomment for safer code
//	rhs = ast.New2(AND, type.wordtype, rhs, mask);
	rhs = ast.New2(LSL, type.wordtype, rhs, shft);
	rhs = ast.New2(OR, type.wordtype, temp, rhs);
	// now narrow to target type size
	rhs = ast.Extend(rhs, lhs@.width, true);
	// undo the load  FIXME - same as UnLoad()?
	if lhs@.op == LOAD then
	    lhs = lhs@.child[0];      // undo the lhs LOAD
	else if lhs@.op == BSWAP && lhs@.child[0]@.op == LOAD then
	{   lhs = lhs@.child[0]@.child[0];
	    rhs = ast.New1(BSWAP, rhs@.type, rhs);
	}
	else
	    lex.ErrorS(COMPILER, "FieldInsert LOAD not found");
	return lhs, rhs;
    }

    proc Load(load: Ast)
    {   var offs: Ast;

	// LLVM doesn't handle bitfields (packed records or arrays)
	// so we expand bitfield extract
	offs = load@.child[0];
	{   GenSub(offs);
	    load@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = load ", load);
	    if offs@.type@.base@.io.in then
		f.str("volatile ");
	    if feature.syntax37 then
	    {   PType(load@.type);
		f.str(", ");
	    }
	    Print("%T* %0N", load);
	    if offs@.type@.base@.unalgn then
	    {   f.str(", align ");
		f.uint64(offs@.type@.base@.align/target.ByteSize);
	    }
	    PEndLine(load);
	}
    }

    proc Store(store: Ast)
    {   var rhs, lhs, varb, tree, mask: Ast;
	var i, n: ast.NSubNodes;

	i = 0;
	n = store@.num / 2;
	while i < n do
	{   lhs = store@.child[i];
	    rhs = store@.child[n+i];
	    if (lhs != 0 && lhs@.op == FIELD) then
	    {   // We are dealing with a packed record or array (aka bitfield).
		// LLVM doesn't handle bitfields (packed records or arrays),
		// so we expand bitfield insert
		lhs, rhs = FieldInsert(lhs, rhs);
		store@.child[i] = lhs;
		store@.child[n+i] = rhs;
	    }
	    GenSub(rhs);	// rhs first
	    i += 1;
	}
	i = 0;
	while i < n do
	{   lhs = store@.child[i];
	    rhs = store@.child[n+i];
	    if lhs != 0 then
	    {   GenSub(lhs);	// then lhs
		f.chr('\t');
		f.str("store ");
		if lhs@.type@.base@.io.out then
		    f.str("volatile ");
		NodeType(rhs); f.chr(' ');
		NodeSrc(rhs);
		Print(", %K %D", lhs);
		if lhs@.type@.base@.unalgn then
		{   f.str(", align ");
		    f.uint64(lhs@.type@.base@.align/target.ByteSize);
		}
		PEndLine(store);
	    }
	    i += 1;
	}
    }

    proc Return(node: Ast): boolean
    {   var i: ast.NSubNodes;
	var rnode: Ast;

	if node@.num > 0 then
	{   i = 0;
	    while i < node@.num do
	    {   rnode = node@.child[i];
		GenSub(rnode);
		Print("\tstore %T %N, %T* ", rnode);
		PRetValName(i);
		PEndLine(node);
		i += 1;
	    }
	    node@.seqno = node@.child[0]@.seqno;
	}
	f.str("\tbr label %return");
	PEndLine(node);
	return true;	// always terminates a block
    }

    proc IfExpr(node: Ast)
    {
	GenSub(node@.child[1]);
	GenSub(node@.child[2]);
	GenSub(node@.child[0]);
	node@.seqno = Tseqno;  Tseqno += 1;
	Print("\t%N = select i1 %0N, %1T %1N, %2T %2N", node);
	PEndLine(node);
    }

    proc GenSub(node: Ast): boolean
    {   var term: boolean;	// basic block has been terminated

	term = false;
	if node == 0 then return term;
	if node@.seqno != 0 then return term;
	if node@.op
	is NOP then { GenSub(node@.child[0]); node@.seqno = node@.child[0]@.seqno; }
	is ASSERT then Assert(node);
	is FILE then
	{   if feature.gflag then llvmdb.FileStart(node@.symb@);
	    GenSub(node@.child[0]);
	    if feature.gflag then llvmdb.FileFinish(node@.symb@);
	}
	is PACKAGE then
	{   if feature.gflag then llvmdb.PackageStart(node@.symb@.ident);
	    GenSub(node@.child[0]);
	    if feature.gflag then llvmdb.PackageEnd();
	}
	is PROC then
	{   if feature.gflag then llvmdb.ProcStart(node@.symb@);
	    Procedure(node);
	    if feature.gflag then llvmdb.ProcFinish(node@.symb@);
f.flush();
	}
	is DCLVAR then DclVar(node);
	is DCLCON then DclCon(node);
	is VAR, CONST, FCON, SCON, CLIST then {}
	is AEQ, ANE then term = ArrayCompare(node);
	is SET then Set(node);
	is COPY then Copy(node, false);
	is MOVE then Copy(node, true);
	is RET then term = Return(node);
	is GETRV then GetRV(node);
	is STORE then Store(node);
	is LOAD  then Load(node);
	is FIELD then FieldExtract(node);
	is BYREF then
	{   GenSub(node@.child[0]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    if feature.syntax37 then
		Print("\t%N = getelementptr %R, %K %0N\n", node);
	    else
		Print("\t%N = getelementptr %K %0N\n", node);
	}
	is OFFSET then
	{   GenSub(node@.child[0]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    if feature.syntax37 then
		Print("\t%N = getelementptr %0R, %0K %0N, %W 0, i32 ", node);
	    else
		Print("\t%N = getelementptr %0K %0N, %W 0, i32 ", node);
	    f.uint32(_uint32(node@.valu));
	    f.nl();
	}
	is INDEX then
	{   GenSub(node@.child[0]);
	    // LLVM wants index value to be register width
	    node@.child[1] = ast.ExtendT(node@.child[1], type.wordtype);
	    GenSub(node@.child[1]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    if feature.syntax37 then
		Print("\t%N = getelementptr %0R, %0K %0N, %W 0, %1T %1N\n", node);
	    else
		Print("\t%N = getelementptr %0K %0N, %W 0, %1T %1N\n", node);
	}
	is SLICE then
	{   var nextseqno: seqnoT;
	    // Treat this like an index followed by cast back to original type
	    // Ignore the count, for now
	    GenSub(node@.child[0]);
	    // LLVM wants index value to be register width
	    node@.child[1] = ast.ExtendT(node@.child[1], type.wordtype);
	    GenSub(node@.child[1]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    nextseqno = Tseqno; Tseqno += 1;
	    if feature.syntax37 then
		Print("\t%N = getelementptr %0R, %0T %0N, %W 0, %1T %1N\n", node);
	    else
		Print("\t%N = getelementptr %0T %0N, %W 0, %1T %1N\n", node);
	    f.chr('\t'); PTempName(nextseqno);
	    Print(" = bitcast %**K* %N to %T\n", node);
	    node@.seqno = nextseqno;
	}
	is CAST then
	{   GenSub(node@.child[0]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    if node@.type@.kind == REF then
	    {   if node@.child[0]@.type@.kind == REF then
		    Print("\t%N = bitcast %0K %0N to %K\n", node);
		else
		    Print("\t%N = inttoptr %0T %0N to %T\n", node);
	    }
	    else
	    {   if node@.child[0]@.type@.kind == REF then
		    Print("\t%N = ptrtoint %0T %0N to %T\n", node);
		else
		    Print("\t%N = bitcast %0K %0N to %K\n", node);
	    }
	}
	is ZEXT then  ChangeSize(node, "zext");
	is SEXT then  ChangeSize(node, "sext");
	is TRUNC then ChangeSize(node, "trunc");
	is BSWAP, NOT, NEG, FNEG, FCVTL, FCVTS, CVTUF, CVTIF, CVTFU, CVTFI then
	    UnaryOp(node);
	is CLZ, CLZNZ, CTZ, CTZNZ, POP, BITREV, SQRT then UnaryOp(node);
	is ABS then Abs(node);
	is UMIN, UMAX, SMIN, SMAX then MinMax(node);
	is ROL, ROR then Rotate(node);
	is ZLEN then ZLen(node);
	is ADD then BinaryOp(node, "add");
	is SUB then BinaryOp(node, "sub");
	is MUL then BinaryOp(node, "mul");
	is DIV then SignedBinaryOp(node, "udiv", "sdiv");
	is MOD then SignedBinaryOp(node, "urem", "srem");
	is LSL, ASL then BinaryOp(node, "shl");
	is LSR then BinaryOp(node, "lshr");
	is ASR then BinaryOp(node, "ashr");
	is FADD then BinaryOp(node, "fadd");
	is FSUB then BinaryOp(node, "fsub");
	is FMUL then BinaryOp(node, "fmul");
	is FDIV then BinaryOp(node, "fdiv");
	is FREM then BinaryOp(node, "frem");
	is EQ then  term = CompareOp(node, "icmp eq");
	is NE then  term = CompareOp(node, "icmp ne");
	is UGT then term = CompareOp(node, "icmp ugt");
	is ULT then term = CompareOp(node, "icmp ult");
	is UGE then term = CompareOp(node, "icmp uge");
	is ULE then term = CompareOp(node, "icmp ule");
	is SGT then term = CompareOp(node, "icmp sgt");
	is SLT then term = CompareOp(node, "icmp slt");
	is SGE then term = CompareOp(node, "icmp sge");
	is SLE then term = CompareOp(node, "icmp sle");
	is FEQ then term = CompareOp(node, "fcmp oeq");
	is FNE then term = CompareOp(node, "fcmp one");
	is FGT then term = CompareOp(node, "fcmp ogt");
	is FLT then term = CompareOp(node, "fcmp olt");
	is FGE then term = CompareOp(node, "fcmp oge");
	is FLE then term = CompareOp(node, "fcmp ole");
	is AND then BinaryOp(node, "and");
	is OR then  BinaryOp(node, "or");
	is XOR then BinaryOp(node, "xor");
	is BNOT then
	{   GenSub(node@.child[0]);
	    node@.seqno = Tseqno;  Tseqno += 1;
	    Print("\t%N = xor i1 %0N, true\n", node);
	}
	is BOR then  term = Conditional(node, false);
	is BAND then term = Conditional(node, true);
	is IFEXPR then IfExpr(node);
	is CALL then  Call(node, false);
	is CALLI then Call(node, true);
	is ASM then Asm(node);
	is IF then   term = If(node);
	is SEL then  term = Select(node);
	is LOOP then term = Loop(node);
	is EXIT then term = Exit(node);
	is SEQ then
	{   var i: ast.NSubNodes;
	    i = 0;
	    while i < node@.num do
	    {   if term then
		{   // a block ends in a sequence, unreachable code
		    Label(Lseqno);  Lseqno += 1;
		    term = false;
		}
		term = GenSub(node@.child[i]);
		i += 1;
	    }
	}
	return term;
    }

    proc Gen(fd: file, tree: Ast)
    {   var i: 0..target.IntSizesMax;

	f = bout.buffer(fd, 4096);;
	// These pointer types might be useful to other packages.
	pbytetype = type.MakeRef(type.bytetype);
	i = 0;
	while i < Target.nisize do
	{   puinttype[i] = type.MakeRef(type.uinttypes[i]);
	    i += 1;
	}
	f.str("target datalayout = \"");
	if Target.memorder == BE then f.str("E"); else f.str("e");
	f.str("-p:");  f.uint(Target.ptr.size);
	f.str(":");    f.uint(Target.ptr.align);
	f.str(":");    f.uint(Target.ptr.align);
	f.str("-i1:"); f.uint(Target.isizes[0].align);
	f.str(":");    f.uint(Target.isizes[0].align);
	i = 0;
	while i < Target.nisize do
	{   f.str("-i"); f.uint(Target.isizes[i].size);
	    f.str(":");  f.uint(Target.isizes[i].align);
	    f.str(":");  f.uint(Target.isizes[i].align);
	    i += 1;
	}
	f.str("\"\ntarget triple = \"");
	f.str(target.Triple);
	f.str("\"\n");
	if feature.gflag then llvmdb.ProgStart(tree@.symb@, false);
	GenSub(tree);
	DeclareIntrinsics();
	if feature.gflag then llvmdb.ProgFinish();
	f.flush();
    }
}
// vim: ts=8 sw=4 noet nowrap

